<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 基本認識與常用指令整理]]></title>
    <url>%2Flinux-basic.html</url>
    <content type="text"><![CDATA[Linux 檔案系統架構理論上所有 Linux 發布版都應該要遵守 Linux 檔案系統的標準（Filesystem Hierarchy Standard, FHS)，但不同版本可能會有些許差異，大致結構如下： 根目錄(/)底下的目錄 目錄名稱 說明 例 /bin 放一些一般使用者可以操作的指令。連結到 /usr/bin kill、cp.. /sbin 放置系統管理員可以操作的指令。連結到 /usr/sbin /boot 系統開機相關的一些載入檔 /etc 系統設定檔案 /home 主要是一般帳戶的家目錄 /root 系統管理者的家目錄 /lib, /lib64 主要為系統函式庫和核心函式庫，若是 64 位元則放在 /lib64。連結到 /usr/lib, /usr/lib64 /proc 整個系統的運作資訊 /sys 與 /proc 類似，但主要針對硬體相關參數 /usr 全名為 unix software resource 縮寫，放置系統相關軟體、服務（注意不是 user 的縮寫） X-Window /var 記載著各種系統上的變數的地方 /tmp 全名為 temporary，放置暫存檔案(雜七雜八的東西) /media 放置隨插即用的裝置慣用目錄 /mnt 為管理員、使用者手動掛上（mount）的目錄 /opt 全名為 optional，通常為第三方廠商放置軟體處 /srv 通常是放置開發的服務（service），如：網站服務 www 等 /vmlinuz 系統核心檔案 lost+found 系統檢查結果 /run 系統進行服務軟體運作管理處 /cdrom 光碟機裡的資料被掛上來的地方 /dosc 開機時把 dos 檔案系統掛上來的地方 /dev 放置 device 裝置檔案，鍵盤滑鼠等 基本指令1. 資料夾與檔案處理mkdir建立資料夾 結構： mkdir [OPTION] DIR 參數： -p：多層目錄同時創建 範例： 12345# 新增 myDir 資料夾mkdir myDir# 多層目錄mkdir -p dir1/dir2/dir3 rmremove - 刪除檔案或資料夾 結構： rm [OPTION] FILE 參數： -r：刪除資料夾 -f：強制刪除 範例： 12345# 刪除檔案rm abc.txt# 刪除資料夾rm -r myDir lslist - 列出資料夾下內容 結構： ls [OPTION] DIR 參數： -l：列出詳細檔案資訊 (權限、日期等) -a：也列出隱藏檔案 -R：遞迴，也列出子資料夾內的所有檔案及資料夾內容 範例： 12345678# 只列出檔名ls# 也列出隱藏檔案，外加詳細資訊ls -al# ls -al 的縮寫ll cdchange directory - 切換工作目錄 範例： 1234567891011# 進入 myDir 資料夾cd myDir# 回上層目錄cd ..# 進入"家目錄"cd ~# 進入"根目錄"cd / pwdprint working directory - 列出當前工作目錄 範例： 1pwd cpcopy - 複製資料夾或檔案 結構： cp [OPTION] SOURCE DEST 【 cp -參數 來源檔(或目錄) 目的檔(或目錄) 】 參數： -r：針對目錄下檔案做遞歸複製(白話：整個目錄下每一個檔案複製到你想要的位置) -p：將檔案本身屬性(權限、所有者、時間)同時複製過去(一般用於備份居多) -f：拷貝時若相同檔名的檔案直接複蓋不提出警告(強制複製) -i：如果要複製過去的位置已經有相同檔案，會在覆蓋前詢問是否持續進行 -s：複製成符號連結檔(symbolic link)(白話：複製成捷徑檔) 範例： 123456789101112131415161718192021222324# 將 a.txt 複製成一份 b.txt (若操作的目標在當下目錄內，也可以不加./)cp ./a.txt ./b.txt# 等同於cp a.txt b.txt# 將 myDir 整個資料夾包含檔案複製成一份 myDir2cp -r ./myDir ./myDir2# 等同於cp -r myDir myDir2# 將 from.txt 檔案從當下工作目錄中的 myDir 目錄，複製到當下工作目錄中的 myDir2 目錄下，並改名為 to.txtcp myDir/from.txt myDir2/to.txt# 將跟目錄中的 from 目錄下的 user 目錄，連同檔案整個複製到跟目錄中的 to 目錄cp -r /from/user /to/# 將跟目錄中的 source 目錄下的 user 目錄，連同檔案與屬性整個備份到跟目錄中的 backup 目錄cp -rp /source/user /backup/# 複製多個檔案到跟目錄中的 to 目錄夾cp a.txt b.txt /to/# 利用萬用符號 * 複製多個符合 .mp3 檔案到 to 目錄夾cp /from/*.mp3 /to/ 補充說明：像是特殊權限檔案 (/etc/shadow)，密碼檔、設定檔 …等，需要加上 -a 或 -p 參數，才能完整複製檔案。如果複製過程希望有進度條功能，建議改用 scp 或 rsync 指令 mvmove - 移動或重命名資料夾或檔案 結構： mv [OPTION] SOURCE DEST 【 mv -參數 來源檔(或目錄) 目的檔(或目錄) 】 參數： -b：移動之前先做備份 -v：做完移動之後顯示所做的移動情形 -f：強迫性移動，不會詢問使用者是否確認 123456789101112# 將當下目錄 a.txt 改名成 b.txt (若操作的目標在當下目錄內，也可以不加./)mv ./a.txt ./b.txt# 等同於mv a.txt b.txt# 將當下目錄 myDir 資料夾改名成 myDir2 (若操作的目標在當下目錄內，也可以不加./)mv ./myDir ./myDir2# 等同於mv myDir myDir2# 將當前目錄中的 myDir 目錄中的所有檔案，移動到當前目錄中的 myDir2 目錄中mv myDir/* myDir2/ rmremove - 刪除檔案或資料夾 結構： rm [OPTION] FILE 參數： -r：刪除資料夾 -f：強制刪除 範例： 12345# 刪除檔案rm abc.txt# 刪除資料夾rm -r myDir find在指定資料夾與其子資料夾搜尋檔案，輸出符合條件資料之路徑 參數： -name：指定檔案(目錄)名稱 -iname：不區分大小寫 範例： 基礎 1234# 查詢當前目錄下的檔名為 a.txt 的檔案 (. 可省略，不給值預設就是查詢當下目錄)find . -name 'a.txt'# 查詢 HOME 目錄下所有 txt 檔案，$HOME 是 Linux 下的一個環境變數，預設指向執行帳號的 HOME 目錄find $HOME -name '*.txt' 「或」邏輯運算符 12# 在 HOME 目錄下尋找 html 和 js 檔案find $HOME -name '*.html' -o -name '*.js' 指定檔案類型 12345# 指定只要搜尋「檔案」名稱find /var/log -type f -iname '*.txt'# 指定只要搜尋「檔案」名稱find /var/log -type d -iname 'myDir' 檔案大小 12345# 找尋所有檔案大小大於 50MB 的檔案 (不加上 -name 代表搜尋全部檔案)find /var -type f -size +50M# 找尋所有檔案大小小於 50MB 的檔案find /var -type f -size -50M 時間 1234567891011121314# 尋找超過 7 天沒有被存取或修改過的檔案 (判斷檔案存取時間)find $HOME -type f -atime +7# 尋找曾經在 7 天內被存取或修改過的檔案 (判斷檔案存取時間)find $HOME -type f -atime -7# 尋找超過 10 分鐘沒有被存取或修改過的檔案 (判斷檔案存取時間)find $HOME -type f -amin +10# 尋找曾經在 10 分鐘內被存取或修改過的檔案 (判斷檔案存取時間)find $HOME -type f -amin -10# 尋找檔案建立時間已超過 30 天的檔案find $HOME -type f -ctime +30 使用者 12尋找特定使用者的檔案find $HOME -type f -user dylan.liu237 exec 執行 指令解釋：尋找名字為 a.txt 的檔案，透過 -exec 指令將輸出結果 (a.txt 檔案路徑)，丟入 cat 執行，印出檔案內文本。 1find ~ -type f -iname 'a.txt' -print -exec cat &#123;&#125; \; ~ (相當於 $HOME) 目錄 指令最後一個分號前一定要加上反斜線 加上 –print 是為了讓被刪除的檔案檔名一併顯示在畫面上，這個參數可以省略 使用 –exec 會讓查詢到的每一個檔案路徑代入 {} 位置，一個檔案會執行一遍 cat 命令 12# 補充，上面的 exec 範例也可以用原生的 xargs 指令達成相同效果find ~ -type f -name 'a.txt' | xargs cat 實用範例： 12345# 在當前目錄中，找出檔案大小在 10 MB 以上的 mp3 檔案，並刪除。find . -type f -name '*.mp3' -size +10M -exec rm -f &#123;&#125; \;# 在當前目錄中，找出所有 js 檔，透過 grep 搜尋檔案內的原始碼，過濾出含有 Hello World 單字的檔案，列出所有符合條件的檔案列表find . -type f -name '*.js' -exec grep -wl Hello World &#123;&#125; \; diff以逐行的方式，比較文本文件的異同處。如果指定要比較目錄，則 diff 會比較目錄中相同文件名的文件，但不會比較其中子目錄 參數： -c：(上下文模式) 顯示差異處的前後內文，並標出差異處 -u：(Git diff 模式) -y：(並排模式) -b：不比較空白字元 -B：不比較空白行數 -w：忽略全部的空白和 tab -i：忽略大小寫 -l：忽略指定字串的差異 -q：僅顯示是否有差異，不顯示其餘訊息 用法參考： Linux 下文本比对方法:diff 命令 Linux 下 diff 命令用法详解 2. 文本處理cat將檔案內容印在終端機上。 參數： -n：由 1 開始對所有輸出的行數編號 -b：和 n 類似，不過空白行不編號 -s：當遇到兩行以上空白行，就合為一行空白行 -E：在每行結束點顯示 $ 符號 範例： 12345# 將 a.txt 內容加上行號，並覆寫 b.txt 內容cat -n a.txt &gt; b.txt# 將 a.txt 內容加上行號(空白行不加)，並追加進 b.txt 現有內容之後cat -b a.txt &gt;&gt; b.txt 實用範例： 12# 清空 a.txt 內容cat /dev/null &gt; a.txt echo印出一行文本 範例： 1234567891011# output: It is a stringecho 'It\'s a string'# 換行顯示 (-e 開啟轉譯)echo -e 'OK! \n'# 不換行echo -e 'OK! \c'# 顯示日期 (注意：這裡是反引號 ` 而不是單引號 ')echo `date` 範例 2： 以下程式碼儲存為 test.sh 檔案 123#!/bin/shread nameecho "$name It is a test" 執行 sh test.sh，後輸入字串，該字串將成為 shell 變數 ($name) 123[root@www ~]# sh test.shOK # 輸入OK It is a test # 輸出 實用範例： 12# 以 "It is a test" 字串覆蓋 a.txt 內容echo "It is a test" &gt; a.txt grep用關鍵字找尋檔案 結構： grep [OPTION] 內容關鍵字 [檔名條件] [目錄或檔案路徑] 參數： -r：遞歸搜尋，搜尋指定目錄還有其子目錄內容 -a：不忽略二進位資料 -A&lt;顯示行數&gt;：除了符合關鍵字的行內容，額外多顯示該行”之後”的內容(多的行數就是你所指定的數字) -B&lt;顯示行數&gt;：同 -A，但是是多顯示”之前”的內容 -C&lt;顯示行數&gt;：同 -A -B，前後的內容都顯示，顯示的行數就是指定的數量 -v：反向搜尋 -E：將關鍵字用正則表達式使用 -i：忽略大小寫 -n：顯示行數 範例： 1234567891011121314# 在當前目錄搜尋檔名結尾為 file 且內容含有 hello 字串的目標，並將該檔案符合該字串的行內容輸出grep 'hello' *file# 檔名後綴符合的檔案(根目錄下包含跟目錄下所有子目錄)grep -r 'hello' file* /# 多個關鍵字grep -r 'hello|world' file* /# 反向搜尋，找出不含關鍵字的行數grep -v 'hello' file* /# 搭配 pipe 篩選資料，例如篩選出含有 network 的輸出內容ls /etc/ | grep 'network' 正則： 1234567891011# a 開頭ls | grep "^a"# b 結尾ls | grep "b$"# a 或 b 開頭ls | grep "^[ab]"# a 或 b 結尾ls | grep "[ab]$" wc利用 wc 指令我們可以計算檔案的位元組數，字數，或者列數，如果不指定檔案名，或者所造成的檔案稱為’-‘，則 wc 指令會從標準輸入設備讀取資料。 參數： -l：只顯示行數 -w：只顯示字數 (單字) -c：只顯示 Bytes 數 範例： 12# a.txthello a.txt 12wc a.txt# output: 1 2 14 a.txt -&gt; 行數 字數 Bytes數 檔名 sort預設將檔案內容依照 ASCII 碼的次序排列，再輸到終端 參數： -b：忽略美航前面開始出的空格字元 -d：排序時，處理英文字母、數字及空格字符外，忽略其他的字符 -f：排序時，將小寫字母視為大寫字母 -o&lt;輸出檔案 &gt;：將排序後的結果存入指定的檔案。 r：以相反的順序來排序。 範例： 1234$ cat testfile #testfile文件原有排序test 30Hello 95Linux 85 使用 sort 指令 1sort testfile 輸出 123Hello 95Linux 85test 30 3. 系統管理Linux 系統對於檔案設有三種權限，分別為讀 Read、寫 Write、執行 eXecute，另外不同的角色能擁有的檔案權限都不同，角色則分別有使用者 user、群組 group、其他 others 三種，輸入 ls -l 指令後可以觀察到所有檔案和目錄的權限資訊。想深入學習可以閱讀鳥哥的第五章 - Linux 的檔案權限與目錄配置。 圖片來源： https://www.eebreakdown.com/2016/08/linux.html#sec-5 圖片來源： 鳥哥 chmodLinux 的檔案角色權限分為三級：使用者 user、群組 group、其他 others ，利用該指令可以控制檔案如何被他人利用。 參數： u (使用者)、g (群組)、o (其他)、a (全部) + (增加權限)、- (取消權限)、= (唯一設定權限) r (可讀取)、w (可寫入)、x (可執行)、X (只有該檔案是個子目錄或該檔案已經被設定過為可執行) 其他參數： -f：若該檔案權限無法被更改也不要顯示錯誤訊息 -v：顯示權限變更的詳細資料 -R：遞歸，對該目錄下所有檔案與子目錄進行相同權限變更 範例： 12345678910# 將檔案 a.txt 設定為所有人皆可讀取chmod ugo+r a.txt# 同上chmod a+r a.txt# 將檔案 a.txt 和 b.txt 設定為該檔案的擁有者，與其所屬同一個群組可寫入，但其他人不可寫入chmod ug+w,o-w a.txt b.txt# 將 ex.py 設定為只有該文件擁有者可以執行chmod u+x ex.py# 將該目錄所有檔案和子文建設為任何人皆可讀取chmod -R a+r * 另外權限也可以用數字來表示，語法為： 1chmod abc file a,b,c 各為一個數字，分別代表 User、Group、others 的權限 權重表：| Read | Write | eXecute || ——– | ——– | ——– || 4 | 2 | 1 | 若要 rwx 權限，則 4+2+1=7，也就是 7 代表著最高權限，若要 rw 權限，則 4+2=6.. 以此類推 範例： 1234567chmod a=rwx a.txt# 相當於chmod 777 a.txtchmod ug=rwx,o=x a.txt# 相當於chmod 771 a.txt chownLinux/Unix 是多人多工作業系統，所有的檔案皆有擁有者。利用 chown 將指定檔案的擁有者改為指定的使用者或組，使用者可以是使用者名或者使用者 ID；組可以是組名或者組 ID；檔案是以空格分開的要改變權限的檔案。 一般來說，這個指令只有是由系統管理者(root)所使用，一般使用者沒有權限可以改變別人的檔案擁有者，也沒有權限把自己的檔案擁有者改設為別人。只有系統管理者(root)才有這樣的權限。 參數： -f：若該檔案權限無法被更改也不要顯示錯誤訊息 -v：顯示權限變更的詳細資料 -R：遞歸，對該目錄下所有檔案與子目錄進行相同權限變更 使用 chown 指令前可以先透過 ls -l 來查看或是確認欲更改檔案的擁有者及群組。 圖片來源： 鳥哥 範例： 將 a.txt 的擁有者改為 usera 1sudo chown usera a.txt 將 a.txt 的群組改為 groupa，第一個參數須以冒號開頭，代表更改群組。 1sudo chown :groupa a.txt 同時更改使用者及群組 1sudo chown usera:groupa a.txt 預設情況下，使用 chown 指令後並不會出現任訊息(除非出現錯誤)，若要讓 chown 明確顯示更改結果，要加上 -v 參數 1sudo chown -v usera a.txt 若不想輸出任何錯誤訊息，可以加上 -f 1sudo chown -f usera a.txt 如果要一次修改某個目錄下所有檔案與子目錄的擁有者與群組，可以使用 chown 加上 -R 參數來處理 1sudo chown -R usera:groupa myDir 如果想要把某檔案的擁有者與群組改成和另一個檔案一樣 12# 將 myDir 的擁有者與群組改成和 refDir 一樣sudo chown --reference=refDir myDir 實用範例 12# 找出目前目錄下所有的 *.c 檔，並將這些檔案的擁有者與群組改為 myuser:mygroupsudo find ./ -name *.c -exec chown myuser:mygroup &#123;&#125; \; suswitch user - 切換到其他 Linux 用戶，但是不切換環境變數，除 root 外，需要輸入該使用者密碼，所有使用者皆有權限使用該指令。 參數： -m -p：執行 su 時，不改變環境變數 -c ：變更帳號後執行後面接著的指令，再切回原來的使用者 -s：指定要執行的 shell，預設值為 /etc/passwd 內該使用者的 shell - -l：加了這個參數後，就好像重新 login 為該使用者一樣，大部分環境變數都是以該使用者為主，並且工作目錄也會改變，如果沒有指定使用者，預設為 root 範例： 取得 root 權限。執行 su 並輸入密碼後，可以取得 root (最高) 權限。 1su 忘記 root 密碼解決方式：在 Ubuntu 下第一次使用 root 時會提示要求你輸入密碼，你可能會發現自己根本沒有設置過密碼。輸入指令 sudo passwd root，終端會提示你 Enter new UNIX password 和 Reentry new UNIX password，建立一個 root 帳戶就可以了，看到 password updated successfully 就表示成功了。 不過要注意，在這種情況下，雖然使用者帳號的 user id 變成 0 (root 的 user id)，但其他的環境變數並沒有跟著改變。 若是單純要以 root 權限做一些更改檔案的小變動，用這個指令就夠了。但是如果需要進行·以較複雜的系統管理，牽涉到許多 root 帳號的環境變數 (例如 PATH 或 MAIL)時，就要改用下面的方式 1su - 這個指令相當於用 root 重新登入一樣，進入一個完整的 shell 環境。 使用以上兩種方式，都會開啟一個新的 shell 環境，完成工作後需要輸入 exit 才會離開該環境。若你的操作並不複雜可以使用 -c 參數，後面接著你想執行的 shell 指令，如此的話不會進入新的 shell 環境，而是使用 root 權限執行完該指令後，回到原先的帳號 shell 環境。 123456su - -c 'env | grep root'# output:# USER=root# PWD=/root# HOME=/root# LOGNAME=root 除了讓一般使用者可以使用 root 權限以外，也可以取得其他非 root 帳號的權限 1su -l dylan.liu237 該指令可以取得 dylan.liu237 這個帳號的權限，而這裡的密碼就必須輸入這個帳號的密碼。如果是以 root 身份執行則不需要輸入密碼。 sudosudo 類似 su 指令，也是用來取得 root 或是其他帳號權限，但他在使用上是輸入自己的密碼，而不是 root 或其他帳號的密碼，使用上更方便。 Ubuntu Linux 系統預設在安裝時基於安全考量，並不會啟用 root 帳號，無法用 root 直接登入系統，所有的系統管理動作都是透過 sudo 來取得 root 權限。 參數： -l：印出自己(執行 sudo 的使用者)的權限 -V：列出 sudo 的版本資訊 -u ：以另一個 user 身份執行指令 -s：執行環境變數中的 SHELL 所指定的 shell，或 /etc/passwd 裡所指定的 shell sudo 用起來和 su -c 很類似，執行完指令後會自動離開 root 的 shell 環境 1234567# 查看環境變數，因為使用 sudo 指令，輸出的變數為 root 的環境變數sudo 'env | grep root'# output:# USER=root# PWD=/root# HOME=/root# LOGNAME=root 如果要查看 dylan.liu237 這個帳號的環境變數，可以切換到該帳號權限，再做查看 12345678sudo -u dylan.liu237 env | grep dylan.liu237# output:# HOME=/home/dylan.liu237# MAIL=/var/mail/dylan.liu237# LOGNAME=dylan.liu237# USER=dylan.liu237# USERNAME=dylan.liu237# SUDO_USER=dylan.liu237 也可以取得特定群組的權限，例如取的 adm 全組權限後，看系統記錄檔 1sudo -g adm view /ver/log/syslog 實用範例： 透過這個指令可以利用 sudo 不需要輸入密碼的特性，開啟一個 root 的 shell 環境，很常在 Ubuntu Linux 中使用。 1sudo su - 補充： sudo 可以不需要 root 密碼情況下取得 root 權限，在正常情況下當然不可能讓任何使用者都可以使用 root 權限，他是依據 /etc/sudoers 設定檔來控管的。只有在這個檔案中有被特別設定的使用者才可以使用 sudo 指令。 編輯 /etc/sudoers 時，建議使用 visudo 指令來開啟 vi 編輯器進行編輯，系統將在編輯完成時檢查語法是否正確，避免錯誤語法造成 sudo 無法使用。使用指令： sudo visudo -f /etc/sudoers /etc/sudoers` 對個別使用者的設定與法格式如下 1帳號名稱 來源主機=(可切換帳號) 可執行命令 帳號名稱 來源主機 可切換帳號 可執行命令 可以使用 sudo 的帳號名稱 限制使用者從特定網路主機連線時，才能使用 sudo 指令，可用來防止入侵者從不明的主機登入攻擊。若指定為 ALL 則代表不限制來源主機。 可以取得哪些帳號的權限。若指定為 ALL 則代表可以取得任何帳號的權限。 在取得特殊權限後，可以執行的指令。若指定為 ALL 則代表可以執行任何令。 個別使用者設定： 若要讓 dylan.liu237 帳號可以使用 sudo 執行所有指令，需在 /etc/sudoers 加入此行 1dylan.liu237 ALL=(ALL) ALL 允許使用者使用 sudo 指令取的 root 權限，就等於讓使用者成為系統管理者，並不建議這樣做。理想的情況，可以建立一個使用者專門管理其他使用者密碼的，可以把它定義為一個密碼管理員帳號，可以透過以下方式實現 1accmgr ALL=(root) /usr/bin/passwd 上面這樣的寫法有一個問題，就是該使用者也可以更改 root 的密碼，如果 root 帳號可以被更改，代表整個該帳號可以透過更改 root 密碼來取得系統的最高管理權限，可以加上以下設定防止 1accmgr ALL=(root) !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root 以上設定加上了更多限制 - !/usr/bin/passwd： 不許該帳號使用 /usr/bin/passwd 指令 - /usr/bin/passwd [A-Za-z]： 只允許更改一般使用者密碼 - !/usr/bin/passwd root： 禁止更改 root 密碼 群組設定： 對特定群組底下帳號一次開放權限，可以直接對特定群組進行定義 1%群組名稱 來源主機=(可切換帳號) 可執行的指令 群組設定和使用者設定只差在群組名稱前的 % 前綴，其他欄位皆相同。如果要讓 groupa 群組下的所有使用者都可以用 sudo 指令，可以這樣設定 1%groupa ALL=(ALL) ALL 不需輸入密碼： 想讓特定群組或使用者可以在不須輸入密碼的情況下，直接使用 sudo，可以加入 NOPASSWD 設定 沒有加入 NOPASSWD 設定，預設五分鐘後必須再次輸入密碼 1234// 使用者dylan.liu237 ALL=(ALL) NOPASSWD:ALL// 群組％groupa ALL=(ALL) NOPASSWD:ALL 使用 Alias：有些情況 /etc/sudoers 的設定比較複雜，例如同時設定多個使用者或是多個允許指令，可以用 alias 做到類似變數的概念來管理 123User_Alias MYACC = acc1, acc2, acc3Cmnd_Alias MYEXE = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd rootMYACC ALL=(root) MYEXE passwd更改使用者密碼 passwd 指令可以變更使用者密碼，對於非 root 使用者而言，執行 passwd 後需輸入現行密碼後才可以更改密碼;如果是 root 則不需要，並可以更改所有使用者的密碼，包含 root 自己。 /etc/passwd 目錄儲存的是作業系統使用者訊息，該檔案為所有使用者可見。 /etc/shadow 被稱為 /etc/passwd 的影子檔案。它們之間的內容是互補的。shadow 內容包括使用者及被加密的密碼以及其它 /etc/passwd 不能包括的訊息，比如使用者的有效期限等。 # 參數： -S：顯示密碼狀態資訊 -aS：顯示所有帳號訊息 -d：移除使用者密碼 -e：設定密碼過期狀態 -l：鎖定使用者密碼 -u：解除鎖定使用者密碼 -n ：設定每隔多久才能變更一次密碼 -x ：設定每隔多久需要更換一次密碼 -w ：過期前幾天給予使用者變更密碼警告 -i ：設定寬限期，在過期後幾天使用者還是可以照常登入，過期後帳號即無法登入 範例： 修改自己的密碼，需要輸入現行密碼(root 修改自己的密碼也是一樣的指令，但是不需輸入密碼) 12345passwd# (current) UNIX password:# Enter new UNIX password:# Retype new UNIX password:# passwd: password updated successfully root 使用者更改其他使用者密碼，不需輸入現行密碼 1234sudo passwd dylan.liu237# Enter new UNIX password:# Retype new UNIX password:# passwd: password updated successfully 顯示密碼狀態資訊 12345# 查看自己的密碼資訊passwd -S# 以 root 帳號查看其他使用者密碼資訊sudo passed -S dylan.liu237 印出結果 1dylan.liu237 L 07/17/2020 0 99999 7 -1 輸出七個欄位，對應的資訊如下 帳號名稱 密碼狀態，狀態包含鎖定密碼（L）、無密碼（NP）與可用密碼（P。 上次修改密碼的時間。 密碼最短使用期限（minimum password age），單位為天。 密碼最長使用期限（maximum password age），單位為天。 密碼過期前警告期間（password warning period），單位為天。 密碼過期後可使用的期間（password inactivity period），單位為天。 顯示所有帳號密碼資訊 (root 權限) 1sudo passwd -aS 移除使用者密碼 1sudo passwd -d dylan.liu237 變更密碼過期狀態。有時候因為某些原因，例如重新設定密碼後，會希望使用者立刻更改自己的密碼，這時候可以使用 -e 參數 1sudo passwd -e dylan.liu237 1passwd: password expiry information changed. 接著檢查狀態資訊 1sudo passwd -S dylan.liu237 1dylan.liu237 P 01/01/1970 0 99999 7 -1 這時候如果使用者使用 SSH 登入的話，系統就會強制更新密碼 1ssh dylan.liu237@34.80.206.16 123456789*** System restart required ***Last login: Tue Sep 1 07:33:24 2020 from 211.21.120.39WARNING: Your password has expired.You must change your password now and login again!Changing password for dylan.liu237.(current) UNIX password:Enter new UNIX password:Retype new UNIX password:passwd: password updated successfully 鎖定使用者密碼。使用參數 -l 可以鎖定使用者密碼 1sudo passwd -l dylan.liu237 檢查使用者狀態 1sudo passwd -S dylan.liu237 1dylan.liu237 L 09/01/2020 0 99999 7 -1 在鎖定之後，系統會在 /etc/shadow 的密碼欄位之前加上 !，在這個情況下該使用者無法更新自己的密碼 1dylan.liu237:!$6$aihNuUv/$c9jjnkmLa376aJ08gYXITIje8KECL25NMdVVGLOk4O4RVYEP5BrDEcTSAfAyjpV7wSABq7P89fUH.5b9cMrTN/:18506:0:99999:7::: 解除鎖定可以使用 -u 參數 1sudo passwd -u dylan.liu237 設定密碼期限，至少每隔三天才可以變更一次密碼，設置為 0 代表可以任意變更密碼 1sudo passwd -n 3 dylan.liu237 設定密碼有效期限，每 30 天需要更換一次密碼 1sudo passwd -x 30 dylan.liu237 密碼過期前 7 天警告 1sudo passwd -w 7 dylan.liu237 當使用者密碼過期後，會有一段寬限期(inactivity period)，過了以後就無法登入，可以透過 -i 參數設定該時間 1sudo passwd -i 10 dylan.liu237 4.其他man查詢指令說明 12# 查詢 ls 指令說明man ls history列出歷史指令 1history 快捷鍵常用Ctrl + C中斷目前畫面上操作 (中斷前景程序 process) Ctrl + D離開 (等同 exit 指令 + Enter) Ctrl + Z將目前畫面上操作切到背景 (不中斷操作) Ctrl + L清理畫面 (等同 clear 指令) Ctrl + R根據關鍵字查詢過往輸入的 Linux 指令 移動光標Ctrl + A移到行首 Ctrl + E移到行尾 Ctrl + XX在命令行尾和光標間切換 刪除字Ctrl + W刪除光標前的一個單字，這樣就不用每次都要按折 delete 一個一個字刪除了 Ctrl + K刪除光標後所有字，搭配 Ctrl + A 可以刪除整行 Ctrl + U刪除光標前所有字，搭配 Ctrl + E 可以刪除整行 ⌥ + 左右箭頭 (MAC)以單字為單位前後切換光標 References Linux 指令大全 Linux 常用指令-cp-複製檔案與目錄 【Ｌ】Linux 常用指令集 Unix/Linux 的 find 指令使用教學、技巧與範例整理 Linux 更改檔案擁有者與群組，chown 指令使用教學與範例 Linux 的 su 與 sudo 指令教學與範例 Linux 的 su 與 sudo 指令教學與範例 Linux 的 passwd 指令範例教學]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 入門紀錄]]></title>
    <url>%2Fdocker.html</url>
    <content type="text"><![CDATA[概念海 → VPS鯨魚 → Docker貨櫃 → Container，來自單個或數個 Image installation方法 1Docker (docker-ce) installation for Ubuntu 16.04 and Ubuntu 18.04 將 docker_installer.sh 檔案放到 VPS 上，執行: 1bash docker_installer.sh 方法 2下載安裝腳本 sh install-docker.sh # 執行安裝腳本 12curl https://get.docker.com/sh install-docker.sh 不加 sudo 执行 Docker 命令 Hello World將 Docker Hub 用來練習的 Hello World 映像檔拉進 VPS 1docker run hello-world 背後運作 在本機端(VPS)尋找是否有 Hello World 映像檔，若有直接將該 image 運行成一個 container 若沒有，從 Docker Hub 上拉取對應的 image 並運行 若 Docker Hub 也沒有，拋出錯誤訊息 Docker 基本指令幫助命令版本查詢1docker version 查看 Docker 資訊1docker info 常用指令1docker --help 查看特定指令細節說明 1docker help COMMAND image 相關命令列出現有的 images1docker images [OPTIONS] REPOSITORY TAG IMAGE ID CREATED SIZE 倉庫源(唯一) 版本 ID(唯一) 創建日期 檔案大小 同一個倉庫源可以有個 tag，代表不同版本(e.g 3.2)，使用 REPOSITORY:TAG 來定義不同的 image，如果不指定版本標籤預設為 lastest (e.g ubuntu:latest) options -a (列出本地所有images，包含中間層) -q (只顯示image ID) --digests (顯示image的摘要訊息) --no-trunc (顯示完整的image訊息)查詢遠端倉庫(docker hub)的 image1docker search [OPTIONS] REPONAME options -s [number] (列出 stars 數不小於[number]的 repo) --automated (只列出 automated build 類型的 images) --no-trunc (顯示完整的image訊息)下載遠端倉庫(docker hub)的 image1docker pull REPONAME[:TAG] 若不加上:TAG參數，預設下載最新版本(latest)，若需指定版本e.g docker pull nginx:3.2 刪除 image1docker rmi [OPTIONS] IMAGE[:TAG] 若不加上:TAG參數，預設刪除最新版本(latest) 可刪除多個，只需在 imageName 後加空白，接續著要刪除的 imageName options -f (強制刪除，即使在運行中)刪除所有 images12docker rmi -f $(docker images -q)docker rmi -f $(docker images -qa) (包含所有中間層) $() 可以解釋為一個子命令，docker images -q 如上面說明，可羅列出宿主機器所有 image 的 id，搭配起來即可刪同時刪除所有 id 被羅列的 image。 12docker images -q | xargs docker rmi -fdocker images -qa | xargs docker rmi -f (包含所有中間層) 將 | 前指令產生的字串作為參數，傳入 | 後的指令中 (Linux 原生指令) 列出 image 歷史1docker history IMAGE Container 相關命令將 image 實例化為 container 並執行1docker run [OPTIONS] IMAGE options --name (為該容器命名) -d (啟動守護式容器(常用於後台應用) -&gt; 不需與 container 終端交互) -i (啟動互動式容器(常用於前台應用) -&gt; 登入 container 時可與終端交互，通常與 -t 同時使用) -t (自動打開該 container 終端介面) -P (隨機 port 映射) -p [vps port]:[container port] (指定 port 映射)運行交互式容器12docker run -it --name mycentos centos /bin/bash# /bin/bash 為進入容器終端機後的路徑，可不寫，預設是即是 /bin/bash 以 centos 映像開啟一個名為 mycentos 的交互式 container。使用 -it 選項會直接進入該 container 的終端介面(紅框處)，該紅框處的 SHA 值則對應此 container 的 ID 運行守護式容器1docker run -d --name mycentos centos 開啟守護式容器成功後，系統會返回一個 conatainer ID，證明已經開啟成功。不過有個需注意的地方，在成功開啟後，再以 docker ps 查詢運行中容器時，卻發現沒有發現該容器(如上圖)。 原因是在該容器成功實例化並執行後，由於沒有任何前台進程，所以很快又就被 docker 自動清除掉了。參考 上述問題是由於 docker 機制所導致，docker 後台容器要運作，就必須有一個前台進程 如何讓前台有進程執行？ 1docker run -d centos bin/sh -c "while true;do echo hello;sleep 2;done" 該指令每兩秒會在終端機 log 一次 ‘hello’ 字串，如此一來有進程正在執行，docker 就不會自動清除該容器。 列出 docker 所有運行中的 container1docker ps [OPTIONS] options -a (列出正在運行及歷史上運行過的容器) -l (列出最近一個執行的容器) -n [number] (列出最近[number]個運行的容器) -q (只顯示容器編號)停止 container在 container 環境中的終端執行 container 停止並退出 1exit 重啟”已關閉(exited)”容器 docker ps -l -&gt; 列出上一個被操作的容器，記下 ID SHA 值 或 容器名稱 docker start NAME|ID -&gt; 重啟 重啟並進入 container 交互終端docker start NAME|ID -i container 不停止並退出 1ctrl + P + Q 如何證明容器沒有被關閉？ docker ps 查看該 container 的 status 是否為 up 可透過 attach 指令重新進到”不停止退出”的容器，下面會有該指令介紹。 在 宿主機 環境中的終端執行 正常停止，需等待 (建議使用) 1docker stop NAME|ID 強制停止，立即關閉 1docker kill NAME|ID docker kill 和 stop 有什么区别 what’s the difference between docker stop and docker kill? 刪除已停止運行的 container 刪除單個 1docker rm NAME|ID 刪除全部 12docker rm $(docker ps -qa)docker ps -qa | xargs docker rm 已刪除的 container 會從快取中清除，使用 docker ps 指令查詢不到 刪除未停止的容器需加上 -f 參數進行強制刪除 重啟正在運行的 container1docker restart NAME|ID 重啟後輸入指令 docker ps NAME|ID，查看該容器的 status，開啟時間會變為幾秒前，證明該容器確實已被重新啟動 查看容器日誌 logs1docker logs [OPTIONS] NAME|ID options -t (顯示各 log 時間) -f (即時更新) --tail [number] (只看最後 [number] 行)查看容器內執行中的進程1docker top [OPTIONS] NAME|ID 查看容器內部細節1docker inspect [OPTIONS] NAME|ID 進入正在執行的容器並以終端機交互指令 attach exec 進入容器開啟終端，且不開啟新的進程。 啟動容器中新的終端，並開啟新進程 attach1docker attach [OPTIONS] CONTAINER 範例： 1docker attach d2ea08ddc42c 在容器內使用 ctrl + P + Q 退出後，輸入此指令可以回到容器終端介面。 exec1docker exec [OPTIONS] CONTAINER [script] 範例 1： 1docker exec -it d2ea08ddc42c /bin/bash 此指令效果相當於上面的 docker attach d2ea08ddc42c，原理實際上是啟動了容器內的 /bin/bash，此時你就可以通過 bash shell 與容器內交互了，就像遠端連接了 SSH 一樣。 範例 2： 1docker exec -it d2ea08ddc42c ls /tmp 此指令不會進入 d2ea08ddc42c 容器，並且在該指定容器中的 /tmp 目錄下操作 ls 指令，並將結果返回宿主環境。 從容器內複製文件到宿主環境1docker cp [OPTION] d2ea08ddc42c:容器內路徑 宿主環境路徑 範例： 1docker cp d2ea08ddc42c:/tmp/test.txt /tmp 將容器內的 /tmp/test.txt 檔案複製一份到宿主環境的 /tmp 路徑 修改並提交現有容器成為一個新的 image1docker commit [OPTION] CONTAINER [REPOSITORY[:TAG]] options -a=&quot;&quot; (作者) -m=&quot;&quot; (提交訊息) -c (將 Dockerfile 指令應用於創建的映像) -p (再提交時暫停容器運作，預設為true)範例： 1docker commit -a="dylam" -m="customCentOS" d2ea08ddc42c dylan/centOS:1.1.0 Data Volumes 資料卷概述在 Docker 容器中產生的資料，若不透過 commit 將資料成為 image 的一部分的話，在關閉容器時資料就會消失，為了解決這個問題，可以 透過 Data Volumes 解決。 特性 將容器資料持久化儲存 容器間繼承、共享資料 Data Volumes 在容器中修改會直接生效 Data Volumes 的更改不會包含在 image 的更新中 直到沒有任何容器使用，他的生命週期才正式結束 容器內添加以指令添加1docker run -it -v /宿主機絕對路徑資料夾:/容器資料夾 IMAGE 可支援添加多個 Data Volume 1docker run -it -v /host-a:/container-a -v /host-b:/container-b IMAGE 範例： 1docker run -it -v /hostDataVolume:/containerDataVolume dylan/centos:1.0.0 此指令將會以 dylan/centos:1.0.0 映像，開啟一個交互式容器，同時建立 Data Volumes，hostDataVolume 資料夾建立在宿主機根路徑下，containerDataVolume 則建立在容器根路徑下。兩個目錄具有共享資料的功能及上述所有特性。 訪問錯誤Docker 掛載主機目錄 Docker 訪問若出現 cannot open directory .: permission denied解決方法，添加 privileged 參數: 1docker run -it -v /宿主機絕對路徑資料夾:/容器資料夾 --privileged=true IMAGE 自訂權限 1docker run -it -v /宿主機絕對路徑資料夾:/容器資料夾:ro IMAGE or 表示 read-only，加上此參數後，容器內的 Volume 不可修改。 以 Dockerfile 添加在根目錄新增資料夾，並且添加一個 dockerfile 檔案1cd / &amp;&amp; mkdir mydocker &amp;&amp; cd mydocker &amp;&amp; touch dockerfile &amp;&amp; vim dockerfile 編寫基礎 dockerfile1234FROM centosVOLUME ["/dataVolumeContainer1", "/dataVolumeContainer2"]CMD echo "finished,---------success1"CMD /bin/bash FROM VOLUME CMD 基礎環境 映像生成後，自動建立的容器內 Data Volume 資料夾路徑(支援生成多個目錄)，以 Dockerfile 描述的 volume 無法指定對應的宿主機資料夾位置，而是由 Docker 自動產生 執行 shell 指令 docker build透過 dockerfile 生成 image 1docker build -f ~/mydocker/Dockerfile -t dylan/centos:1.0.0 . 若已在 ~/mydocker 目錄下，則也不須加 -f ~/mydocker/Dockerfile，預設會讀取當下目錄的 Dockerfile(D 大寫) 檔案 options -f (dockerfile 路徑) -t (生成的 image 名字)查看是否掛載成功使用指令 docker inspect CONTAINER 查詢容器細節將會發現此資料： 以指令添加時 123456"HostConfig": &#123; "Binds": [ "/myDataVolume:/containerDataVolume" ], ....&#125; 以 Dockerfile 添加時 Destination 為容器 data volume 位置，Source 為宿主機 data volume 位置(docker 自動產生) 12345678910111213141516171819202122"Mounts": [ &#123; "Type": "volume", "Name": "aa92d3f6045c1d0b3a99e3fa44c491937ca7a062b826dd5fe43a3a50515c54c0", "Source": "/var/lib/docker/volumes/aa92d3f6045c1d0b3a99e3fa44c491937ca7a062b826dd5fe43a3a50515c54c0/_data", "Destination": "/dataVolumeContainer1", "Driver": "local", "Mode": "", "RW": true, "Propagation": "" &#125;, &#123; "Type": "volume", "Name": "fb5ee2c3dc4826ac025011a789a74364409e70b654305184e55eb790019d2979", "Source": "/var/lib/docker/volumes/fb5ee2c3dc4826ac025011a789a74364409e70b654305184e55eb790019d2979/_data", "Destination": "/dataVolumeContainer2", "Driver": "local", "Mode": "", "RW": true, "Propagation": "" &#125;], 繼承其他容器的 Data Volume假設現在已經有一個正在運行的容器，名為 dc01，並且已有設定 Data Volume，此時如果想要在新建一個容器，並且共享 dc01 的 Data Volume，可以怎麼做呢？ 1docker run -it --name dc02 --volumes-from dc01 IMAGE 此時新生成一個 dc02 容器，並且與 dc01 共享 Data Volume，在內部所有資料將會共享並同步，即使父容器 dc01 被刪除，dc02 繼承自 dc01 的 Data Volume 依然會存在。 Dockerfile什麼是 Dockerfile? Dockerfile 是用來構建 Docker image 的文件，是由一系列指令和參數構成的腳本。 構建三步驟 編寫 Dockerfile docker build -&gt; 執行 dockerfile，建構成 image docker run -&gt; 執行生成的映像成為一個運行中容器 Dockerfile 的解析過程基礎知識 每條保留字都必須全大寫，且至少要有一個參數 指令從上到下依序執行 # 表示註解 每條指令都會創建一個 映像層，並對映像進行提交 Docker 執行 Dockerfile 的大致流程 Docker 從基礎映像運行一個容器 (FROM 後的參數) 執行一條指令並對容器作出修改 執行類似 docker commit 的操作，提交一個新的映像層 再基於剛提交的映像運行一個新容器 執行下一條 Dockerfile 指令，直到所有指令執行完成 Dockerfile 保留字指令 FORM 基礎 IMAGE，當前新映像是基於哪個映像的 MAINTAINER 作者資訊 1MAINTAINER The CentOS Project &lt;cloud-ops@centos.org&gt; RUN 容器構建時需要運行的額外 Linux 命令 EXPOSE 當前容器對外暴露的 port 號 WORKDIR 指定在創建容器後，終端機預設的工作目錄 ENV 在構建映像的過程中，設定環境變數這個變數可以在後續任何 RUN 指令中引用，就如同在命令指令了環境變數前綴一樣;也可以在其他指令中直接使用這些變數。 12ENV MY_PATH /usr/test# 引用 WORKDIR $MY_PATH ADD 將宿主機資料夾下的文件複製進映像且預設自動處理 URL 和解壓縮 tar COPY 類似 ADD 指令，拷貝文件和資料夾到映像中。從宿主機上下文(dockerfile 所在的資料夾)中的文件或資料夾，複製到映像內的&lt;目標路徑&gt;位置 支援兩種格式寫法，前者為 &lt;源路徑&gt; 後者為 &lt;目標路徑&gt; 12COPY src destCOPY ["src", 'dest'] VOLUME 定義容器內的 Data Volume 資料夾的路徑 CMD 指定容器啟動時要運行的指令 注意 Dockerfile 中可以有多個 CMD 指令 但只有最後一個生效 CMD 會被 docker run 之後的參數覆蓋。 123456FROM node:10.15.3-alpineWORKDIR /appADD . /appRUN npm installEXPOSE 3000CMD node index.js 以這個簡單的 dockerfile 為例，將這個 dockerfile 透過 docker build 指令產生 image 後，使用 docker run 指令生成容器： 1docker run -p 3000:3000 -it myNodeApp 在執行的最後，終端會執行最後一個 dockerfile 的 CMD 指令，也是就是 node index.js(將 node app 啟動)。但如果在下 docker run 時，在指令最後加上了其他 command 指令，則這個指令會覆蓋掉 node index.js 1docker run -p 3000:3000 -it myNodeApp ls -l 可以想像 dockerfile 在你加了其他指令後變成： 1234567FROM node:10.15.3-alpineWORKDIR /appADD . /appRUN npm installEXPOSE 3000CMD node index.js ## 不會執行CMD ls -l ## 會執行 如上述 1、2 點所敘述，CMD 指令可以有多個，但只有最後一個會起作用。 格式CMD 指令格式和 RUN 相似，也是兩種格式 12# shell 格式CMD &lt;commnad&gt; 12# exex 格式CMD ["可執行文件", "參數1", "參數2", ...] 12# 參數列表格式，在指定了 ENTRYPOINT 指令後，用 CMD 指定具體的參數CMD ["參數1", "參數2", ...] ENTRYPOINT 指定容器啟動時要運行的指令，ENTRYPOINT 和 CMD 一樣，都是在指定容器啟動程序及參數 注意 和 CMD 不同的是，ENTRYPOINT 後這指令不會被 docker run 之後的參數覆蓋，而是為該指令追加參數。 docker run 之後的參數會被當作參數傳遞給 ENTRYPOINT 指定的指令，形成新的指令組合，但 dockerfile 內必須使用 ENTRYPOINT [&quot;&quot;] 格式，否則追加參數不會起作用。 ONBUILD 當構建一個被繼承的 Dockerfile 時運行該指令，父映像在被子映像繼承後，父映像的 ONBUILD 會被觸發。 案例父映像 ~/mydocker/parentdockerfile 12FROM centosONBUILD RUN echo "Hello!" 透過父映像 dockerfile 生成 image 1docker run build -f ~/mydocker/parentdockerfile -t parent/image . 子映像 ~/mydocker/childdockerfile1FROM parent/image 執行 1docker build -f ~/mydocker/childdockerfile -t child/image . 此時因為父映像被繼承(FROM)，因此 ONBUILD RUN echo &quot;Hello!&quot; 會被觸發，並且在終端機輸出執行結果。 案例Base 映像(scratch)下面是 centOS 6.8 官方 Dockerfile，Docker Hub 中 99% 的映像都是在 scratch 映像中安裝和配置需要的軟體而構建出來的，你可以把它當作 docker 映像的基底，大部分映像的映像層最底部都是它。當你編寫的 Dockerfile 包含指令FROM centos 即代表該 Dockerfile 描述的映像的內部映像層也包含了 scratch 映像。 12345678910FROM scratchMAINTAINER The CentOS Project &lt;cloud-ops@centos.org&gt;ADD c68-docker.tar.xz /LABEL name="CentOS Base Image" \ vendor="CentOS" \ license="GPLv2" \ build-date="2016-06-02"# Default commandCMD ["/bin/bash"] 自訂義映像編寫 Dockerfile 案例 1 Docker hub 中官方的 centos 是一個精簡版的 Linux 系統，為的是盡可能壓縮大小，因此有許多功能是不支援的。另外某些行為已經被官方的 Dockerfile 所定義，如下： 執行 docker run -it centos 時，預設進入的目錄路徑為 /。 不支援 ifconfig 指令查找 ip 資訊 不支援 vim 編輯器 現在嘗試使用官方的 centos 映像為基底，編寫一個新的 Dockerfile，讓上述的功能可以被支援，且進入容器時的預設目錄為 /tmp。 123456789101112131415# 路徑: ~/mydocker/dockerfileFROM centosMAINTAINER Dylan&lt;dylan.liu237@gmail.com&gt;ENV MYPATH /tmpWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo "--success--"CMD /bin/bash 將 Dockerfile 編譯成 image 1docker build -f ~/mydocker/dockerfile -t dylan/mycentos . 查看 image 歷史。 1docker history dylan/mycentos 有一點值得注意，Docker 映像的概念就是一層一層映像層的嵌套，透過 image history 這個指令可以證實，每一個 Docker 保留字的指令都會生成一個新的映像層(參考上述的 Docker 執行 Dockerfile 的大致流程 部分)，每層都有擁有一個 ID，而最後一個指令產生的映像層 ID，將會成為這個映像最終對外暴露的 ID。 執行 image 成 container 1docker run -it --name mycentos dylan/mycentos 接著就可以發現這個容器的變化了 編寫 Dockerfile 案例 2此案例是使用 centos 為基底，並包含 tomcat 環境，並且此案例中會涵蓋幾乎所有的 Dockerfile 保留字指令。 1234567891011121314151617181920212223FROM centosMAINTAINER abc&lt;abc@abc.com&gt; # 將宿主機當前資料夾路徑(context)的 host.txt 複製到容器中的 /uer/local/ 路徑，並改名為 container.txtCOPY host.txt /usr/local/container.txt# 把 Java 和 tomcat 壓縮檔加到容器中的 /user/lacal 路徑，並且解壓縮ADD jdk-8u171-linux-x64.tar.gz /usr/lacalADD apache-tomcat-9.0.8.tar.gz /usr/lacal# 安裝 vimRUN yum -y install vim# 進入容器後的預設資料夾路徑ENV MYPATH /usr/localWORKDIR $MYPATH# 設定 Java 和 tomcat 環境變數ENV JAVA_HOME /usr/local/apache-tomcat-9.0.8ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.8ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin# 容器運作時監聽的 portEXPOSE 8080# 啟動容器時運行 tomcat# ENTRYPOINT ["/usr/local/apache-tomcat-9.0.8/bin/startup.sh"]#CMD ["/usr/local/apache-tomcat-9.0.8/bin/catalina.sh","run"]CMD /usr/local/apache-tomcat9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.8/bin/logs/catalina.out 執行 Dockerfile 形成 image 若 Dockerfile 在宿主機當前路徑下，可以不需指定 Dockerfile 位置 -f ~/mydocker/Dockerfile 1docker build -t custom/centos . 執行 image 成 container 1docker run -d -p 9999:8080 --name mycentos -v /dylan/tomcat9/volume:/usr/local/apache-tomcat-9.0.9/webapps/volume -v /dylan/tomcat0/logs/:/usr/local/apache-tomcat-9.0.8/logs --privileged=true custom/centos 看起來有點長，不過都是上面所提到的東西綜合運用而已，斷行後一個一個看看： 12345678910111213# 以後台方式執行容器，不進入容器終端、不印出任何執行logdocker run -d # 指定宿主機的 9999 port 與該容器的 8080 port 互相映射-p 9999:8080# 指定容器名稱--name mycentos# 設定兩組 Data Volume 對應-v /dylan/tomcat9/volume:/usr/local/apache-tomcat-9.0.9/webapps/volume-v /dylan/tomcat0/logs/:/usr/local/apache-tomcat-9.0.8/logs# 開啟"寫權限"--privileged=true# 執行的映像名稱custom/centos 上傳 image 到 Docker HubBuild image from Dockerfile假設已經 commit 了一個新的映像，或者用自己的 Dockerfile 產生了一個映像，叫做 dylan237/centos，執行此指令產生 image / 前必須與 Docker Hub 帳號一致 1docker build -t dylan237/centos . 登入在執行 docker push 指令前需要先登入，輸入自己的 Docker Hub 帳號密碼，只要登入過 Docker 會把 credential 保存，往後不需要再登入 1docker login Push將 image 上傳 補充: Docker image 大小動輒數百 MB，要上傳的話其實算蠻肥的，還記得上面提過映像是由多個映像層組成的概念嗎？假設今天這個例子的基底是 centos，在 commit 的時候 Docker 並不會把完整的映像層都提交到遠端，而是將你新增的幾個映像層做提交而已，未來 pull 下來會連同你的基底 image 和你提交的映像層合併成你自己的 image 讓你使用。 1docker push dylan237/centos 更新版本1docker push dylan237/centos:tagname 透過資料形式保存 image如果在客戶端環境不能使用網路，這時候就能利用 docker save 將 image 轉成檔案，之後只要有這支檔案，就透過 docker load 指令將檔案轉還原成 image，幫助我們在無網路的環境中，跨平台部署專案。 假設想輸出成檔案的映像叫 dylan/test，並且希望輸出後的檔案位置在當下目錄 ./myImageInFileForm 1docker save -o ./myImageInFileForm dylan/test 在當下目錄輸入指令 ls -l 應該就可以看到輸出完成的檔案 myImageInFileForm，接著可以透過任何形式保存這支檔案。 將檔案還原成 image 1docker load -i myImageInFileForm.bin References 尚硅谷 写给前端工程师看的 Docker 教程-实战篇 How to write excellent Dockerfiles Image 映像檔堆疊（分層式結構)]]></content>
      <categories>
        <category>DevOps</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 SSH 遠端連線 VPS (Google GCP)]]></title>
    <url>%2Fconnect-gcp-with-ssh.html</url>
    <content type="text"><![CDATA[產生 ssh 公私鑰開啟本地終端機輸入指令 1ssh-keygen -t rsa -C '[email address]' 將會詢問你需不需要為金鑰命名，如果不設定 enter 跳過即可(預設以 id_rsa 命名)，若未來要產生其他組 ssh key，這裡就需要命名了 1Enter file in which to save the key 詢問是否需要設定密碼，如果不設定 enter 跳過即可: 1Enter passphrase (empty for mo passphrase) 查看金鑰位置進入金鑰所在位置 .ssh 資料夾 1cd ~/.ssh 輸入 ls 指令，預期會看到兩個檔案(公私鑰) 12id_rsa(私鑰)id_rsa.pub(公鑰) 查看金鑰內容 12cat id_rsacat id_rsa.pub 將公鑰保存在要連線的伺服器中macOS 複製公鑰指令 1pbcopy &lt; ~/.ssh/id_rsa.pub 或是終端機輸入後手動複製 1cat ~/.ssh/id_rsa.pub GCP 連線 開啟 GCP 網站點擊 VM執行個體 選單 點擊連結 ssh 下拉選單 點擊在瀏覽器視窗中開啟，開啟 VPS 終端介面 將公鑰貼至 authorized_keys 檔案(public_key_string 要換成剛剛複製的公鑰字串) 在 authorized_keys 檔案中寫入 “public_key_string” 字串，如果檔案已存在，且已有以前寫入的公鑰，會換行寫入新的公鑰。 1echo "public_key_string" &gt;&gt; ~/.ssh/authorized_keys 假如剛剛自己是建立一個新的檔案，因為安全性的關係要改變 permission 輸入以下兩個指令 (username 需要換成自己的帳號) 12chmod -R go= ~/.sshchown -R username:username ~/.ssh 回到本地端，試試看是否能正常登入使用 ssh key 遠端登入 GCP 1ssh 帳號@伺服器ip 補充：ssh 帳號@IP 預設是使用 id_rsa 這組金鑰，若有多組金鑰要額外輸入金鑰檔名 1ssh -i ~/.ssh/私鑰名稱 帳號@伺服器ip 本機端查看 ssh 已連線的選端伺服器清單(hosts) 1cat ~/.ssh/known_hosts References [教學] 產生 SSH Key 並且透過 KEY 進行免密碼登入]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github 搜尋技巧整理]]></title>
    <url>%2Fgithub-search-tips.html</url>
    <content type="text"><![CDATA[搜尋專案名字1in:name [keywods] 搜尋專案描述內容1in:description [keywods] 搜尋專案根目錄中 README 的內容1in:readme [keywods] 星數限制123[keywods] stars:&gt;1000[keywods] stars:&gt;=1000[keywods] stars:1000..2000 fork 數限制1[keywods] forks:&gt;100 最後更新時間1[keywods] pushed:&gt;2020-01-01 專案大小限制 單位為 K 1[keywods] size:&gt;=5000 搜尋特定程式語言1[keywods] language:python 注意：上列所有的技巧可以同時使用。]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Google 搜尋技巧整理]]></title>
    <url>%2Fseach-tips.html</url>
    <content type="text"><![CDATA[搜尋特定網頁內容 site:url1爬蟲 site:https://stackoverflow.com/ 使用該技巧，搜尋引擎會回饋該網站所有符合關鍵字的相關項目 精確搜尋 &quot;1&quot;dylan blog&quot; 搜尋引擎只會回饋和關鍵字完全吻合的搜尋結果，在沒有給關鍵字加上雙引號的情況，搜尋引擎只會顯示所有分別和「dylan」以及「blog」相關的訊息。 排除特定的關鍵字 -在關鍵字後加上 - ，輸入想排除的關鍵字眼 1JavaScript -入門 日期區間限制 .. 注意：兩個句號後要加上空白 1Vue 2019.. 2020 同義字眼 ~1plumbing ~university 在搜尋引擎輸入該內容結果會包含「plumbing universities」和「plumbing colleges」等相似項目。 萬用關鍵字，取代不確定的關鍵字 *1architect* 用 * 填補關鍵字中的缺失部分，不論缺失的是一連串單字的其中一個還是一個單字的某一部分。此外，當你希望搜索一篇確定性偏低的文章時，也可以使用星號填補缺失部分。搜尋上述範例，所得到的回饋結果將會是所有包含 architect、architectural、architecture、architected、architecting 以及其他所有以「architect」作為開頭的詞彙項目。 Either OR 邏輯搜尋 OR1jennifer lawrence or jennifer aniston 使用該技巧，不僅能得到和關鍵字相關的資訊，還能得到兩個關鍵字分別相關的訊息。在不確定哪個關鍵字起作用時，OR 是很有幫助的 特定檔案格式filetype:1Vue documentation filetype:pdf 搜尋相關網站 related:1related:nike.com 搜尋標題intitle:、連結inurl:、內容intext:中的關鍵字123intitle:JavaScriptinurl:JavaScriptintext:JavaScript 學術、書籍搜尋引擎Google 學術Google 書籍]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node.js 中的 __dirname、__filename，以及使用相對路徑產生的問題]]></title>
    <url>%2Fnodejs-dirname-and-filename.html</url>
    <content type="text"><![CDATA[使用相對路徑產生的問題資料夾結構 12345test/ — nodejs/ ∟ path.js — lib/ ∟ common.js path.js 中的程式碼 123456fs.readFile('../lib/common.js','utf8' , function (err, data) &#123; if (err) &#123; return console.log('error: ', err) &#125; console.log('OK')&#125;) 在 nodejs 資料夾下執行 node path.js, 可以順利讀取檔案 退回一個資料夾, 在 test 資料夾下執行 node nodejs/path.js, 則是報錯了。這是 Node 的機制所導致的, 在 Node 中, 文件裡的相對路徑代表的是執行 node 時所在的資料夾的相對路徑, 並不是你所執行的 JS 檔本身的相對路徑。 在這個例子中, 如果在 ~/DeskTop/test 這個資料夾執行 node nodejs/path.js 指令, 程式碼中 readFile 內參數路徑 ../lib/common.js 會被解釋成 ~/DeskTop/lib/common.js, 而顯然這個資料路徑是不存在的。 使用絕對路徑在 Node.js 中, 大概有 __dirname、__filename、process.cwd() 或者 ./ 和 ../, 前三者都是絕對路徑, 為了便於比較 ./ 和 ../ 我們使用 path.resolve(&#39;./&#39;) 來轉換為絕對路徑 和上例一樣的資料結構, 將 path.js 改成： 123456const path = require('path')console.log('__dirname：', __dirname)console.log('__filename：', __filename)console.log('process.cwd()：', process.cwd())console.log('./：', path.resolve('./')) 在當下資料夾, 也就是 nodejs 資料夾執行命令 node path.js, 看看輸出結果： 1234__dirname： C:\Users\Dylanliu\Desktop\test\nodejs__filename： C:\Users\Dylanliu\Desktop\test\nodejs\path.jsprocess.cwd()： C:\Users\Dylanliu\Desktop\test\nodejs./： C:\Users\Dylanliu\Desktop\test\nodejs 接著退回一個層級資料夾, 到了 test 資料夾執行命令 node nodejs/path.js, 看看輸出結果： 1234__dirname： C:\Users\Dylanliu\Desktop\test\nodejs__filename： C:\Users\Dylanliu\Desktop\test\nodejs\path.jsprocess.cwd()： C:\Users\Dylanliu\Desktop\test./： C:\Users\Dylanliu\Desktop\test 再退一個層級資料夾, 到 Desktop 中執行命令 node test/nodejs/path.js, 看看輸出結果： 1234__dirname： C:\Users\Dylanliu\Desktop\test\nodejs__filename： C:\Users\Dylanliu\Desktop\test\nodejs\path.jsprocess.cwd()： C:\Users\Dylanliu\Desktop./： C:\Users\Dylanliu\Desktop 由上面的實驗結果可以歸納以下結論： 1234- __dirname： 總是回傳被執行 js 檔所在資料夾的絕對路徑- __filename： 總是回傳被執行 js 檔的絕對路徑- process.cwd()： 總是回傳執行 node 指令時所在的資料夾之絕對路徑- ./: 和 process.cwd() 一樣 正確路徑使用習慣由上面的實驗可以知道, 在 Node 中使用相對路徑進行檔案讀取是很危險的, 建議一律都透過絕對路徑的方式來處理 將 path.js 改成這樣： 123456789101112const fs = require('fs')const path = require('path')const absolutePath = path.join(__dirname, '../lib/common.js')// C:\Users\Dylanliu\Desktop\test\lib\common.jsfs.readFile(absolutePath, 'utf8', function (err, data) &#123; if (err) &#123; return console.log('error: ', err) &#125; console.log('OK')&#125;) 在 nodejs 資料夾下執行 node path.js, 順利讀取檔案 退回一個資料夾, 在 test 資料夾下執行 node nodejs/path.js, 一樣順利讀取檔案 path.join() 方法 path.join() 是 path 核心模組提供的一個方法, 可以幫助開法者在拼接路徑字串時, 減少出錯機率 來做個實驗, 首先在終端機執行 node, 進入 REPL 模式, 輸入程式碼做測試 1path.join('C:/file', 'fileB') 輸出： 1&apos;C:\\file\\fileB&apos; 若在手動拚字串的過程中少了或多了一個 / 符號, 很容易導致路徑問題, 產生一些低級錯誤。如果使用 path.join() 這個方法就能有效避免失誤機率發生 1path.join('C:/file', 'fileB', '//fileC', 'fileD') 輸出： 1&apos;C:\\file\\fileB\\fileC\\fileD&apos; require 的相對路徑還記得我們在 Node 中使用 require 時好像也常常使用相對路徑來引入自己寫的 JS 檔, 對吧？這樣也會有一樣的問題嗎？來試試看吧 延續一樣的資料夾結構 12345test/ — nodejs/ ∟ path.js — lib/ ∟ common.js common.js 內容 1exports.A = 'A' 在 path.js 撰寫程式碼, 透過 require 和 readFile 來測試, 讀取的檔案同樣是 common.js, 接著測試在不同資料夾執行腳本時, 兩者會不會有差異 123456789var fs = require('fs')var common = require('../lib/common.js')console.log(common.A)fs.readFile('../lib/common.js', function (err, data) &#123; if (err) return console.log(err) console.log(data)&#125;) 在 nodejs 資料夾下執行指令 node path.js, 想當然是不會報錯的。 退回一個資料夾, 在 test 資料夾下執行指令 node nodejs/path.js 這下問題來了, test 資料夾下執行指令時, 為什麼 require 是 OK 的, 只有 readFile 會報錯呢? 關於相對路徑的結論是 只有在 require() 中使用時, 效果相同於 __dirname , 不會因為啟動腳本的資料夾不同而改變, 在其他情況下則跟 process.cwd() 效果相同, 是相對於啟動腳本所在資料夾的路徑。因此, 只有在 require() 時才能使用相對路徑, 其他情況一律使用絕對路徑是最安全的方式。 參考資料浅析 NodeJs 的几种文件路径]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Express 製作簡易的留言版]]></title>
    <url>%2Fexpress-message-book.html</url>
    <content type="text"><![CDATA[之前我們使用原生 Node.js 製作了一個簡單的留言版應用程式, 現在讓我們把這個小練習用 Express 來改寫吧。 這篇部分程式碼和之前原生的版本是一樣的(如HTML), 有些細節在這篇就不再重複演示, 如有不夠清楚的地方, 可以搭配服用：用 Node.js 製作簡易的留言版 檔案結構除了改寫 app.js 以外, 其他配置包含程式碼, 大部分都和之前 Node.js 原生版本一樣 12345678— app.js— views ∟ index.html ∟ post.html ∟ 404.html— public ∟ lib ∟ bootstrap.css app.js 後端邏輯程式碼 views HTML 檔案, 分別是首頁、發表留言頁、404警告頁 public 靜態資源資料夾, 包含所有第三方套件、圖片、前端js檔、css檔, 這些在 HTML 標籤中, 如 &lt;link&gt; &lt;script&gt; &lt;img&gt; 所請求的資源 起手式Express 服務基本配置, 並且配置首頁(index.html) 及發表留言頁(post.html) 路由。 12345678910111213141516const express = require('express')const app = express()const host = '127.0.0.1'const port = 3000app.get('/', function (req, res) &#123; res.send('首頁')&#125;)app.get('/post', function (req, res) &#123; res.send('留言頁')&#125;)app.listen(port, host, function () &#123; console.log(`app is runnig at $&#123;host&#125;:$&#123;port&#125;`)&#125;) 在 Express 中使用 art-template 模板引擎art-template 模板引擎套件也有提供一種 Express 框架可使用的版本, 詳細配置請參考文件： art-template Express。 安裝12npm install --save art-templatenpm install --save express-art-template express-art-template 是把 art-template 整合在 Express 中的套件。在 Express 中使用時, 不需要特別 require(&#39;art-template&#39;), 但是必須要安裝, 因為 express-art-template 套件中有引入 art-template。 配置12345678910111213141516171819const express = require('express');const app = express();const host = '127.0.0.1'const port = 3000// view engine setup (核心配置)app.engine('html', require('express-art-template')); // ##// routesapp.get('/', function (req, res) &#123; res.render('index.html') &#125;)app.get('/post', function (req, res) &#123; res.render('post.html')&#125;)app.listen(port, host, function () &#123; console.log(`app is runnig at $&#123;host&#125;:$&#123;port&#125;`)&#125;) engine() 方法的第一個參數是在告訴模板引擎, 渲染 .html 附檔名的檔案時, 使用模板引擎渲染 Express 原生就為 res 物件提供一個方法 render, 但預設是無法使用的, 需要搭配模板引擎後才能使用 參數： res.render(&#39;html模板檔名&#39;, 欲渲染的資料(型別為物件, 可選參數)) 第一個參數不可寫路徑, 僅需提供檔名, 模板引擎預設會到 views 資料夾中尋找該模板檔案。 因此建議開發者建立一個 views 資料夾, 然後將 html 檔案都放到該資料夾中 如果想要修改預設的資料夾，可以使用1app.set('views', 新的資料夾名稱) 將資料帶入模板引擎目前的程式碼只會回傳靜態的 index 頁面, 因此還需要使用模板引擎動態渲染留言的資料到 index.html 上。 宣告一個處理留言資料的物件, 先寫死兩個留言資料, 屬性有 name 留言者 message 留言內容 dateTime 留言時間 123456789101112let comments = [ &#123; name: '王曉明', message: '今天天氣不錯', dateTime: '2019-08-09 13:00:00' &#125;, &#123; name: '王曉華', message: '對阿', dateTime: '2019-08-09 12:00:00' &#125;] 將資料帶入模板引擎渲染 12345app.get('/post', function (req, res) &#123; res.render('post.html', &#123; comments: comments &#125;)&#125;) 處理發表留言使用 get 方法發送留言請求表單 HTML 1234567891011&lt;form action="/comment" method="get"&gt; &lt;div class="form-group"&gt; &lt;label for="input_name"&gt;你的大名&lt;/label&gt; &lt;input type="text" class="form-control" required minlength="2" maxlength="10" id="input_name" name="name" placeholder="請寫入你的姓名"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="textarea_message"&gt;留言內容&lt;/label&gt; &lt;textarea class="form-control" name="message" id="textarea_message" cols="30" rows="10" required minlength="5" maxlength="20"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;發表&lt;/button&gt;&lt;/form&gt; 伺服器程式碼 1234567app.get('/comment', function (req, res) &#123; // 在 Express 中可以直接使用 req.query 取得 GET 請求所夾帶的 query, 且已自動將它處理成物件格式 var newComment = req.query newComment.dateTime = new Date().toLocaleString() comments.unshift(newComment) res.redirect('/')&#125;) 原生的留言版練習中, 在使用者發表留言後作了以下處理 設定狀態碼 302 告訴伺服器做臨時重新導向 設定 Response Header 中的 Location 屬性, 告訴瀏覽器重新導向到哪裡 結束響應 而 Express 為我們提供 res.redirect 方法(帶入一個參數, 該參數帶入欲重新導向的路徑), 只要需要使用一個方法, 就可以將上述所有步驟全部都搞定。 使用 post 方法發送留言請求到此, 已經改寫完 Express 版的留言板, 現在試著來做一個小練習, 將發表留言從 GET 請求改為 POST 請求。 1&lt;form action="/comment" method="post"&gt; GET 請求可以使用 query 夾帶資料, 傳送到伺服器, 而 POST 無法這麼做, POST 方法必須透過 Request Body 來夾帶資料做傳送。因此後端無法用 req.query 取得資料, 必須要做改寫。 修改程式碼 123app.post('/comment', function (req, res) &#123; res.send('收到 POST 請求')&#125;) 發起一個 POST 請求 按下發送按鈕後, 查看開發者工具的 Network, 可以看到這次的請求所夾帶的資料 接下來的問題是, 如何在 Express 中取得 POST 請求所夾帶的 Request Body? 取得 POST 請求體(Request Body)在 Express 中預設是無法直接取得表單 POST 方法的 Request Body 的, 需要透過第三方套件 body-parser 實現。 body-parser 文件 安裝 1npm install --save body-parser 配置 1234const bodyParser = require('body-parser)app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json()) 接著就可以透過 res.body 取得 POST 方法所夾帶的 Request Body 123456app.post('/comment', function (req, res) &#123; var newComment = req.body newComment.dateTime = new Date().toLocaleString() cmds.unshift(newComment) res.redirect('/')&#125;) DEMO Github]]></content>
      <categories>
        <category>Nodejs</category>
        <category>Express</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立第一支 Express 應用程式]]></title>
    <url>%2Fexpress-get-start.html</url>
    <content type="text"><![CDATA[原生的 Node.js 在某些方面表現不足以應對開發的需求, 因此我們需要框架來加快開發的效率, 框架的目的就是提高效率, 讓我們的程式碼更加簡潔統一。 Express官網 安裝12npm init -ynpm install --save express 初始化在目錄中，建立名為 app.js 的檔案，並新增下列程式碼： 1234567891011121314var express = require('express')var app = express()app.get('/', function (req, res) &#123; res.send('Hello World')&#125;)app.get('/login', function (req, res) &#123; res.send('Login!')&#125;)app.listen(3000, function () &#123; console.lig('Server is listening on port 3000..')&#125;) 應用程式會啟動伺服器，並在埠 3000 接聽連線。應用程式對指向根 URL (/) 或路由的要求，以 Hello World! 回應；指向 URL (/login)，以 Login! 回復。對於其他每一個路徑，它的回應是 404 找不到。 使用 nodemon 自動重啟應用程式在開發 Node.js 時, 若要執行程式, 需要使用 node [應用程式檔名] 來啟動伺服器服務, 且每次修改程式碼時都必須重啟一次, 在大量調試開發的階段顯得非常不方便。現在開始我們要使用 nodemon 這個工具來幫助我們自動 reload, 避免不必要的重複動作。nodemon 會監控程式碼有無變更, 並自動重啟服務, 只要刷新你的瀏覽器就能看到改動。 安裝全域安裝(任意資料夾都可以執行, 建議使用) 1npm install nodemon -g 單一專案安裝(需切到目標專案資料夾, 再執行install) 1npm install --save-dev nodemon 使用使用方法非常簡單, 以往是 node [應用程式檔名] 來開啟服務, 在安裝完 nodemon 之後, 可以使用 nodemon [應用程式檔名] 來開啟並且監控服務。 1nodemon app.js 基本路由路由簡單的解釋就是一張表, 它告訴你 url 與資源的映射關係。舉例來說, 某一棟大廈中, 有許多的公司(網站的各個分頁), 當你第一次來到這時, 並不知道你想去的那間公司(欲造訪的分頁)具體位在哪樓哪室, 這時候保全警衛扮演的角色就像路由, 它可以很清楚的告訴你你該去哪裡找到你的目標(url對應的資源)。 路由器 請求方法 請求路徑 請求處理函式 get當以 GET 方法請求 / 時, 執行對應的處理函式 123app.get('/', function (req, res) &#123; res.send('Got a GET request')&#125;) post當以 POST 方法請求 / 時, 執行對應的處理函式 123app.post('/', function (req, res) &#123; res.send('Got a POST request')&#125;) 特性Express 提供的 get、post ..等方法, 都支援鏈式, 就像 jQuery 一樣, 它會 return 一個 app 物件。因此你可以這麼做 12345app .get('/', function() &#123;...&#125;) .get('/login', function() &#123;...&#125;) .post('product', function() &#123;...&#125;) // .... 在更大型的專案中, 你可以將這些路由另外放到一支 router.js 中, 統一管理, 讓你的專案更加容易閱讀，更加有條理。 公開靜態資源在 用 Node.js 製作簡易的留言版 練習中, 在公開的靜態資源我們是這樣做處理的。 12let urlObj = url.parse(req.url, true)let pathname = urlObj.pathname 123456if (pathname.indexOf('/public/') === 0) &#123; fs.readFile(`.$&#123;pathname&#125;`, (err, data) =&gt; &#123; if (err) return toErrorPage() res.end(data) &#125;)&#125; 而 Express 中, 提供了一個 API, 我們可以透過更簡單的方式來開放靜態資源資料夾。 當以 /public/ 開頭為請求路徑時, 去該專案下的 ./public/ 資料夾尋找對應的資源 1app.use('/public/', express.static('./public/')) 例如請求的路徑是 127.0.0.1:3000/public/css/lib/bootstrap.css, 伺服器則會回應 ./public/css/lib/bootstrap.css 這個資料路徑的資源。 精簡請求路徑另外若有需要, 還可以更加簡化請求 url 1app.use(express.static('./public/')) 此時請求路徑可以省略 /public/, 現在可以透過 127.0.0.1:3000/css/lib/bootstrap.css url 來請求 ./public/css/lib/bootstrap.css 這個資源了。]]></content>
      <categories>
        <category>Nodejs</category>
        <category>Express</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js module system (三) - module 的三種類型]]></title>
    <url>%2Fnodejs-module-system-3.html</url>
    <content type="text"><![CDATA[在 Node.js 中的模組有大三類型, 要如何區別他們, 以及它們是如何被運作的, 將是這篇的重點 Node.js 中模組的三大類型 核心模組 文件操作的 fs http 服務的 http … 第三方模組 需透過 npm 下載的第三方套件 自己撰寫的模組 自己撰寫的 JS 腳本 另外, 三大模組形態還可以將他們區分為兩種型態(標示符) 非路徑形式的模組 核心模組 第三方模組 路徑形式的模組 自己撰寫的模組 路徑形式的模組只有自己撰寫的模組被歸類在 路徑形式的模組 當中, 它的特性是 require 時必須添加路徑, 如： 1let foo = require('./foo.js') 透過相對路徑的方式, 找到你自己撰寫的 JS 檔案, 並且引入使用 或者透過絕對路徑, 如： 1let foo = require('/foo.js') 開頭直接為 / 代表的是該檔案所屬的硬碟根目錄, 在 windows 系統中, 如果檔案位在 C 槽下的話, 則 require(&#39;/foo.js&#39;) 代表載入 C:/foo.js, 不過這種方法幾乎不會使用, 只要了解就可以了。 .js 的後綴名可以省略 非路徑形式的模組核心模組 與 第三方模組 都是屬於這個分類, 共同點是他們都不需要加上路徑, 只需要單純用該模組的名字來引入就可以了, 如： 引入核心模組 http 1let http = require('http') 引入第三方模組 art-template 1let tpl = require('art-template') 核心模組當引入自己撰寫的模組時, 我們都很清楚, 其實我們引入的就是自己寫好的 JS 檔案。那麼當我們像 let http = require(&#39;http&#39;) 引入 http 模組時, 它到底引入的是什麼東西呢? 一樣是 JS 檔案 沒錯, 它的本質一樣是 JS 檔案, 實際上它是真實存在的一支檔案, 由 Node.js 開發人員所撰寫, 並且被編譯成二進制文件中。在開發時我們只需要知道它的名字, 需要時引入就可以了。 Node.js 是開源的, 原始碼都可以在 Github 上找到, 我們可以來看看能不能找到 http.js 這隻檔案 原始碼連結 第三方模組凡是第三方模組, 都必須透過 npm 套件管理工具下載, 例如： 1npm install art-template 這時候檔案所在資料夾下多了一個 node_modules 資料夾, 裡面也會有一個 art-template 資料夾, 當中包含了這個套件的相關檔案。 現在就可以 require(&#39;套件名&#39;) 的方式來載入使用 1let tpl = require('art-template') 第三方模組 和 核心模組 在載入時, 都不需要路徑, 他們的載入方式是一樣的, 因此不可能有任何一個 第三方模組 的名字是和 Node.js 的核心模組相同的, 因為套件開發者將套件上傳到 npm 時, 若名稱與核心模組一樣, 是無法上傳的。 如何判斷是否為第三方模組既然第三方模組與核心模組載入的方式都不需要路徑, 那當 Node.js 引擎是如何判斷這個 require 是哪種類型呢? 以下用 第三方模組 art-template 當作範例來說明 Node.js 判斷模組類型的流程 Node.js 引擎讀取到 let tpl = require(&#39;art-template&#39;) 不具有路徑, 判斷它並非 自己撰寫的模組 核心模組並沒有一個名字叫做 art-template 的, 判斷它並非 核心模組 排除以上兩個可能, 確定它是一個 第三方模組 第三方模組查找規則現在 Node.js 知道這個 art-template 是一個第三方模組了, 接著它是如何知道具體該去載入哪支 JS 檔呢? 首先 Node 會優先從當前檔案所處資料夾中, 尋找有沒有 node_modules 資料夾 若沒有 node_modules 資料夾, 則執行 A. (↓) 尋找 node_modules 內, 有沒有 art-template 資料夾 若沒有 art-template 資料夾, 則執行 A. 尋找 art-template 內, 有沒有 package.json 檔案 若沒有 package.json, 預設會 require art-template/index.js。 若 index.js 也不存在, 執行 A. 尋找 package.json 內的 main 屬性, 而它的值將會是最終被 require 的檔案 若沒有 main 屬性, 預設會 require art-template/index.js。若 index.js 也不存在, 執行 A. A. 進入上一級資料夾找 node_modules, 直到找到該檔案硬碟根目錄為止, 若有找到則重複執行上述流程。若沒找到, 則報錯誤 can not find module xxx 上述的流程概念有點類似 JavaScript 的原型鏈和作用域特性, 就是不斷地往外查找, 你可以以同樣的思路去理解。 延伸閱讀深入淺出Node.js（三）：深入Node.js 的模塊機制]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node.js module system (二) - exports 和 module.exports 的差異]]></title>
    <url>%2Fnodejs-module-system-2.html</url>
    <content type="text"><![CDATA[在我的Node.js - 模組系統 (一)文章裡, 初步的認識了 Node.js 模組系統的運作原理, 在這篇文章中, 將更深入探討模組系統到底是怎麼一回事。 CommonJS 模組規範瀏覽器中執行的 JavaScript 是不支援模組化的, 但在 Node.js 中參照 CommonJS 規範, 設計了一套模組化系統 模組(文件)作用域 (每個文件的成員都是封閉的, 預設無法互相取用, 需透過導出和載入) 通信規則 使用 require 來載入模組 使用 exports 接口物件來導出模組中成員 關於瀏覽器中的 JS 及 Node.js 的比較, 請參考認識 Node.js exports 物件和 module.exports 物件差異在Node.js - 模組系統 (一)中, 導出模組成員時是使用 exports 物件做導出的, 如以下範例 B.js 導出成員 123// B.jsexports.aaa = 'aaa'exports.bbb = function() &#123;&#125; A.js 引入成員 123// A.jslet B_exports = require('./B')console.log(B_exports) 終端機執行 node A, 成功的取得 B 導出的成員 1&#123; aaa: &apos;aaa&apos;, bbb: [Function] &#125; 在上一篇沒有提到的是, exports 其實是一個簡化的寫法, 在 Node 模組系統中, 真正被導出的物件其實叫做 module.exports, 下面來做個實驗看看 B.js 導出成員 123// B.jsmodule.exports.aaa = 'aaa'module.exports.bbb = function() &#123;&#125; A.js 引入成員 123// A.jslet B_exports = require('./B')console.log(B_exports) 終端機執行 node A, 得到的結果和使用 exports 物件導出是一樣的 1&#123; aaa: &apos;aaa&apos;, bbb: [Function] &#125; 嗯? 我說那個原理呢? 若你對 JavaScript 有基本的認識, 應該對 by reference (傳參考)的概念不陌生, 其實就是透過這個原理做到的。 在 JS 中物件型別特性是傳參考，若將一個A變數指向某個物件，當修改A變數或是指向的那個物件內部任一屬性，都會影響另一個物件，因為現在這兩個變數都被指向同一個記憶體位置。 範例 12345var obj1 = &#123; name: 'dylan', age: 18 &#125;;var obj2 = obj1;obj2.age = 21;console.log(obj1); // &#123;name: "dylan", age: 21&#125; 了解這個概念後, 你可以想像一件事, Node.js 在模組系統的底層寫了這麼一段程式碼 123var module = &#123; exports : &#123;&#125;&#125; module.exports 是被預設的接口物件, 每一個 Node.js 的模組底層都有這麼一個空物件，你可以想像, 在程式碼的最後 Node 會將 module.exports 物件 return 1return module.exports 之後誰來 require 這個模組, 誰就可以得到這個 module.exports 物件。 but 這個物件的名稱實在是太長了, 如果要導出多個物件你可能需要 1234module.exports.aaa = 'aaa'module.exports.bbb = 'bbb'module.exports.ccc = 'ccc'// loop ... 當然你也可以這麼做啦 12345module.exports = &#123; aaa: 'aaa', bbb: 'bbb', ccc: 'ccc',&#125; 不過貼心如 Node, 還是為你做了一件事情 1let exports = module.exports 它宣告了一個新變數 exports 指向了 module.exports 接口物件的記憶體, 所以透過傳參考的特性, 不管你對兩個中的哪個物件新增成員, 他們都會同步被改變。關於這點你可以在任一 JS 檔貼上下面這段程式碼, 並且在 Node 環境執行它, 你會得到 true 的結果 1console.log(exports === module.exports) 好的, 了解這個概念後, 現在你可以簡化成 123exports.aaa = 'aaa'exports.bbb = 'bbb'exports.ccc = 'ccc' 但是你千萬不能這麼做 12345exports = &#123; aaa: 'aaa', bbb: 'bbb', ccc: 'ccc',&#125; exports 物件陷阱為什麼不能這麼做呢? 來實際實驗看看 B.js 12345exports = &#123; aaa: 'aaa', bbb: 'bbb', ccc: 'ccc',&#125; A.js 12let B_exports = require('./B')console.log(B_exports) 終端機執行 node A, 得到的結果 1&#123;&#125; 奇怪了? exports 不是等同於 module.exports 嗎? 為什麼引入模組得到的是空物件? 其實, 如果你真的理解 JavaScript 傳參考的特性, 就有答案了。 來看看一個簡單傳參考範例 首先先建立一個傳參考物件 12345let obj1 = &#123; name: 'dylan', age: 18 &#125;let obj2 = obj1obj2.hobby = 'coding'console.log(obj1, obj2) 輸出結果 12&#123;name: 'dylan', age: 18, hobby: 'coding'&#125; // obj1&#123;name: 'dylan', age: 18, hobby: 'coding'&#125; // obj2 到目前為止沒有問題, 但是若你對 obj2 物件重新賦值( 也是就重新讓 obj2 等於某某東西時 ) 1234567obj2 = &#123; aaa: 'aaa', bbb: 'bbb', ccc: 'ccc',&#125;console.log(obj1) 輸出結果, obj1 並沒有被影響 1&#123;name: "dylan", age: 18, hobby: "coding"&#125; 當你對傳參考物件(obj2)重新賦值時, 它的記憶體位置已經不再指向和 obj1 所指向的 {name: &#39;dylan&#39;, age: 18, hobby: &#39;coding&#39; 物件了, 它已是另外一個獨立的物件, 也就是說傳參考的連結在你重新賦值時即斷開。 所以, 在 Node.js 中, 請不要對 exports 物件做任何重新賦值的行為, 如果有需要只能使用 module.exports 物件。 總結實戰時最常用使用方式： 導出多個成員 (也就是導出一個物件, 成員都放在裡頭) exports.XXX = xxx 或 module.exports.XXX = xxx 都可以 module.exports = { ... } (只能是 module.exports) 導出單個成員 (無論指向什麼型別的東西, 導出的東西就是它一個) module.exports = XXX (只能是 module.exports) 最後, 若對上列的描述還是覺得不夠清楚, 你可以再看一次(毆).. 不是啦, 如果你覺得要理解這些有點麻煩, 就一律都使用 module.exports 就可以避免所有問題了。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Node.js 製作簡易的留言版]]></title>
    <url>%2Fnodejs-message-book.html</url>
    <content type="text"><![CDATA[檔案結構12345678— app.js— views ∟ index.html ∟ post.html ∟ 404.html— public ∟ lib ∟ bootstrap.css app.js 後端邏輯程式碼 views HTML 檔案, 分別是首頁、發表留言頁、404警告頁 public 靜態資源資料夾, 包含所有第三方套件、圖片、前端js檔、css檔, 這些在 HTML 標籤中, 如 &lt;link&gt; &lt;script&gt; &lt;img&gt; 所請求的資源 views使用 bootstrap 來製作簡易的介面 index.html 12345678910111213141516171819&lt;div class="header container"&gt; &lt;div class="page-header"&gt; &lt;h1 class="my-4"&gt;留言板 &lt;small&gt;...&lt;/small&gt;&lt;/h1&gt; &lt;a class="btn btn-success mb-4" href="./post.html"&gt;發表留言&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="comments container"&gt; &lt;ul class="list-group"&gt; &lt;li class="list-group-item"&gt; &lt;div class="d-flex flex-column"&gt; &lt;div class="mb-3"&gt; &lt;span class="font-weight-bold mr-2"&gt;留言者姓名&lt;/span&gt; &lt;small class="text-right"&gt;留言時間&lt;/small&gt; &lt;/div&gt; &lt;span class="mb-3"&gt;留言內容&lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; post.html 123456789101112131415161718&lt;div class="header container"&gt; &lt;div class="page-header"&gt; &lt;h1&gt;&lt;a href="/"&gt;首頁&lt;/a&gt; &lt;small&gt;發表評論&lt;/small&gt;&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="comments container"&gt; &lt;form&gt; &lt;div class="form-group"&gt; &lt;label for="input_name"&gt;你的大名&lt;/label&gt; &lt;input type="text" class="form-control" id="input_name" name="name" placeholder="請寫入你的姓名"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="textarea_message"&gt;留言內容&lt;/label&gt; &lt;textarea class="form-control" name="message" id="textarea_message" cols="30" rows="10"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;發表&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; app.js起手式123const http = require('http')const fs = require('fs')const url = require('url) 在用 Node.js 實作一個 Apache HTTP Server中, 是這樣建立服務的 1234const server = http.createServer()server.on('request', function (req, res) &#123; // ...&#125;) 現在我們可以簡化成以下寫法, 結果是一樣的 123http.createServer(function (req res) &#123; // ...&#125;) 取得請求路徑當瀏覽器發送請求到伺服器端時, 需要根據請求過來的網址, 回傳對應的 html 頁面回去, 首先我們需要先得到網址的字串資料, 最簡易的方式是像這樣的 123http.createServer(function (req, res) &#123; let url = req.url&#125;) 如果請求的網址是 127.0.0.1:3000/comment, url 的輸出結果則為 /comment。 但是, 當使用者在留言時所傳送的網址可能會副帶 query string 參數, 像是這樣 1127.0.0.1:3000/comment?name=dylan&amp;message=今天天氣真好 這時候 url 的值為 /comment?name=dylan&amp;message=今天天氣真好, 這些傳送的參數是不可能每次都一樣的, 這個情況下, 如果使用 if (url === &#39;/comment&#39;) 這樣的判斷方式是會有問題的。因此我們需要確保請求網址傳過來時, 能夠將請求路徑區與夾帶的 query string 區分開。 使用 Node.js 的 url 核心模組, 使用方法請參考此篇：使用 JS 取得 Query String 資料 1234http.createServer(function (req, res) &#123; let urlObj = url.parse(req.url, true) let pathname = urlObj.pathname&#125;) 現在, 如果像這樣 127.0.0.1:3000/comment?name=dylan&amp;message=今天天氣真好 的請求傳來時, url 模組的 parse 方法可以幫助我們將網址進行處理。 輸出 urlObj.pathname 可以得到請求路徑 1/comment urlObj.query 幫助我們將 query 處理成物件 1&#123;name: 'dylan', message: '今天天氣真好'&#125; 接著可以把判斷方式改為這樣, 就能避免問題了 123if (pathname === '/comment') &#123; // do something&#125; 公開的靜態資源這個留言板中只有一個靜態資源 bootstrap, 位置在 public → lib → bootstrap.css 123— public ∟ lib ∟ bootstrap.css 以往我們在做前端開發的經驗中, 通常使用相對路徑來引入 JS、CSS 或圖片檔案, 像是： 1&lt;link rel="stylesheet" href="../node_modules/bootstrap/dist/css/bootstrap.css"&gt; 現在可以改成使用絕對路徑, 如果請求路徑是以 /public/ 開頭, 則伺服器認定需要往 public 資料夾中的某個資源, 所以我們就直接可以把請求路徑當作文件路徑來直接進行讀取 1&lt;link rel="stylesheet" href="/public/lib/bootstrap.css"&gt; 12345678910111213141516171819http.createServer(function (req res) &#123; let urlObj = url.parse(req.url, true) let pathname = urlObj.pathname // 統一處理 404 頁面 function toErrorPage () &#123; fs.readFile('./views/404.html', (err, data) =&gt; &#123; if (err) return res.end('404 not Found!') res.end(data) &#125;) &#125; // ============== START ================ if (pathname.indexOf('/public/') === 0) &#123; fs.readFile(`.$&#123;pathname&#125;`, (err, data) =&gt; &#123; if (err) return toErrorPage() res.end(data) &#125;) &#125; // ================ END ================&#125;) 若有其他的靜態資源也可以如法炮製 1234567— public ∟ js ∟ main.js ∟ css ∟ main.css ∟ img ∟ A.jpg 123&lt;script src="/public/js/main.js"&gt;&lt;/script&gt;&lt;link rel="stylesheet" href="/public/css/main.css"&gt;&lt;img src="/public/css/A.jpg" alt=""&gt; 處理 index.html撰寫 / 請求的伺服器回應12345678910if (pathname.indexOf('/public/') === 0) &#123; // ...// ============== START ================&#125; else if (pathname === '/') &#123; fs.readFile('./views/index.html', (err, data) =&gt; &#123; if (err) return toErrorPage() res.end(data) &#125;)&#125;// ================ END ================ 模板引擎動態渲染留言資料目前的程式碼只會回傳靜態的頁面, 因此還需要使用模板引擎動態渲染留言的資料到 index.html 上。這邊和上次製作 Apache Server 一樣, 使用 art-template 套件。 使用方法可以參考在 Node.js 中使用 art-template 模板引擎。 宣告一個處理留言資料的物件, 先寫死兩個留言資料, 屬性有 name 留言者 message 留言內容 dateTime 留言時間 123456789101112let comments = [ &#123; name: '王曉明', message: '今天天氣不錯', dateTime: '2019-08-09 13:00:00' &#125;, &#123; name: '王曉華', message: '對阿', dateTime: '2019-08-09 12:00:00' &#125;] 使用 art-template 模板引擎app.js 1const template = require('art-template') 12345678910111213if (pathname.indexOf('/public/') === 0) &#123; // ...&#125; else if (pathname === '/') &#123; fs.readFile('./views/index.html', (err, data) =&gt; &#123; if (err) return toErrorPage()// ============== START ================ let afterRenderData = template.render(data.toString(), &#123; comments: comments &#125;) res.end(afterRenderData)// ============== END ================ &#125;)&#125; index.html 12345678910111213&lt;ul class="list-group"&gt; &#123;&#123; each comments &#125;&#125; &lt;li class="list-group-item"&gt; &lt;div class="d-flex flex-column"&gt; &lt;div class="mb-3"&gt; &lt;span class="font-weight-bold mr-2"&gt;&#123;&#123; $value.name &#125;&#125;&lt;/span&gt; &lt;small class="text-right"&gt;&#123;&#123; $value.dateTime &#125;&#125;&lt;/small&gt; &lt;/div&gt; &lt;span class="mb-3"&gt;&#123;&#123; $value.message &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &#123;&#123; /each &#125;&#125;&lt;/ul&gt; 效果 處理 post.html撰寫 /post 請求的伺服器回應當點擊首頁中的發表留言按鈕時, 瀏覽器會向伺服器發起 127.0.0.1:3000/post 請求, 隨即跳轉至 post.html 頁面 12&lt;!-- index.html --&gt;&lt;a class="btn btn-success mb-4" href="./post.html"&gt;發表留言&lt;/a&gt; 改為 1&lt;a class="btn btn-success mb-4" href="/post"&gt;發表留言&lt;/a&gt; 1234567891011// ..&#125; else if (pathname === '/') &#123; // ...// ============== START ================&#125; else if (pathname === '/post') &#123; fs.readFile('./views/post.html', (err, data) =&gt; &#123; if (err) return toErrorPage() res.end(data) &#125;)&#125;// ============== END ================ 使用 HTML 表單發送資料當使用者點擊發送按鈕時, 將表單資料送往後端 123456789101112&lt;!-- post.html --&gt;&lt;form action="/comment" method="get"&gt; &lt;div class="form-group"&gt; &lt;label for="input_name"&gt;你的大名&lt;/label&gt; &lt;input type="text" class="form-control" id="input_name" name="name" placeholder="請寫入你的姓名"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="textarea_message"&gt;留言內容&lt;/label&gt; &lt;textarea class="form-control" name="message" id="textarea_message" cols="30" rows="10"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;發表&lt;/button&gt;&lt;/form&gt; action=&quot;/comment&quot; 在發送時, 瀏覽器會透過 127.0.0.1:3000/comment 向伺服器發起請求, get 方法則會將表單內具有 name 屬性的表單元素的值, 透過 query string 的方式發送資料。 簡單的原生 HTML 表單驗證1&lt;input type="text" class="form-control" required minlength="2" maxlength="10" id="input_name" name="name" placeholder="請寫入你的姓名"&gt; 1&lt;textarea class="form-control" name="message" id="textarea_message" cols="30" rows="10" required minlength="5" maxlength="20"&gt;&lt;/textarea&gt; required 為必填項目, minlength 及 maxlength 分別代表最低字數與最多字數限制 撰寫 /comment 請求的伺服器回應12345678910&#125; else if (pathname === '/post') &#123;// ...&#125; else if (pathname === '/comment') &#123; let commentData = urlObj.query commentData.dateTime = new Date().toLocaleString() comments.unshift(commentData) res.statusCode = 302 res.setHeader('Location', '/') res.end()&#125; 如文章一開始所提, 在使用者送出留言後, 會使用像是 127.0.0.1:3000/comment?name=dylan&amp;message=今天天氣真好 的網址傳送到伺服器, 然而現在我們已經可以透過 url.parse 方法取得物件格式的 query string 資料, 當收到此請求時將該 query string 物件推入 comments 留言物件中, 就完成了資料的更新。資料雖然已經更新, 但使用者還是停留在 post 頁面, 我們需要透過伺服器重新導向到首頁。 狀態碼設定為 302 臨時重新導向 在 Response Header 中通過 Location 告訴瀏覽器導向到哪一頁 如果瀏覽器發現收到伺服器的狀態碼是 302, 它會自動去 Response Header 中找 Location, 然後對伺服器重新發請求, 接著你就能看到瀏覽器自動跳轉了。當使用者被重新導向到首頁時, 新的資料已經透過模板引擎重新渲染成新的首頁 HTML 發送給瀏覽器了, 如此一來, 使用者就能順利看到新的留言呈現在首頁上。 DEMO Github]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端開發 MacOS 環境安裝]]></title>
    <url>%2Fmacos-env-setup.html</url>
    <content type="text"><![CDATA[Command Line Tools在安裝 MacOS 的套件管理工具 homebrew 前需要先安裝 Command Line Tools。登入Apple Developer 搜尋 Command Line Tools, 下載符合你 Mac 系統的版本的 dmg 並安裝 homebrew Homebrew 官網 Command Line Tools 安裝成功後後, 打開終端機輸入指令 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 出現 Installation successful 即安裝成功 確認版本 1brew -v Iterm2 終端機Iterm2 是可以取代 Mac OSX 的預設 Terminal 的套件，提供了比 terminal 更多樣化的功能，透過安裝 zsh shell 及 zsh 的管理套件 oh-my-zsh，讓我們可以輕鬆的管理 zsh 的設定檔，並且支援許多 plugin 及 theme。 安裝 1brew cask install iterm2 另外 iterm2 還提供了多樣了配色樣式, 可以到 iTerm2-Color-Schemes 挑選喜歡的配色, 右上角有下載的標示可以整包下載下來，解壓縮後在 schemes 資料夾中有許多副檔名為 .itermcolors 的配色檔可以使用, 透過以下操作將檔案 import 進去使用 zsh接著我們要安裝 ZSH ，這是用來取代 BASH 的一種工具，打開 Terminal 輸入 安裝 1brew install zsh zsh-completions 確認版本 1zsh --version 接著要將預設終端機窗口改為 ZSH，一樣在終端機輸入 1chsh -s /bin/zsh 接者要重啟 Iterm2，接著輸入以下指令確認是否設定成功 1echo $SHELL 應該會看到顯示 /usr/local/bin/zsh oh-my-zshoh-my-zsh 是一個用來管理 ZSH 設定檔（configuration）的框架，提供了很多的外掛和主題可以選擇。 安裝 1sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 套用主題 1open ~/.zshrc 接著會打開 zsh 的設定檔，找到 ZSH_THEME= &quot;…&quot;，將這段的內容改成下面這段後存檔 1ZSH_THEME="agnoster" 字體修改安裝字型 123brew tap caskroom/fonts// 若出現錯誤也可以試試brew tap homebrew/cask-fonts 1brew cask install font-hack-nerd-font 設定下載的字型 1itrem2 -&gt; Preferences -&gt; profiles -&gt; text -&gt; font -&gt; 選擇 Hack nerd font 另外 VScode 可能因為預設字體不支援的關係, 在內建整合的終端機使用 zsh 會有亂碼問題, 我們可以使用 Powerline fonts @ github 字型包解決 安裝 12345# clone 複製git clone https://github.com/powerline/fonts.git --depth=1# install 安裝cd fonts ./install.sh 開啟 VScode, 使用快捷鍵 command + shift + p 搜尋並開啟 setting.json 設定檔案並貼上 123&#123; "terminal.integrated.fontFamily": "Meslo LG M for Powerline"&#125; powerlevel9k 主題這部分可以依照個人喜好, 可做可不做 powerlevel9k 風格是承襲 agnoster ，不同的地方是新增了一些小功能像是版控資訊、電池狀態、硬碟狀況、ip位置、時間、還有小圖icon …等讓使用者自行設定。 安裝 1git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k 開啟設定檔案 1open ~/.zshrc 貼上以下設定 (貼在ZSH_THEME=&quot;agnoster&quot; 後即可 ), 若需要更多客製設定可至官網查看文件 12345678910# 使用powerlevel9k主題亦可選擇使用agnoster或預設robbyrussellZSH_THEME="powerlevel9k/powerlevel9k"# 隱藏用戶名稱(user@hostname)DEFAULT_USER=`id -un`# CLI 左邊想顯示的內容(資料夾路徑、資料夾讀寫狀態、版本控制資訊)POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir dir_writable vcs)# CLI 右邊想顯示的內容(狀態、時間)POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status time)# 含有icon的字型(依喜好)POWERLEVEL9K_MODE='nerdfont-complete' 成果大概會是這個樣子 其他 zsh 外掛Autojump 資料夾路徑提示安裝 1brew install autojump AutosuggestionsAutosuggestions 會根據過去所輸入的指令來提示你的工具 1git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions zsh-syntax-highlighting程式碼高亮工具 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 最後還需要設定 iterm2 的 zshrc 設定檔 進入設定 1open ~/.zshrc 12345678plugins=(gitosxnpmautojumpzsh-autosuggestionszsh-syntax-highlighting) nvm &amp; node.js安裝 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash 查詢 node 有哪些版本 1nvm ls-remote 下載指定版本 1nvn install 10.14.1 切換版本 1nvm use 10.14.1 查詢是否安裝成功 12node -vnpm -v 參考資料PJCHENder 那些沒告訴你的小細節用Oh My Zsh把iTerm變美美[ Alex 宅幹嘛 ] 👨‍💻 網頁前端開發的 Macbook 初始化安裝]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>開發環境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 MacOS 原生方法讀寫 NTFS 格式]]></title>
    <url>%2Fntfs-for-mac.html</url>
    <content type="text"><![CDATA[NTFS（New Technology File System 是一個由 Microsoft 發展標準檔案系統，FAT32 則是另一個常用的檔案系統的例子。檔案系統定義了資料（或檔案）如何存儲於儲存裝置，或從儲存裝置中檢索及讀取。不過，在預設情況下 Mac OSX 只支持讀取 NTFS，不能寫。雖然網路上有軟體可以啟用 NTFS 的寫入，但是其實，只要幾個簡單的步驟，便可以啟用，而且是完全免費。 檢查外接硬碟名稱開啟終端機(terminal)並輸入, 查詢硬碟資訊 1diskutil list 紅框處即可查詢硬碟名稱 硬碟名稱盡量避免空白符, 若有空白符號建議可以先到 windows 電腦改名, 若不方便須以 \040 代替空格 更改 /etc/fstab 文件緊接著更新 /etc/fstab 文件，在 terminal 執行下面指令, 打開 fstab 文件檔 1sudo vi /etc/fstab 指令說明 sudo 以管理者權限執行, 需輸入密碼 vi 用終端機的 vim 文本編輯模式開啟檔案(/etc/fstab) vim 操作 進入 vim 模式後按下 a 即可進入 insert(編輯模式) 編輯完成後按下 ESC 離開編輯模式 按下 :wq 儲存並離開 若不熟悉 vim 的編輯方式可以改執行 sudo open /etc/fstab, 此指令會以一般文本編輯器開啟檔案 寫入以下內容 1LABEL=dylan none ntfs rw,auto,nobrowse 這邊的 dylan 是我的硬碟名稱, 注意須將此處改為所查詢到的硬碟名稱, 後面的ntfs rw 表示把這個分區掛載為可讀寫的 ntfs 格式。最後 nobrowse 非常重要，因為這個代表了在 finder 裡不顯示這個磁碟，如果不打開的話掛載是不會成功的。 現在插入此硬碟都可以正常寫入檔案了,若之後有其他 NTFS 格式硬碟需要做寫入再重複寫入上述內容即可 捷徑到這部基本上已經完成了,剩下一個小問題, 目前這個硬碟在 finder 裡不顯示了，那麼我們要怎麼找到它呢解決辦法其實很簡單，由於現在這個硬碟是掛在 /Volumes 資料夾下的，我們只要找到這個資料夾，然後把裡面的硬碟在桌面上做一個捷徑就行了。 開啟終端機輸入 1sudo ln -s /Volumes/dylan ~/Desktop/dylan 此指令會將目標 /Volumes/dylan 複製一個捷徑, 放到桌面上, 並命名為 dylan 建立快捷方式後，又出現了新的問題，無論有沒有插入硬碟。這個捷徑 icon 會一直在桌面，不太美觀。 隱藏桌面捷徑，拖入 Finder 側欄打開 Finder 將桌面的捷徑拖入側邊欄, 方便之後快速造訪 隱藏桌面硬碟捷徑，打開 terminal 執行 12cd ~/Desktopmv dylan .dylan 若要退出硬碟時 禁用 NTFS 寫入如果不需要 NTFS 的寫入，只需刪除 /etc/fstab 便可，輪入下面的指令 1sudo rm /etc/fstab 疑難排解啟用 NTFS 的寫入操作之後，你有時可能會發現，插入外接硬碟後，無法正常讀取，這是由於你之前沒有在 Windows 上做安全移除所造成。這是因為蘋果沒有 fsck 去修復 NTFS 上的問題，去清理 log 文件。您可以通過以下方法去驗證是這個問題，先插入儲存裝置，然後在 Terminal 輸入以下命令 1sudo dmesg 應該會顯示以下訊息 12345NTFS driver 3.11 [Flags: R/W].NTFS volume name DEVICE_NAME, version 3.1.NTFS-fs error (device /dev/dylan, pid 345): ntfs_system_inodes_get(): $LogFile is not clean. Mount in Windows.NTFS-fs error (device /dev/dylan, pid 345): ntfs_mount(): Failed to load system files (error 30).NTFS-fs error (device /dev/dylan, pid 345): ntfs_mount(): Mount failed (error 30). 解決方案 再次把儲存裝置連接到 Windows 中，通過安全移除斷開連接。 還原之前的備份，指令是1sudo mv /sbin/mount_ntfs.orig /sbin/mount_ntfs 參考資料如何在Mac OS X上讀寫NTFS格式的外置硬碟機/USB? (含疑難排解)Mac OSX 打開原生自帶讀寫NTFS功能]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用 Node.js 實作一個 Apache HTTP Server (三)]]></title>
    <url>%2Fuse-nodejs-build-a-apache-3.html</url>
    <content type="text"><![CDATA[前一篇用 Node.js 實作一個 Apache HTTP Server (二)，完成了大部分 Apache 目錄頁面的功能，最後提到還有一些部分可以做優化： 取得檔案大小、創建時間、修改時間資訊，判斷檔案類型 icon 點擊目錄內的檔案名，可以直接造訪該檔案 大標題路徑與請求路徑一致 當造訪的目錄內有 index 為名的檔案時，不顯示目錄，而是該檔案 優化程式碼 目前進度 server.js template.html 取得檔案大小、創建時間、修改時間資訊，判斷檔案類型 iconfs.statSync() - 取得資源詳細資訊Node.js 提供一個 API fs.statSync()，它接受一個路徑參數，回傳該路徑檔案或資料夾的詳細資訊(包含了檔案大小、創建時間、修改時間的資訊)。前面已經透過 fs.readdir 取得資料夾列表的所有成員的名稱字串，接著只需要將請求路徑字串及成員的名稱字串連接再當作參數帶入 fs.statSync() 即可取得目錄頁面所有成員的詳細資訊 這邊任意將一個資源路徑帶入 fs.statSync()，看看輸出的資料： 123456789101112131415161718192021Stats &#123; dev: 447961964, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 16888498603848728, size: 22, blocks: undefined, atimeMs: 1568171004525.9443, mtimeMs: 1568171004525.9443, ctimeMs: 1568171004525.9443, birthtimeMs: 1568170980574.5933, atime: 2019-09-11T03:03:24.526Z, mtime: 2019-09-11T03:03:24.526Z, ctime: 2019-09-11T03:03:24.526Z, birthtime: 2019-09-11T03:03:00.575Z &#125;2019-09-11T03:03:24.526Z2019-09-11T03:03:24.526Z 其中我們需要的資訊為 size 檔案大小(Byte) ctime 創建時間 mtime 修改時間 另外需要注意 fs.statSync() 輸出的時間格式為 RFC3999Date 時間格式，我們需要處理一下將它轉為像是 2019-01-01 11:11 這樣的格式 透過函式處理 12345var timeFormater = function(RFCdate) &#123; var millisecond = Date.parse(RFCdate) // RFC3999Date格式轉毫秒 var dateObj = new Date(millisecond) // 轉時間物件 return `$&#123;dateObj.toLocaleDateString()&#125; $&#123;dateObj.getHours()&#125;:$&#123;dateObj.getMinutes()&#125;`&#125; 目前每個資料夾目錄成員須具備的資訊有 檔名(或資料夾名) 檔案大小 創建時間 修改時間 將所有成員需要的資訊一一整理成物件 123456789101112131415161718192021222324252627282930313233if (fs.statSync(fullPath).isDirectory()) &#123; // 路徑為資料夾時，渲染抓資料夾內容，並渲染阿帕契目錄頁面 console.log('路徑為資料夾') // fs.readdir =&gt; 取資料夾內的成員 fs.readdir(fullPath, function (err, dirFiles) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; fs.readFile('./template.html', function (err, templateFile) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; // ********************Start******************** var filesDetailInfo = dirFiles.map((file) =&gt; &#123; // fs.statSync =&gt; 取得檔案或資料夾的詳細資料 var statSync = fs.statSync(fullPath + '/' + file) var fileDetail = &#123; fileName: file, // 檔名 size: statSync.size, // 檔案大小 createTime: timeFormater(statSync.ctime), // 創建時間 mutateTime: timeFormater(statSync.mtime), // 修改時間 &#125; return fileDetail &#125;) // 將資料帶入模板 var htmlStr = template.render(templateFile.toString(), &#123; files: filesDetailInfo &#125;) res.end(htmlStr) // ********************End*********************** &#125;) &#125;)&#125; 12345678910&lt;tbody id="tbody"&gt; &#123;&#123; each files &#125;&#125; &lt;tr&gt; &lt;td&gt;&lt;a class="icon file" href="#"&gt;&#123;&#123; $value.fileName &#125;&#125;&lt;/a&gt;&lt;/td&gt; &lt;td class="detailsColumn"&gt;&#123;&#123; $value.size &#125;&#125; Byte&lt;/td&gt; &lt;td class="detailsColumn"&gt;&#123;&#123; $value.createTime &#125;&#125;&lt;/td&gt; &lt;td class="detailsColumn"&gt;&#123;&#123; $value.mutateTime &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125;&lt;/tbody&gt; 目錄頁面成員類型icon (資料夾或檔案)目前目錄頁面的成員無論是什麼檔案類型，一律都是顯示檔案的 icon，現在我們需要做判斷，資料夾就渲染資料夾 icon，其他的就渲染檔案 icon。我們可以利用 art-template 的 if 功能配合正規式判斷，正規式的判斷方式很簡單，只要成員的名稱出現 . 我們可以直接判定它是具附檔名的一般檔案，檔名沒有出現 . 則一律當作資料夾處理。 12345678910111213&#123;&#123; each files &#125;&#125;&lt;tr&gt; &lt;!-- 判斷 icon 是資料夾或是一般檔案 --&gt; &#123;&#123; if (/\./.test($value.fileName))&#125;&#125; &lt;td&gt;&lt;a class="icon file" href="#"&gt;&#123;&#123; $value.fileName &#125;&#125;&lt;/a&gt;&lt;/td&gt; &#123;&#123; else &#125;&#125; &lt;td&gt;&lt;a class="icon dir" href="#"&gt;&#123;&#123; $value.fileName &#125;&#125;&lt;/a&gt;&lt;/td&gt; &#123;&#123; /if &#125;&#125; &lt;td class="detailsColumn"&gt;&#123;&#123; $value.size &#125;&#125; Byte&lt;/td&gt; &lt;td class="detailsColumn"&gt;&#123;&#123; $value.createTime &#125;&#125;&lt;/td&gt; &lt;td class="detailsColumn"&gt;&#123;&#123; $value.mutateTime &#125;&#125;&lt;/td&gt;&lt;/tr&gt;&#123;&#123;/each&#125;&#125; 點擊檔案名即可造訪該檔案目前可以透過輸入網址造訪到單一檔案，但是點擊目錄頁面的檔案是沒有反應的，這裡可以透過 art-template 將請求路徑資料帶入 HTML a 標籤的 href 屬性即可。 將請求路徑與 port 號加上檔名字串接起來，傳入模板並帶入 href 屬性 123456var htmlStr = template.render(templateFile.toString(), &#123; path: filePath, // ** port: 9000, // ** files: filesDetailInfo&#125;)res.end(htmlStr) 修改模板 1&lt;td&gt;&lt;a class="icon file" href="http://127.0.0.1:&#123;&#123; port + path + '/' + $value.fileName &#125;&#125;"&gt;&#123;&#123; $value.fileName &#125;&#125;&lt;/a&gt;&lt;/td&gt; 大標題路徑與請求路徑一致將請求路徑及帶入模板即可 1&lt;h1 id="header"&gt;Index Of C:/nodejs/www&#123;&#123; path &#125;&#125;&lt;/h1&gt; 當造訪的目錄內有 index 為名的檔案時，不顯示目錄，而是該檔案dirFiles 為使用 fs.readdir() 所取出的資料夾成員陣列，透過迴圈及正規式判斷使否有成員名稱吻合 index. 123456789101112131415161718192021if (fs.statSync(fullPath).isDirectory()) &#123; // 路徑為資料夾時，渲染抓資料夾內容，並渲染阿帕契目錄頁面 console.log('路徑為資料夾') // fs.readdir =&gt; 取資料夾內的成員 fs.readdir(fullPath, function (err, dirFiles) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; // ********************Start******************** // 檢查該資料夾內是否有名為index的檔案，有則建立一個indexItem物件 var indexItem = &#123;&#125; dirFiles.forEach((file) =&gt; &#123; if (/index\./.test(file)) &#123; indexItem = &#123; hasIndexFile: true, fileName: file &#125; &#125; &#125;) // ********************End***********************&#125; 如果請求資料夾內有 index 為名的檔案，則直接回傳該檔案 12345678910111213141516171819202122232425262728293031// 檢查該資料夾內是否有名為index的檔案，有則建立一個indexItem物件var indexItem = &#123;&#125;dirFiles.forEach((file) =&gt; &#123; if (/index\./.test(file)) &#123; indexItem = &#123; hasIndexFile: true, fileName: file &#125; &#125;&#125;)// ********************Start********************// 如果有index，則回傳該檔案if (indexItem.hasIndexFile) &#123; var indexPathLocation = fullPath + '/' + indexItem.fileName fs.readFile(indexPathLocation, function(err, indexFile) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; res.end(indexFile) &#125;)// ********************End**********************// 若沒有則印出資料夾成員頁面&#125; else &#123; fs.readFile('./template.html', function (err, templateFile) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; var filesDetailInfo = dirFiles.map((file) =&gt; &#123; // 略.. &#125;&#125; 優化程式碼動態 Content-type 之前有一篇文章提到關於 Content-type ，若不清楚它是做什麼的可以先閱讀 伺服器傳送資源到客戶端時，檔案型態千百種，我們需要告訴客戶端瀏覽器當前的 response 檔案需要用什麼檔案類型來解析。首先可以透過 Node.js 提供的 path 核心模組中的 path.extname API 取得檔案副檔名 123// 引入核心模組var path = require('path')path.extname('index.js') // output: '.js' 了解使用方式後，就可以製作一個函式，將常見的檔案類型和對應的 Content-type 寫起來 1234567891011121314151617181920212223242526272829var returnContentType = function (fileName) &#123; var deputy = path.extname(fileName) switch(deputy) &#123; case '.html': return 'text/html; charset=utf-8' break case '.js': return 'application/x-javascript; charset=utf-8' break case '.css': return 'text/css; charset=utf-8' break case '.txt': return 'text/plain; charset=utf-8' break case '.jpg': return 'image/jpg' break case '.jpeg': return 'image/jpeg' break case '.png': return 'image/png' break default: return 'charset=utf-8' break &#125;&#125; 使用 1234567891011// 如果有index，則回傳該檔案if (indexItem.hasIndexFile) &#123; var indexPathLocation = fullPath + '/' + indexItem.fileName fs.readFile(indexPathLocation, function(err, indexFile) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; res.setHeader('Content-type', returnContentType(indexItem.fileName)) // ** res.end(indexFile) &#125;)&#125; 將 error page 導向包裝成函式1234var toErrorPage = function () &#123; res.setHeader('Content-type', 'text/html') return res.end('&lt;h1&gt;404 Not Found.&lt;/h1&gt;')&#125; 接著將程式碼中所有的 return res.end(&#39;404 Not Found.&#39;) 替換成 toErrorPage() Demo 資源 最終版本原始碼]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Node.js 中使用 art-template 模板引擎]]></title>
    <url>%2Fart-template.html</url>
    <content type="text"><![CDATA[安裝透過 npm 安裝 1npm install art-template --save 載入模組 1var template = require('art-template') HTML 模板文件template.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"/&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;大家好, 我叫: &#123;&#123; name &#125;&#125;&lt;/p&gt; &lt;p&gt;我今年 &#123;&#123; age &#125;&#125; 歲&lt;/p&gt; &lt;h1&gt;我來自 &#123;&#123; province &#125;&#125;&lt;/h1&gt; &lt;p&gt;我喜歡: &#123;&#123; each hobbies &#125;&#125; &#123;&#123; $value &#125;&#125; &#123;&#123; /each &#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; if (boo)&#125;&#125; &#123;&#123; test[0] &#125;&#125; &#123;&#123; else &#125;&#125; &#123;&#123; test[1] &#125;&#125; &#123;&#123; /if &#125;&#125; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 使用基本使用 12345678910111213141516fs.readFile('./template.html', function (err, data) &#123; if (err) &#123; return console.log('data readed error') &#125; // 預設讀取到的 data 是二進制數據 // 而模板引擎的 render 方法需要接收字串 // 所以在這裡需要把 data 二進制數據轉換為字串, 才可以給模板引擎使用 var ret = template.render(data.toString(), &#123; name: 'Dylan', age: 18, province: '台灣', hobbies: ['彈吉他', '寫程式', '玩滑板', '繪畫'] boo: true, test: ['if(boo)', 'if(!boo)'] &#125;)&#125;) console.log(ret) 輸出字串 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;/&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;大家好, 我叫: Dylan&lt;/p&gt; &lt;p&gt;我今年 18 歲&lt;/p&gt; &lt;h1&gt;我來自 台灣&lt;/h1&gt; &lt;p&gt;我喜歡: 彈吉他 寫程式 玩滑板 繪畫 &lt;/p&gt; &lt;p&gt; if(boo) &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 資源 art-template官方文件 在瀏覽器使用 art-template 範例 在 Node.js 使用 art-template 範例]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Node.js 實作一個 Apache HTTP Server (二)]]></title>
    <url>%2Fuse-nodejs-build-a-apache-2.html</url>
    <content type="text"><![CDATA[在用 Node.js 實作一個 Apache HTTP Server (一)中，已經初步用 Node.js 做出 Apache server 的功能了，我們可以透過 url 訪問伺服器 www 資料夾內的對應資源。接著我們要來實現另一項功能： 圖片來源： 網路 在 Apache 中，如果請求地址對應的資源是一個資料夾，Apache 會回應一個網頁，並將該資料夾內部的檔案顯示在網頁中。 目前程式碼12345678910111213141516171819202122232425// server.jsvar http = require('http')var fs = require('fs')var server = http.createServer()var wwwDir = './www'server.on('request', function (req, res) &#123; var url = req.url var filePath // 在 Apache 中，當請求路徑為 / 時，預設回傳 index.html url === '/' ? filePath = '/index.html' : filePath = url var fullPath = wwwDir + filePath fs.readFile(fullPath, function (error, data) &#123; if (error) &#123; return res.end('404 Not Found.') &#125; res.end(data) &#125;)&#125;)server.listen('9000', function () &#123; console.log('伺服器正在運行...')&#125;) 判斷請求路徑是否為資料夾 當請求路徑為資料夾時，顯示目錄頁面 目前我們可以造訪 ./www 資料夾內的檔案，但如果是請求路徑對應到的資源是資料夾的話，伺服器目前會回傳 404。現在我們需要做兩件事情： 當收到客戶端請求時，先確認該請求路徑在 ./www 資料夾中，是否有對應資源 若確認有對應資源，判斷該請求路徑對應的目標是資料夾或是檔案，若是資料夾就渲染目錄頁面，若是檔案就直接回應該檔案 fs.access() 判斷路徑是否存在1234567891011121314151617server.on('request', function (req, res) &#123; var url = req.url var filePath url === '/' ? filePath = '/index.html' : filePath = url var fullPath = wwwDir + filePath // *************Start*************** fs.access(fullPath, function (err) &#123; if (err) &#123; console.log('資源不存在') return res.end('404 Not Found.') &#125; else &#123; console.log('資源存在') // Do 2. &#125; &#125;) // **************End****************&#125;) fs.statSync() 取得資源的實例(Stats)將檔案路徑帶入參數 1fs.statSync(fullPath) 返回一個物件 12345678910111213141516171819Stats &#123; dev: 447961964, mode: 16822, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 10977524092275140, size: 0, blocks: undefined, atimeMs: 1568251013478.8442, mtimeMs: 1568251013478.8442, ctimeMs: 1568251013478.8442, birthtimeMs: 1568251006016.5771, atime: 2019-09-12T01:16:53.479Z, mtime: 2019-09-12T01:16:53.479Z, ctime: 2019-09-12T01:16:53.479Z, birthtime: 2019-09-12T01:16:46.017Z &#125; isDirectory() 判斷是否為資料夾我們可以透過 fs.statSync(fullPath).isDirectory() 來判斷該請求路徑是否為資料夾，該 API 會回傳一個布林值 123456789101112131415161718192021222324fs.access(fullPath, function (err) &#123; if (err) &#123; console.log('資源不存在') return res.end('404 Not Found.') &#125; else &#123; console.log('資源存在') // *************Start*************** if (fs.statSync(fullPath).isDirectory()) &#123; console.log('路徑為資料夾') // 路徑為資料夾時，抓資料夾成員內容，透過模板引擎寫入資料夾成員到目錄頁面的HTML模板，並回傳到客戶端 // ... 下方待續 &#125; else &#123; // 路徑為檔案時，回傳該檔案 console.log('路徑為一般檔案') fs.readFile(fullPath, function (error, data) &#123; if (error) &#123; return res.end('404 Not Found.') &#125; res.end(data) &#125;) &#125; // **************End**************** &#125;&#125;) 接著就可以專心處理請求路徑是資料夾時要做的後續邏輯了 抓取資料夾內檔案/資料夾的名稱現在我們已經可以判斷請求路徑是不是資料夾了，接著我們需要： 透過 Node.js 抓取目前請求路徑資料夾內的所有成員(包含資料夾及檔案)的名稱，丟到畫面上讓使用者看 fs.readdir() 取資料夾內的成員fs.readdir() 接收兩個參數 資料夾路徑字串 callback function，此函式有兩個參數 第一個參數是 error 讀取成功時為 null 讀取失敗時為一個物件 第二個參數是 data 讀取成功時為一個陣列，包含該資料夾內所有成員檔名字串 ex. [‘index.html’, ‘main.css’, ‘a-dir’] 讀取失敗時為 undefined 123456789if (fs.statSync(fullPath).isDirectory()) &#123; fs.readdir(fullPath, function (err, dirFiles) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; // 將 dirFiles 陣列資料套入模板引擎，產出出目錄頁面 HTML，接著回傳給客戶端 // ... 下方待續 &#125;)&#125; 模板引擎 art-template 基本的 art-template 用法請參考在 Node.js 中使用 art-template 模板引擎 延續上面的程式碼，接著我們要使用模板引擎將取得的資料夾成員處理成目錄頁面回傳給客戶端 12345678910111213141516171819if (fs.statSync(fullPath).isDirectory()) &#123; fs.readdir(fullPath, function (err, dirFiles) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; // **************Start**************** // 將 dirFiles 陣列資料套入模板引擎，產出出目錄頁面 HTML 字串，接著回傳給客戶端 fs.readFile('./template.html', function (err, templateFile) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; var htmlStr = template.render(templateFile.toString(), &#123; files: dirFiles &#125;) res.end(htmlStr) &#125;) // ***************End****************** &#125;)&#125; 目錄頁面模板 (template.html) 1234567891011121314151617181920212223&lt;body&gt; &lt;h1 id="header"&gt;Index Of C:/nodejs/www&lt;/h1&gt; &lt;table&gt; &lt;thead&gt; &lt;tr class="header" id="theader"&gt; &lt;th&gt;名稱&lt;/th&gt; &lt;th class="detailsColumn"&gt;大小&lt;/th&gt; &lt;th class="detailsColumn"&gt;創建時間&lt;/th&gt; &lt;th class="detailsColumn"&gt;修改時間&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id="tbody"&gt; &#123;&#123; each files &#125;&#125; &lt;tr&gt; &lt;td&gt;&lt;a class="icon file" href="#"&gt;&#123;&#123; $value &#125;&#125;&lt;/a&gt;&lt;/td&gt; &lt;td class="detailsColumn"&gt;XXX Byte&lt;/td&gt; &lt;td class="detailsColumn"&gt;2019-9-11 11:3&lt;/td&gt; &lt;td class="detailsColumn"&gt;2019-9-11 11:3&lt;/td&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt; 這邊的 HTML 省略了 CSS 樣式，需要完整版請參考目錄頁面模板 Demo現在我在專案目錄下的 www 開放資源資料夾新增些檔案，接著來訪問看看這些資源，看看效果吧。 還有一些可以優化的部分，下一篇再讓我們繼續吧： 取得檔案大小、創建時間、修改時間資訊，判斷檔案類型 icon 點擊目錄內的檔案名，可以直接造訪該檔案 大標題路徑與請求路徑一致 當造訪的目錄內有 index 為名的檔案時，不顯示目錄，而是該檔案 優化程式碼 資源 原始碼]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Node.js 實作一個 Apache HTTP Server (一)]]></title>
    <url>%2Fuse-nodejs-build-a-apache.html</url>
    <content type="text"><![CDATA[Apache 伺服器軟體有一個預設功能，假如我們有一個資料夾結構如下： 1234567— server.js— www ∟ index.html ∟ file ∟ index.html ∟ img ∟ 6.jpg 在 Apache 中，我們可以通過開啟本地網頁伺服器，並透過 127.0.0.1/index.html 訪問到 index.html，也可以透過 127.0.0.1/file/index.html 訪問到 index.html，另外如果在網址欄輸入不存在的路徑時，會有錯誤頁面。現在讓我們透過 Node.js 初步實現這個功能。 基本架構server.js 1234567var http = require('http')var fs = require('fs')var server = http.createServer()server.on('request', function (req, res) &#123;&#125;server.listen('8000', function () &#123; console.log('伺服器正在運行...')&#125;) 設定 url 對應的檔案判斷目前我們希望可以讓使用者透過網址直接訪問 www 資料夾內的資源，可以透過這樣來達成 1234567891011server.on('request', function (req, res) &#123; var url = req.url if (url === '/' || url === '/index.html') &#123; fs.readFile('./www/index.html', function (err, data) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; res.end(data) &#125;) &#125;&#125; 接著把所有資源的判斷式都補上 123456789101112131415161718192021222324server.on('request', function (req, res) &#123; var url = req.url if (url === '/' || url === '/index.html') &#123; fs.readFile('./www/index.html', function (err, data) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; res.end(data) &#125;) &#125; else if (url === '/file' || url === '/file/index.html') &#123; fs.readFile('./www/file/index.html', function (err, data) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; res.end(data) &#125;) &#125; else if (url === '/file/img/6.jpg') &#123; fs.readFile('./www/file/img/6.jpg', function (err, data) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; res.end(data) &#125; &#125; 優化 - 動態讀取上面這樣的方式在伺服器資源越來越多時，每新增一個檔案就必須要寫一個判斷式，非常沒有效率。我們可以用更聰明的方式來達成一樣的效果。 我們可以將請求路徑的根當作 www 資料夾，依據請求路徑到 www 資料夾找出相對應的檔案，例如請求路徑為 /AAA/B.html，那我們就找找有沒有 www/AAA/B.html 的檔案，若有相應檔案就回應此檔案，若沒有就回應 404 頁面。實現方式： 先將 ./www 儲存在變數 wwwDir 中，所有資源將會以該資料夾為根目錄選找對應檔案 透過 wwwDir + 請求路徑，就能抓到將對應的檔案123456789101112131415var wwwDir = './www'server.on('request', function (req, res) &#123; var url = req.url var filePath // 在 Apache 中，當請求路徑為 / 時，預設回傳 index.html url === '/' ? filePath = '/index.html' : filePath = url fs.readFile(wwwDir + filePath, function (error, data) &#123; if (error) &#123; return res.end('404 Not Found.') &#125; res.end(data) &#125;)&#125;)]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js module system (一) - module.exports 及 require 運作原理]]></title>
    <url>%2Fnodejs-module-system.html</url>
    <content type="text"><![CDATA[在 Node.js 中，若有載入多支 JS 檔需求時，並不能像以往前端開發一樣，用 &lt;script&gt; 標籤引入多支檔案，且它也沒有 HTML 檔案來支持你這麼做。Node.js 須要使用 require 的方式來載入其他的 JS 檔案，這也是模組系統的主要使用方法。 什麼是模組?在 Node.js 中的模組(Module)，指的就是單一支一支的 JS 檔案，透過互相引入的方式來達成繫節關係。 簡單範例資料夾結構： nodejs-module ∟ A.js ∟ B.js 1234// A.jsconsole.log('A.js 開始執行了!')require('./B.js')console.log('A.js 結束執行了!') 12// B.jsconsole.log('B.js文件被載入且執行了!') 執行 node A.js 123A.js 開始執行了!B.js文件被載入且執行了!A.js 結束執行了! 也就是說，當你執行某支檔案時，程式碼執行到 require 字眼時，Node.js 就會執行被 require 那支檔案內的程式碼。 在 Node.js 中沒有全域作用域，只有模組作用域資料夾結構： nodejs-module ∟ A.js ∟ B.js 123456// A.jsvar foo = 'A'console.log('A.js 開始執行')require('./B.js')console.log('A.js 結束執行')console.log('foo 的值是' + foo) 1234// B.jsconsole.log('B.js 開始執行')var foo = 'B'console.log('B.js 結束執行') 在這個例子當中，若是以以往 &lt;script&gt; 載入的概念來看是像這樣的 12&lt;script src="A.js"&gt;&lt;/script&gt;&lt;script src="B.js"&gt;&lt;/script&gt; 全域的 foo 變數會被後來載入的 B.js 內的 foo 覆蓋，預期應 foo 應該會是 B。但是在 Node.js 中是這樣嗎？ 試著來輸出結果看看 12345A.js 開始執行B.js 開始執行B.js 結束執行A.js 結束執行foo 的值是A 延續上面的例子，如果我們在 A.js 中定義一個函數，並試著在 B.js 呼叫這個函數，能夠成功嗎？ 123456789// A.jsconsole.log('A.js 開始執行')function add (x, y) &#123; return x + y&#125;require('./B.js')console.log('A.js 結束執行') 1234// B.jsconsole.log('B.js 開始執行')console.log(add(10, 5))console.log('B.js 結束執行') 輸出結果 123console.log(add(10, 5)) ^ReferenceError: add is not defined 由上面的例子我們可以理解所謂模組作用域其實就是 檔案作用域，只要不是寫在自己本身的變數或函式，即使我載入了你，我還是不能取用你的東西的，載入就是單純執行對方內部的程式碼而已。 注意事項 require 時副檔名可以省略 1require('./B.js') // === require('./B') 載入自己寫的模組(JS檔)，相對路徑不得省略 1require('B.js') // Cannot find module 'B' 模組間的通信上面的例子或許讓你感到很困惑，既然載入了它，不就是為了要取用它的部分成員嗎？如果只是執行內部的程式碼，而不能取用成員，為何還要載入它呢？ 是的，Node.js 中預設模組是封閉了，你可以載入我，但你取用不到我任何的成員，內部無法取用外部; 外部也無法取用內部。 但有時候載入模組的目的不只是單純為了執行裡面的程式碼，更重要的是取用裡面的成員阿！ 那，該怎麼做？ 導出 (exports)Node 中的 require 方法有兩個作用 載入模組並執行裡面的程式碼 (也就是上面的例子) 拿到被加載模組所導出的接口物件 在每個模組中都提供一個物件 exports，我們可以將它導出，並讓其他模組接收，而它預設是一個空的物件 資料夾結構： nodejs-module ∟ A.js ∟ B.js 123// A.jsvar result = require('./B')console.log(result) 12// B.jsconsole.log('B.js 被加載執行了') 執行 node A.js 結果 12B.js 被加載執行了&#123;&#125; A.js 利用一個變數 require 了 B.js 的接口物件。結果發生了兩件事 執行了 B.js 檔案內的程式碼 result 變數接收了 B.js 的接口物件，由於 B.js 沒有導出任何成員，因此 A.js 接到的是空物件。 你可以試著在任一模組裡，印出 exports 物件，證明它預設就是一個空物件 12// B.jsconsole.log(exports) 執行 node B，果然得到一個空物件 1&#123;&#125; 導出成員了解上面的原理後，接著我們可以開始導出成員了，只需要將想被導出的成員放入 exports 物件中，接著讓須要取用的模組 require 即可 1234567891011// B.jsexports.foo = 'B'exports.add = function(x, y) &#123; return x + y&#125;// 此時的 exports 是// &#123;// foo: 'B',// add: function(x, y) &#123; return x + y&#125;// &#125; 12345// A.jsvar B_exports = require('./B')console.log(B_exports.foo)console.log(B_exports.add(10, 5)) 輸出 node A.js 結果 12B15]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[認識 Content-type]]></title>
    <url>%2Fcontent-type.html</url>
    <content type="text"><![CDATA[指定檔案類型當客戶端或是伺服器在互相傳遞資源時，可能會有各種格式的檔案，以文本為例，常見的就包含了 html、css、js(另外還有圖檔..等)，當伺服器在傳輸文本時傳送的都是字串，若沒有設定 Content-type 表頭，瀏覽器是不知道要用什麼檔案格式來解析這些字串的。 一般文本 (.txt)1234server.on('request', function (request, response) &#123; response.setHeader('Content-type', 'text/plain') response.end('&lt;h1&gt;Hello World!&lt;/h1&gt;')&#125;) HTML文本1234server.on('request', function (request, response) &#123; response.setHeader('Content-type', 'text/html') response.end('&lt;h1&gt;Hello World!&lt;/h1&gt;')&#125;) 圖檔 (.jpg)這裡使用到 Node.js 的 fs 核心模組，記得須要先載入 1var fs = require('fs') 123456789101112server.on('request', function (request, response) &#123; response.setHeader('Content-type', 'image/jpeg') // 讀取同層的 m.jpg 檔案 fs.readFile('./m.jpg', function (err, data) &#123; if (err) &#123; console.log('讀取檔案失敗') return &#125; else &#123; response.end(data) &#125; &#125;)&#125;) 檔案類型不勝枚舉，可以到這邊參考檔案類型對應的 Content-type 指定編碼如果未指定編碼，某些語言的文字輸出在網頁上時會變成亂碼，因為在伺服器發送資料時，預設都是 UTF-8 編碼內容，但瀏覽器並不知道伺服器發送來的內容是 UTF-8 的內容，而當瀏覽器在不知道伺服器回應的內容編碼時，它會按照當前客戶端系統的預設編碼來解析(中文預設編碼是 GBK 編碼)，進而產生亂碼，因此當你在發送數據時必須告訴瀏覽器你的編碼是哪一種。 UTF-8 萬國碼：簡單來說 UTF-8 可以辨識解析世界上大部分的語言，因次被廣泛使用 123server.on('request', function (request, response) &#123; response.end('你好世界!')&#125;) 使用 Content-type 定義編碼 1234server.on('request', function (request, response) &#123; response.setHeader('Content-type', 'text/plain; charset=utf-8') response.end('你好世界!')&#125;) 現在顯示正常了! 可以開啟開發人員工具 Network 觀察這次響應的詳細資料 另外除了可以透過 Content-type 來指令編碼，也可以在 HTML 頁面中透過 meta 標籤來聲明當前文本的編碼格式，瀏覽器也可以識別。 123&lt;head&gt; &lt;meta charset="utf-8"&gt;&lt;/head&gt;]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Node.js 開啟第一個網頁伺服器]]></title>
    <url>%2Fnodejs-http.html</url>
    <content type="text"><![CDATA[使用 Node.js 我們可以非常輕鬆建立起一個網頁伺服器，Node.js 為開發者提供一個核心模組 http，這個模組提供我們創建網頁伺服器的各種 API。 起手式123456789101112131415// 載入模組var http = require('http')// 使用 http.createServer() 方法建立 Web 伺服器，回傳一個 Server 實例var server = http.createServer()// 註冊 request 請求事件監聽，當前端請求過來，此事件就會被觸發，並且執行 callback 函式server.on('request', function () &#123; console.log('收到客戶端請求')&#125;)// 綁定 port，啟動伺服器server.listen(8000, function () &#123; console.log('伺服器已在 port 8000 運行 ...')&#125;) 運行伺服器，接著開啟瀏覽器輸入 127.0.0.1:8000 或是 localhost:8000，來試著造訪剛剛創建在本機的網頁伺服器 如果要停止伺服器服務，在 command line 中按 ctrl + C 即可終止。 處理請求事件server.on() 監聽的 callback 可以接收兩個函數，分別為 request 及 response。 取得請求路徑123server.on('request', function (request, response) &#123; console.log('客戶端請求路徑是' + request.url)&#125;) 測試 回應數據到瀏覽器透過 write() 方法回傳回應內容，並且透過 end() 告訴瀏覽器這次的請求已結束，請瀏覽器停止這次的響應。 12345server.on('request', function (request, response) &#123; response.write('Hello World!') response.end() // 也可以簡化成 response.end('Hello World!')&#125;) 接著造訪 127.0.0.1:8000 依不同的請求路徑回應不同內容到目前為止，任何的請求路徑都會回應相同的內容，例如：不管瀏覽器的 url 是 127.0.0.1:8000 或是 127.0.0.1:8000/login ..，伺服器目前都只會回應 你好世界!，要如何讓它去判斷請求呢? 其實若你已經會 JavaScript 的基本應用，這題非常的簡單。 我們可以利用剛剛用過的 request.url 搭配 if..else 來判斷不同請求，並回傳對應內容。 12345678910server.on('request', function (request, response) &#123; var url = request.url if (url === '/') &#123; response.end('你好世界!') &#125; else if (url === '/login') &#123; response.end('Login page') &#125; else &#123; response.end('404 page not found!') &#125;&#125;) 回應的內容只能是字串或是二進制數據(Buffer)這邊直接破題了，我們直接來證實看看這個標題是不是正確的吧 123server.on('request', function (request, response) &#123; response.end(12345)&#125;) 這時試著開啟伺服器 node main.js，終端機直接跳出錯誤提示，導致無法正常開啟伺服器 1TypeError [ERR_INVALID_ARG_TYPE]: The &quot;chunk&quot; argument must be one of type string or Buffer. Received type number 它告訴我們，必須只能是 字串 或者 二進制數據，但是剛剛接收到的型別是數字。 那如果要回應一個物件或是陣列的話可以嗎? 1234567891011121314151617server.on('request', function (request, response) &#123; var family = [ &#123; name: 'Dylan', age: 18 &#125;, &#123; name: 'Paul', age: 80 &#125;, &#123; name: 'John', age: 5 &#125; ] response.end(family)&#125;) 果然又噴出了一樣的錯誤 1TypeError [ERR_INVALID_ARG_TYPE]: The &quot;chunk&quot; argument must be one of type string or Buffer. Received type object 既然只能允許字串(與二進制數據)，還記得以前在寫 JavaScript 時是如何將物件轉成字串的嗎? 1234567891011121314151617server.on('request', function (request, response) &#123; var family = [ &#123; name: 'Dylan', age: 18 &#125;, &#123; name: 'Paul', age: 80 &#125;, &#123; name: 'John', age: 5 &#125; ] response.end(JSON.stringify(family))&#125;)]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Node.js 讀取及寫入檔案]]></title>
    <url>%2Fnodejs-readfile-and-writefile.html</url>
    <content type="text"><![CDATA[前言在瀏覽器中的 JavaScript 是不具有操作檔案的能力的，但在 Node.js 中提中了多個 API，支援檔案操作的功能 使用在 認識 Node.js 這一篇中提到 Node.js 提供了一系列的核心模組，當中有一個操作文件的模組名為 fs 模組，fs 為 file system 的簡寫，顧名思義，這個模組包含了原生 Node.js 提供的檔案操作相關 API。 使用 require 載入 fs 模組 1var fs = require('fs') readFile() 讀取文件目前的資料夾結構：nodejs ∟ main.js ∟ hello.txt 在 hello.txt 中寫下以下的文字，然後我們嘗試來把這份文件的內容給讀出來 1我是在 hello.txt 內的字串 fs 模組所提供的 readFile API 提供讀取文件的功能，並且須帶入兩個參數 欲讀取檔案的路徑 callback function，如認識 Node.js 中所提，Node.js 提供了大量非同步的 API，情況就類似於這個例子。這個 callback 也提供兩個參數： 當檔案讀取成功時： data → 檔案內的二進制數據 error → null 當檔案讀取失敗時(如路徑錯誤，或是檔案不存在)： data → undefined error → 一個物件 123456789// main.jsfs.readFile('./hello.txt', function (error, data) &#123; // 若錯誤 error 為一個物件，則會在這邊觸發內部程式碼，作為簡單的錯誤處理 if (error) &#123; console.log('讀取檔案失敗') return &#125; console.log(data)&#125;) 執行 1node main 輸出結果 1&lt;Buffer e6 88 91 e6 98 af e5 9c a8 20 68 65 6c 6c 6f 2e 74 78 74 20 e5 85 a7 e7 9a 84 e5 ad 97 e4 b8 b2&gt; 如前面所提及，readFile API 預設讀出來的結果為該檔案內容的二進制數據(輸出結果為16進制，是因為二進制又被轉為16進制了)，若要將它轉換為正常內容可以使用 JS 的toString() API 1console.log(data.toString()) 輸出結果 1我是在 hello.txt 內的字串 試著故意將欲讀取檔案的路徑寫錯，印出 error 來看看是怎麼回事吧 12345678// main.jsfs.readFile('hahaha', function (error, data) &#123; if (error) &#123; console.log(error) return &#125; console.log(data)&#125;) 輸出結果為一個物件 12345&#123; Error: ENOENT: no such file or directory, open &apos;C:\Users\Dylanliu\Desktop\nodejs\hahaha&apos;] errno: -4058, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;C:\\Users\\Dylanliu\\Desktop\\nodejs\\hahaha&apos; &#125; writeFile() 寫入文件目前的資料夾結構：nodejs ∟ main.js writeFile API 提供寫入文件的功能，並且須帶入三個參數 欲寫入的資料夾路徑，及生成的檔案名 檔案內容 callback function，接受一個 error 參數 當檔案寫入成功時： error → null 當檔案寫入失敗時： error → 一個物件 1234fs.writeFile('./hello.md', '# 我是被寫入的檔案',function (error) &#123; console.log(error) console.log('文件寫入成功')&#125;) 輸出結果 試著將檔名改為不合規格的名稱，測試看看失敗時 error 物件是什麼 123fs.writeFile('./&gt;&gt;.md', '# 我是被寫入的檔案',function (error) &#123; console.log(error)&#125;) 一樣產生了一個代表錯誤的物件 12345&#123; Error: ENOENT: no such file or directory, open &apos;C:\Users\Dylanliu\Desktop\nodejs\&gt;&gt;.md&apos;] errno: -4058, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;C:\\Users\\Dylanliu\\Desktop\\nodejs\\&gt;&gt;.md&apos; &#125; 別忘了做一個簡單的錯誤時處理 1234567fs.writeFile('./&gt;&gt;.md', '# 我是被寫入的檔案',function (error) &#123; if (error) &#123; console.log('文件寫入失敗') &#125; else &#123; console.log('寫入成功') &#125;&#125;)]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Node.js 執行 JavaScript 程式碼]]></title>
    <url>%2Frun-js-on-nodejs.html</url>
    <content type="text"><![CDATA[前言以往在做前端開發時，基本都是透過瀏覽器的 REPL 工具來測試 JavaScript 程式碼，而在 Node.js 中也提供類似的功能, 讓開發者可以在終端機中進行測試。 REPL我們可以簡單將這個術語理解為瀏覽器 console 的行為 Read Eval Print Loop 讀取輸入的程式碼 執行輸入的程式碼 打印執行結果 等待下次輸入程式碼 執行指定 JS 檔案我們有一支 main.js 檔案，它的路徑為 ~/Desktop/nodejs/main.js 1234// main.jsvar foo = 'I am a string'console.log(foo) 接著開啟 command line 工具，並將定位切到欲執行檔案的資料夾中 ~/Desktop/nodejs 接著執行(副檔名也可省略) 1node main.js 結果： 注意： 文件名稱不可為 node.js Node.js 中的 console 工具Node.js 也提供一個功能，類似於瀏覽器開發者工具的 console，可以直接在 Node.js 環境中測試 JavaScript 程式碼，做法非常簡單 在 command line 中輸入 1node 接著就可以直接將 command line 當作瀏覽器中的 console 來輸入 JavaScript 程式碼做測試了 若要跳出 console 模式，執行兩次 ctrl + C 即可]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[認識 Node.js]]></title>
    <url>%2Fwhat-is-nodejs.html</url>
    <content type="text"><![CDATA[Node.js 是什麼?Node.js 不是一個程式語言，也不是一個框架，它是一個 JavaScript 的 runtime(運行時環境)，並採用 Google 所開發的 V8 引擎執行程式碼，使用事件驅動、非阻塞和非同步輸入輸出等技術提高效能。 在 Node.js 出現以前，JavaScript 只能做為用戶端程式語言，並且只能在瀏覽器這個宿主中執行。Node.js 的出現使 JavaScript 也能夠脫離瀏覽器運行，可用於伺服器編程。另外 Node.js 含有一系列核心模組，使程式脫離 Apache HTTP Server 或 IIS，作為獨立伺服器執行。 Node.js 中的 JavaScript 與瀏覽器中的 JavaScript 差異瀏覽器中的 JavaScriptNode.js 環境中的 JavaScript 不同於瀏覽器端所執行的 JavaScript，一般而言過去在前端領域我們所認識的 JavaScript 含有： ECMAScript 基本語法 if var function 預設物件 Array Object Date Math … BOM DOM Node.js 中的 JavaScript然而在 Node.js 中，不同於瀏覽器端的 JS，它不含有 BOM 及 DOM，因為它執行在伺服器端，並不需要操做任何 HTML 的節點，它只含有 JS 的核心 也就是我們熟知的 ECMAScript。另外 Node.js 提供一系列伺服器相關核心模組，提供開發者多樣化的 API，如 HTTP 服務能力及文件操作能力.. 等等 ECMAScript 核心模組 讀寫文件 HTTP 網路服務建置 網路通信 … 建置於 Chrome V8 引擎上，是目前公認最快的 JS 引擎 Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. event-driven 事件驅動 non-blocking I/O model 非阻塞IO模型 (異步)，類似於 AJAX，Node.js 提供大量非同步 API 輕量及高效能 Node.js’ package ecosystem, npm is the largest ecosystem of open source libraries in th world npm 是世界上最大的開源套件生態系統 絕大多數 JavaScript 相關套件都存放在 npm 上，這樣做的目的是為了讓開發者更容易去下載使用 Node.js 可以做什麼? 伺服器後台 command line 工具 (如：npm、git、hexo …) 對於前端工程師而言，接觸 node 最多的是它的 command line 工具，如 Webpack、gulp、npm 等等 資源 官方 API 文件 簡體中文 API 文件(舊) Node 入門(篇幅較短) 七天學會 Node.js CNODE 社群]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Math 物件常用方法]]></title>
    <url>%2Fjavascript-math-object.html</url>
    <content type="text"><![CDATA[Math 是 JavaScript 的原生物件，提供各種數學功能。Math 物件是目前 JavaScript 原生物件裡唯一一個不是建構函數，不用實例化，所有的屬性和方法都是直接在 Math 物件上調用。 Math.abs()Math.abs() 方法接受一個參數，返回該參數的絕對值，通俗的說法就是把任何一個數值返回一個正整數 12Math.abs(10) // 10Math.abs(-10) // 10 Math.ceil()Math.ceil() 方法接受一個參數，並返回不小於該參數且最接近它的整數，即無條件進位 1Math.ceil(10.01) // 11 Math.floor()和 Math.ceil() 相反，即無條件捨去 1Math.floor(10.9) // 10 Math.round()Math.round() 接受一個數字參數，並回傳該參數四捨五入後的值 1Math.round(1.499) // 1 1Math.round(1.501) // 2 Math.min()Math.min() 方法接受多個參數，並回傳當中最小的數 1Math.min(1, 2, 3, 4, 5) // 1 Math.max()Math.max() 方法接受多個參數，並回傳當中最大的數 1Math.max(1, 2, 3, 4, 5) // 5 補充: Math.max() 和 Math.min() 不接受物件陣列參數，若需要取陣列中最大或是最小數可以用下列方法 apply 的第一個參數可以自定義的該函數所指向的 this，在此例中不需特別指定，帶入 null 即可。第二個參數為呼叫 apply 方法的方法(即下例的 Math.max 方法)預設帶入的參數，要注意的是須改以物件形式傳入，這是 apply API 的規範。 1Math.max.apply(null, [1, 2, 3, 4, 5]) // 5 也可以使用 ES6 Spread 將陣列拆解後帶入 1console.log(...[1, 2, 3, 4, 5]) // 1 2 3 4 5 1Math.max(...[1, 2, 3, 4, 5]) // 5 Math.random()Math.random() 回傳一個介於 0 到 1 的隨機數 1Math.random() // 輸出 0 - 1 間的隨機數 產生指定區間的整數亂數12345function getRandomNum(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125;getRandomNum(5, 10) // 隨機回傳 5 - 10 之間的整數 [Js] math.random() / Math.floor() 使用 getRandomNum 隨機取陣列中的值 12let arr = ['Dylan', 'Jack', 'Ralph', 'Tom', 'Rex']console.log(arr[getRandomNum(0, arr.length - 1)]) // 回傳 arr 中隨機成員 Math.pow()Math.pow(x, y) 方法接收兩個參數，回傳 x 的 y 次方 12Math.pow(2, 3) // 8Math.pow(5, 2) // 25 參考資料 MDN 掘金]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 JS 取得 Query String 資料]]></title>
    <url>%2Fparse-query-string.html</url>
    <content type="text"><![CDATA[前言Node.js 中的核心模組 url 提供了原生的 API 提供開發者解析 QueryString 123456789101112131415161718let url = require('url')let string = '/comment?name=狄倫&amp;gender=男&amp;hobby=coding'url.parse(string, true)// output：// &#123;// protocol: null,// slashes: null,// auth: null,// host: null,// port: null,// hostname: null,// hash: null,// search: '?name=名字&amp;message=我是一則訊息',// query: &#123; name: '狄倫', gender: '男', hobby: 'coding &#125;,// pathname: '/comments',// path: '/comments?name=名字&amp;message=我是一則訊息',// href: '/comments?name=名字&amp;message=我是一則訊息' // &#125; 今天如果不使用這個 API，我們也可以試著來實現看看簡易版的功能，將網址中的 QueryString 取出 實作假設這組字串是由前端傳遞過來的 QueryString 1let string = '/comment?name=狄倫&amp;gender=男&amp;hobby=coding' 將 QueryString 部分拆解出來 1234let data = string.split('?')// output：// ["/comment", "name=狄倫&amp;gender=男&amp;hobby=coding"]let queryStr = data[1] 接著再將每個 Key/Value Pair 拆分開 123let queryString = queryStr.split('&amp;')// output：// ["name=狄倫", "gender=男", "hobby=coding"] 遍歷資料，將各組 Key/Value 整理成物件格式 12345678let obj = &#123;&#125;queryString.forEach(item =&gt; &#123; let data = item.split('=') obj[data[0]] = data[1]&#125;)// output：// &#123;name: "狄倫", gender: "男", hobby: "coding"&#125; 包裝成函式 123456789function parseQueryString (urlString) &#123; let queryStr = urlString.split('?')[1].split('&amp;') let obj = &#123;&#125; queryStr.forEach(item =&gt; &#123; let data = item.split('=') obj[data[0]] = data[1] &#125;) return obj&#125; 相關延伸JavaScript 取得 Url 的 Query String]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Nodejs</tag>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 使用 userAgent 判斷操作系統和瀏覽器類型]]></title>
    <url>%2Fuser-agent-javascript.html</url>
    <content type="text"><![CDATA[JS使用userAgent判斷操作系統和瀏覽器類型]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>瀏覽器兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 動畫 - Transitions 及 Animation]]></title>
    <url>%2Fvue-transitions.html</url>
    <content type="text"><![CDATA[Vue 封裝好的 transition 元件提供開發者在插入、更新、移除 DOM 時，添加動畫轉場的效果。它提供三種應用方式: CSS 轉場 (CSS transition) &amp; CSS 動畫 (CSS animation) 搭配第三方動畫套件，如 Animation.css 搭配專用的 JavaScript 鉤子函式 使用條件 使用 v-if 使用 v-show 動態元件 (Dynamic Components)，如使用 :is ，透過字串變數進行元件切換 元件的根節點（Component Root Nodes） 方法1 - CSS 轉場 &amp; CSS 動畫預設的轉場類名使用 &lt;transition&gt; 時，Vue 會在特定時間點將對應的 class 加到元素中，然後再移除，產生進入和離開的漸變效果。 v-enter進入轉場開始的狀態。在元素插入前生效，在元素被插入後的下一幀移除 v-enter-active進入轉場過程的狀態。在整個進入轉場的階段中應用，在轉場完成之後移除。在這裡可以定義轉場的過程時間，延遲。如: transition: opacity .5s v-enter-to進入轉場結束的狀態。在元素被插入之後下一幀生效(與此同時 v-enter 被移除)，在轉場完成之後移除 (2.1.8版以上) v-leave離開轉場的開始狀態。在離開轉場被觸發時立即生效，下一幀被移除 v-leave-active離開轉場生效時的狀態。在整個離開轉場的階段中應用，在轉場完成之後移除。在這裡可以定義轉場的過程時間，延遲。如: transition: opacity .5s v-leave-to離開轉場結束的狀態。在 v-leave 被觸發之後下一幀生效(與此同時 v-leave 被移除)，在轉場完成之後移除 (2.1.8版以上) 來源: Vue 官方文件 若無自行定義類別的前綴詞，預設是 v- (如上)。若有自行定義需求，則可以在 &lt;transition&gt; 標籤添加 name 屬性，並且將預設類別 v- 的 v 改為自定義名稱。 CSS 轉場1234567&lt;div id="demo"&gt; &lt;button @click="show = !show"&gt;Toggle&lt;/button&gt; &lt;transition name="fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;) 123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to &#123; opacity: 0;&#125; See the Pen RzeYmR by Dylan (@dylan_demo) on CodePen. 流程敘述 第一次點擊按鈕，變數 show 被更改為 false，此時元素移除，同時觸發 leave → leave-active → leave-to 第二次點擊按鈕，變數 show 被更改為 true，此時元素插入，同時觸發 enter → enter-active → enter-to 另外 v-if 也可以改為 v-show，後者並不會移除元素，而是以 display: block 和 display: none 做切換。 CSS 動畫使用 CSS animation 和 CSS transition 基本上沒有太大差異，區別是在動畫中 v-enter 在節點插入 DOM 後不會立即刪除，而是在 animationend 事件觸發時刪除。 123456&lt;div id="demo"&gt; &lt;button @click="show = !show"&gt;Toggle show&lt;/button&gt; &lt;transition name="bounce"&gt; &lt;p v-if="show"&gt;Hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;) 1234567891011121314151617.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; See the Pen qzJMzB by Dylan (@dylan_demo) on CodePen. 方法2 - 搭配第三方動畫套件 (Animate.css)客製化的方式除了方法一之外，Vue 也提供了另外一種方式。我們可以直接在 ＜transition&gt; 標籤內插入屬性，值則為第三方庫寫好的 Class Name。以下範例使用 Animate.css 動畫庫做範例。 預設的轉場屬性我們可以通過以下屬性來自定義轉場類名，時間點可以對應到上面提到的預設的轉場類名： enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 範例12345678910&lt;div id="demo"&gt; &lt;button @click="show = !show"&gt;Toggle&lt;/button&gt; &lt;transition name="custom-classes-transition" enter-active-class="animated tada" leave-active-class="animated bounceOutRight" &gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;) See the Pen XLxPLG by Dylan (@dylan_demo) on CodePen. 方法3 - JavaScript 鉤子函式另一種方法則是在 &lt;transition&gt; 元素行內綁定鉤子，可以搭配 CSS 轉場和 CSS 動畫使用，也可單獨使用。 預設鉤子 beforeEnter(el)進入轉場/動畫前啟動 enter(el, callback)進入轉場/動畫之元素插入時啟動。done callback 則在結束時呼叫，可傳可不傳。與方法2所對應的時間點為 enter-class afterEnter(el)進入轉場/動畫時啟動。與方法2所對應的時間點為 enter-to-class enterCancelled(el)在未完成進入轉場/動畫時取消動作。 beforeLeave(el)離開轉場/動畫前啟動 leave(el, callback)離開轉場/動畫之元素插入時啟動。done callback 則在結束時呼叫，可傳可不傳。與方法2所對應的時間點為 leave-class afterLeave(el)離開轉場/動畫時啟動。 leaveCancelled(el)在未完成離開轉場/動畫時取消動作。與方法2所對應的時間點為 leave-to-class 補充：當只用JavaScript 轉場的時候，在enter和leave中必須使用done進行callback。否則，它們將被同步呼叫，轉場會立即完成。 補充：推薦對於僅使用 JavaScript 轉場的元素添加 :css=&quot;false&quot;，Vue 會跳過 CSS 的檢測。這也可以避免過渡過程中 CSS 的影響。 範例一個使用 Velocity.js 函式庫的簡單例子： 123456789101112131415&lt;div id="demo"&gt; &lt;button @click="show = !show"&gt; Toggle &lt;/button&gt; &lt;transition @before-enter="beforeEnter" @enter="enter" @leave="leave" :css="false" &gt; &lt;p v-if="show"&gt; Demo &lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526new Vue(&#123; el: '#demo', data: &#123; show: false &#125;, methods: &#123; beforeEnter(el) &#123; el.style.opacity = 0 el.style.transformOrigin = 'left' &#125;, enter(el, done) &#123; Velocity(el, &#123; opacity: 1, fontSize: '1.4em' &#125;, &#123; duration: 300 &#125;) Velocity(el, &#123; fontSize: '1em' &#125;, &#123; complete: done &#125;) &#125;, leave(el, done) &#123; Velocity(el, &#123; translateX: '15px', rotateZ: '50deg' &#125;, &#123; duration: 300 &#125;) Velocity(el, &#123; rotateZ: '100deg' &#125;, &#123; loop: 2 &#125;) Velocity(el, &#123; rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 &#125;, &#123; complete: done &#125;) &#125; &#125;&#125;) See the Pen YoJJKq by Dylan (@dylan_demo) on CodePen. 兩個元素的過場動畫透過 v-if 同時讓兩個元素進行過場。 1234567&lt;div id="demo"&gt; &lt;button @click="show = !show"&gt;toggle&lt;/button&gt; &lt;transition name="fade"&gt; &lt;h1 v-if="show"&gt;element1&lt;/h1&gt; &lt;h2 v-else&gt;element12&lt;/h2&gt; &lt;/transition&gt;&lt;/div&gt; 我們會發現，在動畫執行階段兩個元素會在同個時間交集，造成空間互相擠壓的問題。這並不是我們想要的結果。而 Vue 的 transition 元件提供了一個解法，我們可以為 transition 標籤加上另一個屬性 mode。 in-out： 新的元素先執行 enter，待完成後舊元素才執行 leave out-in：舊元素先執行 leave，待完成後新元素才執行 enter (一般符合預期的狀況) 稍作修改 1&lt;transition name="fade" mode="out-in"&gt; 另外有一點需要特別注意，剛剛的例子使用的是兩個不同元素(h1及h2)，是可以正常執行的，但是如果兩個元素是相同的就會出現一些問題。 1234567&lt;div id="demo"&gt; &lt;button @click="show = !show"&gt;toggle&lt;/button&gt; &lt;transition name="fade"&gt; &lt;h1 v-if="show"&gt;element1&lt;/h1&gt; &lt;h1 v-else&gt;element12&lt;/h1&gt; &lt;/transition&gt;&lt;/div&gt; 我們可以為 transition 標籤加上 key，來解決這個問題，key 內的值需要是唯一值，即每個元素的值不可重複，如此 Vue 才能判斷它為不同的元素，進而正常執行過場。 1234567&lt;div id="demo"&gt; &lt;button @click="show = !show"&gt;toggle&lt;/button&gt; &lt;transition name="fade"&gt; &lt;h1 v-if="show" key="1"&gt;element1&lt;/h1&gt; &lt;h1 v-else key="2"&gt;element12&lt;/h1&gt; &lt;/transition&gt;&lt;/div&gt; See the Pen ydRRPr by Dylan (@dylan_demo) on CodePen. 多個元素的過場前面的例子都是使用 v-if 來做過場效果，最多只有兩個元素，如果使用 v-for 產生的大量元素就必須使用 transition-group 元件。 transition-group 在編譯後預設會被轉換成 span 標籤，由這個標籤包住所有 v-for 渲染出來的元素。例如： 123&lt;transition-group name="fade"&gt; &lt;p v-for="num in 3" :key="num"&gt; num &lt;/p&gt;&lt;/transition-group&gt; 編譯結果為： 12345&lt;span&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt;&lt;/span&gt; 我們可以透過 tag 屬性將預設標籤改掉 123&lt;transition-group name="fade" tag="div"&gt; &lt;p v-for="num in 3" :key="num"&gt; num &lt;/p&gt;&lt;/transition-group&gt; 編譯結果為： 12345&lt;div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt;&lt;/div&gt; 注意：和 transition 元件一樣，在 transition-group 的元素也必須為它加上 key 使用 bootstrap 卡片元件來製作一個簡易的新增刪除功能的表單，並且使用 &lt;transition-group&gt; 加上動畫效果吧。 12345678910111213&lt;div id="demo"&gt; &lt;button @click="addCard"&gt;新增卡片&lt;/button&gt; &lt;transition-group name="fade" tag="div"&gt; &lt;div class="card mb-3 fade-item" v-for="(item, index) in data" :key="item.title" style="width: 18rem;"&gt; &lt;img src="" class="card-img-top"&gt; &lt;div class="card-body"&gt; &lt;h5 class="card-title"&gt; &#123;&#123;item.title&#125;&#125; &lt;/h5&gt; &lt;p class="card-text"&gt; &#123;&#123;item.text&#125;&#125; - &#123;&#123; item.timestamp &#125;&#125;&lt;/p&gt; &lt;a href="#" class="btn btn-primary" @click="removeCard(item.timestamp)"&gt; Delete&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition-group&gt;&lt;/div&gt; 123456789101112131415161718192021222324let app = new Vue(&#123; el: '#demo', data: &#123; data: [] &#125;, methods: &#123; addCard() &#123; let timestamp = function() &#123; const dateTime = new Date().getTime(); return Math.floor(dateTime / 100); &#125; this.data.push(&#123; timestamp: timestamp(), title: `標題 $&#123;this.data.length + 1&#125;`, text: `我是一個內容 $&#123;this.data.length + 1&#125;`, &#125;) &#125;, removeCard(title) &#123; this.data = this.data.filter((item)=&gt; &#123; return item.timestamp !== title; &#125;) &#125; &#125;,&#125;); See the Pen Rzevvx by Dylan (@dylan_demo) on CodePen. 重複利用動畫效果可以使用元件及插槽(Slot)封裝你精心設計的動畫效果，下個專案可以重複利用，這邊使用上面卡片的範例來做。 12345678910111213&lt;div id="demo"&gt; &lt;button @click="addCard"&gt;新增卡片&lt;/button&gt; &lt;list&gt; &lt;div class="card mb-3 fade-item" v-for="(item, index) in data" :key="item.title" style="width: 18rem;"&gt; &lt;img src="" class="card-img-top"&gt; &lt;div class="card-body"&gt; &lt;h5 class="card-title"&gt; &#123;&#123;item.title&#125;&#125; &lt;/h5&gt; &lt;p class="card-text"&gt; &#123;&#123;item.text&#125;&#125; - &#123;&#123; item.timestamp &#125;&#125;&lt;/p&gt; &lt;a href="#" class="btn btn-primary" @click="removeCard(item.timestamp)"&gt; Delete&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/list&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 區域元件 (二擇一)let list = &#123; template: ` &lt;transition-group name="fade" tag="div"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/transition-group&gt; `&#125;// 全域元件 (二擇一)Vue.component('list', &#123; template: ` &lt;transition-group name="fade" tag="div"&gt;\ &lt;slot&gt;&lt;/slot&gt;\ &lt;/transition-group&gt; `&#125;)let app = new Vue(&#123; el: '#demo', components: &#123; // 使用區域元件要加上元件物件 'list': list &#125;, data: &#123; data: [] &#125;, methods: &#123; addCard() &#123; let timestamp = function() &#123; const dateTime = new Date().getTime(); return Math.floor(dateTime / 100); &#125; this.data.push(&#123; timestamp: timestamp(), title: `標題 $&#123;this.data.length + 1&#125;`, text: `我是一個內容 $&#123;this.data.length + 1&#125;`, &#125;) &#125;, removeCard(title) &#123; console.log(title) this.data = this.data.filter((item)=&gt; &#123; return item.timestamp !== title; &#125;) &#125; &#125;,&#125;) See the Pen MMzGYp by Dylan (@dylan_demo) on CodePen. 參考資料Vue 官方文件Vue.js (14) - 過場效果及動畫Vue.js: 樣式與漸變 TransitionsVue.js: 動畫 AnimationsVue.js: 進階過渡效果]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 VScode 自訂程式碼片段(Snippets)，以 Vue 單一元件檔基本架構為例]]></title>
    <url>%2Fvue-snippet-template.html</url>
    <content type="text"><![CDATA[開啟 VScode 程式碼片段功能檔案(F) → 喜好設定 → 程式碼片段 選擇檔案類型此例選擇 vue.json，依情況有所不同 撰寫程式碼片段VScode 程式碼片段基本架構為 12345678"Print to console": &#123; "prefix": "log", "body": [ "console.log('$1');", "$2" ], "description": "Log output to console"&#125; 自訂片段名稱修改範例中的 &quot;Print to console&quot; 即可 自訂片段關鍵字修改範例中的 &quot;prefix&quot;: &quot;log&quot; 即可，完成儲存後我們就可以在所有該類型的檔案輸入 log + Tab 鍵 快速生成自訂的程式碼片段 自訂片段描述修改範例中的 &quot;description&quot;: &quot;Log output to console&quot; 即可 自訂片段程式碼主要的程式碼片段寫在 body 內，每一行都需要以 &quot; &quot; 雙上引號包覆，需要折行則加上 \n，若程式碼內需要使用到雙上引號，需要在前面加上反引號，如 \&quot;。 另外範例中的 $1 為生成該程式碼片段後閃爍游標所在位置，$2 則是再次按下 Tab 鍵後游標的下一個位置，依此類推。 Vue 單一元件檔基本架構程式碼片段範例123456789101112131415161718192021222324252627282930313233343536&#123; "vue template": &#123; "prefix": "vue", "body": [ "&lt;template&gt;", " &lt;div&gt;\n", " &lt;/div&gt;", "&lt;/template&gt;\n", "&lt;script&gt;", "export default &#123;", " props: &#123;\n", " &#125;,", " data() &#123;", " return &#123;\n", " &#125;;", " &#125;,", " computed: &#123;\n", " &#125;,", " created() &#123;\n", " &#125;,", " mounted() &#123;\n", " &#125;,", " watch: &#123;\n", " &#125;,", " methods: &#123;\n", " &#125;,", " components: &#123;\n", " &#125;,", "&#125;;", "&lt;/script&gt;\n", "&lt;style scoped lang=\"$&#123;1:scss&#125;\"&gt;\n", "&lt;/style&gt;\n", ], "description": "Create vue template" &#125;&#125; 再來就可以新增 .vue 副檔名檔案，輸入 vue 並按 tab 鍵使用囉。]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>VScode</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue - 為 props 預設型別及值]]></title>
    <url>%2Fprops-defualt-value-and-type.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738Vue.component('my-component', &#123; props: &#123; // 基礎的類型檢查 (`null` 和 `undefined` 會通過任何型別驗證) propA: Number, // 多個可能的型別 propB: [String, Number], // 必填的 String propC: &#123; type: String, required: true &#125;, // 帶有預設值的 Number propD: &#123; type: Number, default: 100 &#125;, // 帶有預設值的物件 propE: &#123; type: Object, // 物件和陣列預設值必須從一個 factory function 取得 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定義驗證函數 propF: &#123; validator: function (value) &#123; // 這個值必須符合下列字符串中的一個 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125; &#125;&#125;) 參考文件]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue - 動態切換 Class 及 Style 的方法]]></title>
    <url>%2Fvue-class-style-dynamic-switch.html</url>
    <content type="text"><![CDATA[先將等等會用到的 CSS 寫好 12345678910111213141516171819202122232425.box &#123; width: 150px; height: 150px; outline: 1px solid black; margin-top: 50px; margin-left: 50px; transition: all 0.5s ease-out;&#125;.rotate &#123; transform: rotate(45deg);&#125;.redColor &#123; background: red; outline: none;&#125;.bg-danger &#123; color: red;&#125;.radius &#123; border-radius: 100%;&#125; Class 樣式行內物件實體這個方式是我自己最常使用的，直接將物件寫在 :class 內，物件屬性為 class 名稱，值為條件判斷的參數。 1&lt;div class="box" :class="&#123;'rotate' : box.isTransform, 'bg-danger': box.isColor&#125;"&gt;&lt;/div&gt; 還需要有條件判斷的參數 12345678let app = new Vue(&#123; el: '#app', data:&#123; box: &#123; isTransform: false bg-danger: false &#125; &#125; 可以透過 點擊事件 或是 checkbox 來簡單操作條件判斷參數 這邊要注意在 HTML 內使用 - 是會報錯的，特殊情況(符號)時不可使用 . ，而需使用 [] 的物件寫法代替。 12&lt;input type="checkbox" v-model="box.isTransform"&gt;&lt;input type="button" value="rotate!" @click="box['bg-danger'] = !box['bg-danger']"&gt; 將 Class 列表以物件型態宣告在 Vue data 內這個方式雖然個人不常使用，但是寫起來更為簡潔好管理，可以讓 HTML 程式碼保持乾淨。 1&lt;div class="box" :class="classList"&gt;&lt;/div&gt; 宣告 Class 列表物件 1234567let app = new Vue(&#123; el: '#app', data:&#123; classList: &#123; rotate: false, redColor: false, &#125; 同樣可以來簡單操作條件判斷參數，不同的是這次是物件所以我們也用物件的方式來操作條件的布林值參數 12&lt;input type="checkbox" v-model="classList.rotate"&gt;&lt;input type="button" value="rotate!" @click="classList.redColor = !classList.redColor"&gt; 我們還可以寫一些函式，透過操作物件實踐動態新增 Class 樣式 12345methods: &#123; addSomeNewClass(className) &#123; this.classList[className] = true; &#125; &#125; 使用 1&lt;input type="button" value="addClass!" @click="addSomeNewClass('radius')"&gt; 陣列和剛剛的物件例子很相似，同樣可以直接將 Class 清單的陣列寫在行內，或是宣告在 Vue 應用程式的 data 中。寫在行內的情況較少，這邊只舉第二個例子。 1&lt;div class="box" :class="classArr"&gt;&lt;/div&gt; 1234let app = new Vue(&#123; el: '#app', data:&#123; classArr: ['rotate', 'redColor'], 透過 checkbox 來操作 Class 開關 12&lt;input type="checkbox" v-model="classArr" value="rotate"&gt;&lt;input type="checkbox" v-model="classArr" value="redColor"&gt; 一樣可以寫一些函式，透過操作陣列來動態新增 Class 樣式 12345methods: &#123; addSomeNewClass() &#123; this.classArr.push('radius') &#125; &#125; Style 樣式行內物件實體1&lt;div class="box" :style="&#123; backgroundColor: 'red', outline: '1px solid blue' &#125;"&gt;&lt;/div&gt; 1&lt;div class="box" :style="[&#123; backgroundColor: 'red' &#125;, &#123; borderWidth: '5px' &#125;]"&gt;&lt;/div&gt; 將行內 Style 列表以物件型態宣告在 Vue data 內1&lt;div class="box" :style="styleObject"&gt;&lt;/div&gt; 1&lt;div class="box" :style="[styleObject, styleObject2]"&gt;&lt;/div&gt; 1234567891011var app = new Vue(&#123; el: '#app', data: &#123; styleObject: &#123; backgroundColor: 'red', borderWidth: '5px' &#125;, styleObject2: &#123; width: '10 0px' &#125; &#125; 透過 JavaScript 操作物件來動態新增樣式 12345methods: &#123; addSomeNewStyle() &#123; this.styleObject.borderColor = 'green'; &#125; &#125; Codepen Demo See the Pen 4-28 動態切換 ClassName 及 Style 多種方法 by Dylan (@Dylan_Liu) on CodePen.]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常見的 JavaScript 正規式表單驗證功能]]></title>
    <url>%2Fform-validation-regexp.html</url>
    <content type="text"><![CDATA[JavaScript 表單驗證 by divaka]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>RegEx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 地下城挑戰 - 3F 計算機]]></title>
    <url>%2Fjs-3f-calculator.html</url>
    <content type="text"><![CDATA[圖片來源： 六角學院 前言這篇文章將會把重點放在兩個部分： eval() 函式 正規式 (Regular Expression) 在寫這個題目以前，我沒有實際使用過正規式，這個概念大概是一個月以前才接觸的，最後雖然是有把功能寫出來，但是品質還有待加強，不過有小小進步這個挑戰很值得了，日後找機會再加強相關知識吧！ DemoGithubCodepen 關卡資訊UI 設計稿 【特定技術】數字位數過多時，不能因此而破版，計算機功能皆須齊全 【自我學習】請在此關卡中「自學一個你原本不太會的技巧」，投稿時分享你透過哪些資源學習，並寫範例程式碼講解該技巧，以及你如何應用在此關卡上。 eval()語法 eval(string) 實例 可帶入一組字串，並執行字串中的 JavaScript 程式碼，且程式碼內可以包含變數及已存在物件的屬性。 123456789101112eval('2 + 2') // 4//----------------------------let x = 10eval('x + 20') // 30//----------------------------eval('x=10; y=20; console.log(x * y)') // 200//----------------------------let obj = &#123; name: 'Dylan', age: 18 &#125;eval('console.log(obj.name)'); // Dylan 如果 eval() 的參數不是字串，它將會將參數原封不動的返回該參數。 12eval(new String("2 + 2")); // String &#123;"2 + 2"&#125;eval("2 + 2"); // 4 如果要避免這個情況你可以先將參數進行轉字串的處理 12var expression = new String("2 + 2");eval(expression.toString()); // 4 本次關卡應用在了解 eval() 的用法後，可以開始思考開如何運用在計算機這個題目中？ 數字及運算符號功能我們可以先宣告一組字串，代表計算機等待被計算的算式。 1let formula = '' 當我們按下按鍵後，應該要為 formula 字串增加該按鈕的值。為了達到這點，所有的數字按鍵和加減乘除都需要新增事件監聽。 123456789101112131415&lt;div class="button"&gt;0&lt;/div&gt;&lt;div class="button"&gt;1&lt;/div&gt;&lt;div class="button"&gt;2&lt;/div&gt;&lt;div class="button"&gt;3&lt;/div&gt;&lt;div class="button"&gt;4&lt;/div&gt;&lt;div class="button"&gt;5&lt;/div&gt;&lt;div class="button"&gt;6&lt;/div&gt;&lt;div class="button"&gt;7&lt;/div&gt;&lt;div class="button"&gt;8&lt;/div&gt;&lt;div class="button"&gt;9&lt;/div&gt;&lt;div class="button"&gt;.&lt;/div&gt;&lt;div class="button"&gt;÷&lt;/div&gt;&lt;div class="button"&gt;×&lt;/div&gt;&lt;div class="button"&gt;+&lt;/div&gt;&lt;div class="button"&gt;-&lt;/div&gt; 12345document.querySelectorAll('.button').forEach((item) =&gt; &#123; item.addEventListener('click', function(event)&#123; formula += event.target.innerText &#125;, false)&#125;) 可以開啟這個 domo 操作一下，試著打一些簡單的加減乘除計算，再到 console 觀察 formula 變數的改變。到這個階段還有一個問題是可能會有一些不合規格的算式出現，如 1+÷1 這種無法被計算的情況，這就需要留到後面用正規式處理了。 接著繼續新增剩下的按鈕功能 = 功能在使用者按下等於按鈕時將 formula 變數帶入 eval() 函數中，並將回傳值帶入 result 變數，也就是之後會渲染在計算機上的答案。 1&lt;div class="equal"&gt;=&lt;/div&gt; 12345let result;document.querySelector('.equal').addEventListener('click', function()&#123; result = eval(formula);&#125;, false) AC 功能清空功能最單純，按下後將 formula 變數改為空字串即可。 1&lt;div class="ac"&gt;AC&lt;/div&gt; 1234document.querySelector('.ac').addEventListener('click', function()&#123; formula = ''; result = 0;&#125;, false) ⌫ 功能點擊回上一步後，將 formula 字串的最後一個字元刪除。做法是先用 split(&#39;&#39;) 將 formula 字串轉為陣列，舉例說如果 formula 當前值為 1+1，經過 split(&#39;&#39;) 處理會變成陣列[&#39;1&#39;, &#39;+&#39;, &#39;1&#39;]，再用 pop() 將陣列最後一元素移除，然後再透過 join(&#39;&#39;) 轉回字串，結果 formula 由 1+1 變成了 1+。 參考： JavaScript 陣列處理常用方法 1&lt;div class="del"&gt;⌫&lt;/div&gt; 12345document.querySelector('.del').addEventListener('click', function()&#123; let toArr = formula.split(''); toArr.pop(); formula = toArr.join('');&#125;, false) 到這裡所有按鈕的功能告一段落，可以用這個 Demo 操作看看。接著我們來講講如何用正規式來篩選掉不合計算機規則的算式。 使用正規式過濾掉不合法的算式排列如果對於正規式還不熟的朋友可以參考初探正規式這篇。 正規式是用來做什麼的呢？ 正規式也可稱正則表達式、正規表達式…etc，我自己對於它的第一個印象是，這..是機器語言吧？ 不覺得它是我能理解的東西，不過我們需要拋開偏見和恐懼，可以試著先去接觸看看，你會發現它是一個很棒的工具。 舉個正規式常見的應用，當我們在註冊某些網站的帳號時，為什麼當我們再輸入 Email 時，這個網站都會提醒我的 Email 格式是正確或是錯誤的，它是怎麼判斷的呢？其實這就是利用正規式來做檢測的，請參考[Javascript] Regular Expression – Email 表單驗證。 替換乘除符號剛剛我們在實作時有一個小問題，當我們點擊 ÷ 和 × 時，會直接將這兩個字元帶入 formula 變數中，若變數值為 6÷2，按下 = 按鈕後，變數被帶入 eval() 函式處理，結果拋出錯誤 &quot;SyntaxError: Invalid or unexpected toke，原因是 eval() 函式是不認得 ×÷ 符號的，我們需要處理一下當使用者按下 ×÷ 時需要把它替換成 */，試著用正規式來做吧。 1formula.replace(/\÷/g, `/`).replace(/\×/g, `*`); 異常數字處理我們還需要排除開頭一個零以上和開頭零後面接數字的狀況，舉例說像式 00123 + 01235 的算式是不合理的，必須要做處理。 1formula.replace(/^0[0-9]+/, `0`).replace(/([/*+-])0\d+/g, `$10`); 異常運算符號排列處理正常的算式中不會出現相連的運算符號，比如 1+-2，或是運算符號出現在開頭的情況 + 123 + 321。 1formula.replace(/^[/*+-]+/, ``).replace(/([/*+-])[/*+-]+/g, `$1`); 異常小數點處理接著是比較複雜一點的小數點處理 算式開頭不能有小數點 .123 + 123 不能有相連的小數點 1..23 + 8 不會有 00.123 這樣的情況 運算符號後面不能出現小數點 123 + .123 同一組數字不會出現第二個小數點 123.123.3 1234567function fn(formula) &#123; const newStr = formula.replace(/^\.*/, ``); const _newStr = newStr.replace(/\.+/g, `.`); const __newStr = _newStr.replace(/\D00\.(\d+)/g, `0.$1`); const ___newStr = __newStr.replace(/([/*+-])\./g, `$1`); return ___newStr.replace(/(\d+)\.+(\d+)\.*/g, `$1.$2`);&#125; 千分位最後需要套用千分位，把運算結果渲染到計算機上，如果數字是 10000 會被轉換成 10,000。 12345function toCurrency(formula) &#123; let newStr = formula.toString().split("."); newStr[0] = newStr[0].replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, ","); return newStr.join(".");&#125; 到這邊計算機的功能差不多完成了，可以到最後的 Demo 試著操作看看，再來就剩下一些畫面和細節的處理，有興趣的話請參考完整版。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>JS地下城</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>RegEx</tag>
        <tag>JS地下城</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 parseFloat()、parseInt()、Number() 轉換型別]]></title>
    <url>%2Fjs-parse-to-number.html</url>
    <content type="text"><![CDATA[parseFloat() parseFloat(string) parseFloat() 函數可解析一個字串，並返回一個浮點數。該函數指定字串中的首個字符是否是數字。如果是，則對字符串進行解析，直到到達數字的末端為止，然後以數字返回該數字，而不是字串。 參數 描述 string 必需。要被解析的字符串。 特性 只有字串中的第一個數字會被返回。 開頭和結尾的空格是允許的。 如果字串的第一個字符不能被轉換為數字，那麼 parseFloat()會返回 NaN。 例子12345678parseFloat("10") // 10parseFloat("10.33") // 10.33parseFloat("34 45 66") // 34parseFloat(" 60 ") // 60parseFloat("40 years") // 40parseFloat("He was 40") // NaNparseFloat('010') // 10parseFloat(010) // 8 開頭為 0 的 Number 型別會被當作八進制帶入 parseInt() parseInt(string, radix) stringparseInt() 函數可解析一個字串，並返回一個整數。 radix當參數 radix 的值為 0，或沒有設置時，parseInt() 會根據 string 來判斷 radix 的基數。 如果string 以 1 ~ 9 的數字開頭，parseInt() 將把它解析為十進制的整數。 如果string 以 “0x” 開頭，parseInt() 會把 string 的其餘部分解析為十六進制的整數。 如果string 以 0 開頭，那麼 ECMAScript v3 允許parseInt() 的一個實現把其後的字符解析為八進製或十六進制的數字。 參數 描述 string 必需。要被解析的字符串。 radix 可選。表示要解析的數字的基數。該值介於 2 ~ 36 之間。 特性 只有字串中的第一個數字會被返回。 開頭和結尾的空格是允許的。 如果字串的第一個字符不能被轉換為數字，那麼 parseInt()會返回 NaN。 在字符串以 “0” 為開始時舊的瀏覽器默認使用八進制。ECMAScript 5，默認為十進制。 例子1234567891011121314parseInt("10") // 10parseInt("10.33") // 10parseInt("34 45 66") // 34parseInt(" 60 ") // 60parseInt("40 years") // 40parseInt("He was 40") // NaNparseInt('010') // 10parseInt(010) // 8 開頭為 0 的 Number 型別會被當作八進制帶入 (參考補充) parseInt("10",10) // 10parseInt("010") // 10parseInt("10",8) // 8parseInt("0x10") // 16parseInt("10",16) // 16 補充留意 parseInt 用法 Number() Number(object) Number() 函數把對象的值轉換為數字，如果對象的值無法轉換為數字，那麼 Number() 函數返回 NaN。 參數 描述 object 可選。一個 JavaScript 對象。如果沒有提供參數，則返回 0。 特性 如果參數是 Date 對象，Number() 返回從 1970 年 1 月 1 日至今的毫秒數 (TimeStamp)。 12const date = new Date();Number(date); //1561453521912 例子12345678Number(true); // 1Number(false); // 0Number("999"); // 999Number("010"); // 10Number(010); // 8 開頭為 0 的 Number 型別會被當作八進制帶入 Number("999 888"); // NaNNumber("lucky777"); // NaNNumber("777lucky") // NaN 補充若遇到上例有空格字符的情況，可以使用正規式將空格過濾後再帶入函式，參考初探正規式 1Number("999 888".replace(/\s/g, ``)); // 999888]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[談談 JavaScript 的深拷貝及淺拷貝]]></title>
    <url>%2Fclone-deep.html</url>
    <content type="text"><![CDATA[基本型別及物件型別JavaScript上所有的東西可以分成兩大類：純值 Primitive Types 和 物件型別 Object Type 基本型別aka純值 (Primitive Types) 數字 number 字串 string 布林值 boolean undefined null 符號 symbol （ES6) 物件型別 (Object Type)JavaScript 中除了 Primitive Types 以外的東西，全都是物件型別！ 傳值 (by value)基本型別為傳值特性，將純值 b 指向純值 a，當中 a 或 b 進行修改時，不會互相影響。 123456var a = 1;var b = a;b = 2;console.log(a); // 1 console.log(b); // 2 傳參考 (by reference)物件型別特性是傳參考，將兩個物件互相指向，修改任一物件內部的屬性，都會影響另一個物件，因為這兩個變數都被指向同一個記憶體位置。 物件 123456var obj1 = &#123; name: 'dylan', age: 18 &#125;;var obj2 = obj1;obj2.age = 21;console.log(obj1); // &#123;name: "dylan", age: 21&#125;console.log(obj2); // &#123;name: "dylan", age: 21&#125; 陣列 123456var arr1 = [1, 2, 3];var arr2 = arr1;arr2[0] = 10;console.log(arr1) // [10, 2, 3]console.log(arr2) // [10, 2, 3] 如果要避免傳參考，最簡單的方法可以這麼做。由於物件的指向都是傳參考，而純值為傳值，我們可以一一的去指向物件內的純值來避免這個問題，缺點是非常麻煩。 123456var obj1 = &#123; name: 'dylan', age: 18 &#125;;var obj2 = &#123; name: obj1.name, age: obj1.age&#125;;obj2.age = 21;console.log(obj1); // &#123;name: "dylan", age: 18&#125;console.log(obj2); // &#123;name: "dylan", age: 21&#125; 淺拷貝及深拷貝的定義來源: Stack Overflow 淺拷貝 深拷貝 只是複製 collection structure，而不是 element 。當在指向第二層物件時會出現傳參考問題 整個複製，包含 element 。所以當我們在使用多層物件時，要盡量用 deep copy 淺拷貝 (Shallow Copy)以下舉幾個常見的淺拷貝範例 Array.concat &amp; Array.slice使用這兩個的結果是一樣的，也是傳統較常見的淺拷貝方式。詳細的用法請參考這篇 JavaScript 陣列處理常用方法 Array.concat 12var arr1 = [1, 2, 3, &#123;aa: 'aa'&#125;];var arr2 = arr1.concat(); Array.slice 12var arr1 = [1, 2, 3, &#123;aa: 'aa'&#125;];var arr2 = arr1.slice(); 看看結果 12console.log(arr1); // [1, 2, 3, &#123;aa: 'aa'&#125;]console.log(arr2); // [1, 2, 3, &#123;aa: 'aa'&#125;] 試著改變陣列第一層的值，結果並沒有造成傳參考，證明這個拷貝是成功了 1234arr1[0] = 'Dylan';console.log(arr1); // ["Dylan", 2, 3]console.log(arr2); // [1, 2, 3] 接著改變陣列中第二層物件內的值，結果發生了傳參考的問題 1arr2[3].aa = 'bb'; 12console.log(arr1); // ["Dylan", 2, 3, &#123;aa: 'bb'&#125;]console.log(arr2); // ["Dylan", 2, 3, &#123;aa: 'bb'&#125;] Array.from &amp; Spread這是兩個都是 ES6 新增的，效果和 slice 及 concat 是一樣的，但是可讀性較佳，算是一種語法糖。 Array.from 12var arr1 = [1, 2, 3, &#123;aa: 'aa'&#125;];var arr2 = Array.from(arr1); Spread 12var arr1 = [1, 2, 3, &#123;aa: 'aa'&#125;];var arr2 = [...arr1]; 看看結果 12console.log(arr1); // [1, 2, 3, &#123;aa: 'aa'&#125;]console.log(arr2); // [1, 2, 3, &#123;aa: 'aa'&#125;] 由於同上例子是屬於淺拷貝，結果是一樣的，這裡就簡單示範使用方法，不再作後續實驗。 兩者實際使用差異 Array.from 和 Spread 在實際使用上還是有差異的，請參考這篇 Spread Array.from 它不是運算符，僅適用於可迭代( iterable )的陣列 也適用於不可迭代的偽陣列( 具有 length 屬性和索引屬性的陣列 ) 1234567const arrayLikeObject = &#123; 0: 'a', 1: 'b', length: 2 &#125;;// This logs ['a', 'b']console.log(Array.from(arrayLikeObject));// This throws TypeError: arrayLikeObject[Symbol.iterator] is not iterableconsole.log([...arrayLikeObject]); 結論是，當你想要將某東西轉換成陣列時，推薦使用 Array.from，因為他更好閱讀。而當你想要連接多個陣列時，Spread 可能較適合，如 [&#39;a&#39;, &#39;b&#39;, ...someArray, ...someOtherArray] 參考：ES6 - Spread 展開與其餘參數 Object.assignObject.assign 的可以傳入兩個參數，第一個參數可以是物件或是陣列，第二個參數為要合併的目標，若第一個參數帶入空物件或空陣列就可以達到淺拷貝的效果。 12345var obj1 = &#123; name: 'Dylan', family: &#123; dad: 'Rob', mom: 'Mary'&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1) 輸出看看，看似結果一樣 12console.log(obj1);console.log(obj2); 但是由於淺拷貝的特性，第二層以後的物件還是會有傳參考的問題。 12console.log(obj1 === obj2); // falseconsole.log(obj1.family === obj2.family); // true 在來試著改變其中一個物件的第一層純值，結果並不會傳參考。 1234obj2.name = 'Tony';console.log(obj1); // &#123;name: "Dylan", family: &#123;…&#125;&#125;console.log(obj2); // &#123;name: "Tony", family: &#123;…&#125;&#125; 再來試著改變物件中的第二層物件，結果就不同了，形成傳參考，這也是淺拷貝的問題。 1obj2.family.dad = 'Walt'; 深拷貝 (Deep Copy)這邊一樣舉一些例子介紹 JSON.stringify 再 JSON.parse我們可以使用 JSON.stringify 將陣列或物件轉換成字串後，再用 JSON.parse 轉回來。 12345var obj1 = &#123; name: 'Dylan', family: &#123; dad: 'Rob', mom: 'Mary'&#125;&#125;;var obj2 = JSON.parse(JSON.stringify(obj1)); 12console.log(obj1 === obj2); // falseconsole.log(obj1.family === obj2.family); // false 即使修改第二層物件，也不會影響另一個陣列的內容 1obj2.family.dad = 'Walt'; 這樣就是真正的 Deep Copy，也是這篇介紹唯一不需要使用其他函式庫的深拷貝方式，非常方便，但缺點是只有可以轉成 JSON 格式的物件才可以使用，例如 function 就沒有辦法被轉成 JSON。 12var obj1 = &#123; fn: function()&#123; console.log('aaa') &#125; &#125;;var obj2 = JSON.parse(JSON.stringify(obj1)); 驗證 12345console.log(obj1.fn); // ƒ ()&#123; console.log('aaa') &#125;console.log(obj2.fn); // 'undefined'console.log(obj1 === obj2); // falseconsole.log(obj1.fn === obj2.fn); // false 被複製物件內的 function 會消失，所以這個方法只能用在單純只有資料的物件。 jQuery我們還可以使用 jQuery 的 $.extend 來做到深拷貝 123456var obj1 = &#123; name: 'Dylan', family: &#123; dad: 'Rob', mom: 'Mary'&#125;&#125;;var obj2 = $.extend(true, &#123;&#125;, obj1); 驗證 12console.log(obj1 === obj2); // falseconsole.log(obj1.family === obj2.family); // false lodash這是一個非常多人在使用的函式庫，我們可以使用他所提供的 _.cloneDeep 來做到深拷貝，效能佳，且使用簡單易讀。 123456var obj1 = &#123; name: 'Dylan', family: &#123; dad: 'Rob', mom: 'Mary'&#125;&#125;;var obj2 = _.cloneDeep(obj1); 驗證 12console.log(obj1 === obj2); // falseconsole.log(obj1.family === obj2.family); // false 參考資料[Javascript] 關於 JS 中的淺拷貝和深拷貝關於JAVASCRIPT中的SHALLOW COPY(淺拷貝)及DEEP COPY(深拷貝)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 地下城挑戰 - 2F 時鐘]]></title>
    <url>%2Fjs-2f-clock.html</url>
    <content type="text"><![CDATA[圖片來源： 六角學院 前言這關 UI 的部分可以選擇用 CSS 手刻或是直接使用現成的圖片。大部分的時間在處理 UI 的部分，有一個關鍵的 CSS 屬性 transform-origin，稍後會介紹到，時鐘運作的 JavaScript 相對來說就比較不這麼繁瑣，做一些數學加減運算，配合 Date物件 取得時分秒參數即可。 DemoGithub 關卡資訊UI設計稿 【特定技術】需使用 JS 原生語法的 getDate() 撈取時間，不可用套件 【特定技術】需使用 JS 原生語法的 setTimeout() 或 setInterval()，持續讓秒針、分針、時針能夠以台北時區移動 【特定技術】介面請全部用 CSS2、CSS3 手寫繪製，什麼…？你說太強人所難？？那..用圖片也不是不行辣 你攻略此 BOSS 的攻略過程心得 解題時鐘輪廓將時鐘的輪廓刻出來 HTML 123&lt;div class="clock"&gt; &lt;div class="clock__inner"&gt;&lt;/div&gt;&lt;/div&gt; SCSS 12345678910111213141516171819202122232425%centerJustify &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;.clock &#123; width: 350px; height: 350px; border-radius: 100%; @extend %centerJustify; background-color: #a06ee1; box-shadow: 8px 8px 15px #0000007d; &amp;__inner &#123; width: 90%; height: 90%; border-radius: 100%; position: relative; @extend %centerJustify; border: 2px solid #212F0B; background-color: #421b9b; &#125;&#125; 時鐘刻度接著我們需要把刻度做出來，先不管刻度的樣式和大小，我們知道時鐘總共有 60 個刻度，但是這個設計稿有加一些設計在裡面，每個小時的刻度內各多一個菱形的刻度設計，所以總共的刻度有 60+12=72 個。再來我們需要算出每個小刻度佔幾度，一個圓 360 度，除以刻度數量，得一個刻度為 360/72=5。 來寫刻度的 CSS 吧，先設定一個父元素 .scale，裡面會有 72個小刻度 .scale__unit，不過之後我們會使用 JS 迴圈方式來跑 72 次，不會寫死在 HTML 中，所以先寫一個來設定 CSS 樣式即可。 1234567&lt;div class="clock"&gt; &lt;div class="clock__inner"&gt; &lt;div class="scale"&gt; &lt;div class="scale__unit"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718.scale &#123; position: relative; width: 100%; height: 100%; &amp;__unit &#123; transform: rotate(180deg) translateY(120px); // 由於每個刻度的rotate角度不同，這個 CSS 之後會透過 JS 來產生。 width: 2px; height: 24px; border-radius: 100%; position: absolute; top: 50%; left: 50%; transform-origin: 0 0; background-color: #fff; &#125;&#125;` transform-origin上面的程式碼有一個關鍵語法 transform-origin，可以帶入兩個參數( % )，分別代表 X 與 Y ，這個語法可以改變元素transform 的基準點，若沒有特別設定在 CSS 中，預設的基準點為元素的正中心(下圖第一個例子)。可以參考下面兩個連結，會更容易理解。 transform-origin Democlock Demo 時鐘刻度處理及細節跑迴圈產生 72 個刻度 DOM 1234567891011121314151617181920function renderClockUnit() &#123; const unit_wrap = document.querySelector('.scale'); // 父元素 DOM let deg = 180; //刻度的旋轉角度，180度為12時的位置 for (let i = 0; i&lt;72; i++) &#123; const unit = document.createElement('div'); // 創造刻度DOM unit.classList.add('scale__unit'); // 小時的刻度處理 if(i%6 == 0) &#123; unit.style.transform = `rotate($&#123;deg&#125;deg) translateY(110px)`; // 其他刻度處理 &#125; else &#123; unit.style.transform = `rotate($&#123;deg&#125;deg) translateY(120px)`; &#125; deg += 5; unit_wrap.appendChild(unit); &#125;&#125; 小時刻度 &amp; 裝飾刻度樣式 123456789101112131415.scale__unit:nth-child(6n+1) &#123; height: 24px; width: .5px; background-color: #cef9e2;&#125;.scale__unit:nth-child(6n+4)::before &#123; content: '★'; display: block; position: relative; left: -3px; top: -7px; color: #CEF9E2; font-size: 2px;&#125; 到這步，時鐘的刻度算是處理完囉! 製作時鐘上的數字設計稿上有二十四時制及十二時制的時間，我們先宣告兩個變數分別代表它們 12let twelve_hours = 0; // 十二時制let twenty_hours = 12; // 二十四時制 接著，只有在小時刻度時會有數字顯示， 接續上面的程式碼，if 陳述句 i%6 == 0 即代表每小時刻度，我們在該條件成立時需渲染時鐘上的數字。渲染起始點為 12 點的位置，因此當 twelve_hour 跑第一次迴圈時應該為 12，twenty_hours 則為 24，其他情況則帶入變數，且每次迴圈變數都要 +1。 根據上面的代碼，再加入新的功能 123456789 if(i%6 == 0) &#123; unit.innerHTML = ` &lt;span class="twelve"&gt;$&#123; i == 0 ? 12 : twelve_hours &#125;&lt;/span&gt; &lt;span class="twenty"&gt;$&#123; i == 0 ? 24 : twenty_hours &#125;&lt;/span&gt; `; twelve_hours++; twenty_hours++; &#125;&#125; i == 0 ? 12 : twelve_hours 是 JS 的三元運算子，部份情況下可以用簡短的語句取代冗長的 if else ，結構為 [條件] ? [若true回傳此值] : [false則回傳此值]我們可以解釋為，當 i == 0 ( 即第一次迴圈時 )，我要在 .twelve DOM 中輸出 12，其他的情況輸出 twelve_hours 變數當前的值。 CSS 樣式 1234567891011.twelve, .twenty &#123; font-size: 10px; position: absolute; left: -5px;&#125;.twelve &#123; top: -20px;&#125;.twenty &#123; top: 25px;&#125; 到目前我們的時鐘長這樣，好像還差一點點 將時鐘的數字轉正這.. 好像很簡單啊? 把 .twelve 和 .twenty 旋轉 180度好像就可以了 ? 1234.twelve, .twenty &#123; /* ... 略 */ transform: rotate(180deg);&#125; 記得我們剛剛在處理刻度時，每一個小刻度轉了多少度嗎 ? 5度，而每一個小時間隔 6 個小刻度，記得吧? 如果要轉正該怎麼做呢 ? 先將剛剛 .twelve 和 .twenty 的 CSS 刪除，我們用迴圈來產生 CSS，首先一樣迴圈起點為旋轉 180 度。 1let time_deg = 180; 每小時間隔 6 個小刻度，每個小刻度為 5 度，因此一次迴圈需要將角度減去 6*5=30 度。 12345678if(i%6 == 0) &#123; unit.innerHTML = ` &lt;span class="twelve" style="transform:rotate($&#123; time_deg &#125;deg)"&gt; 略... &lt;/span&gt; &lt;span class="twenty" style="transform:rotate($&#123; time_deg &#125;deg)"&gt; 略... &lt;/span&gt; `; time_deg -= 30;&#125; 好的！目前的時鐘長這樣 製作指針指針部分重點和刻度一樣，善用 transform-origin 來改變 transform 基準點即可。詳細製作過程就不在這邊敘述囉~ 請參考 UI 樣板 時鐘邏輯撰寫UI 部分搞定了，接著來讓時鐘跑起來吧！！ 將指針的 DOM 宣告起來 123const hour_hand = document.querySelector('.hand-hour');const min_hand = document.querySelector('.hand-min');const sec_hand = document.querySelector('.hand-sec'); 透過 JS 的 Date 物件抓取時分秒參數 1234const time = new Date();const hour = time.getHours();const min = time.getMinutes();const sec = time.getSeconds(); 再來是最關鍵的，將抓到的參數換算成 CSS 的角度，讓時鐘可以正常運作 秒針sec 變數值的範圍介於 0 ~ 60(秒)，圓為 360度，可以換算得每分鐘的角度為 360/60=6 度。最後需要再扣掉 180度，讓位置以 12 點鐘方向為起點。 1const sec_deg = sec*6 - 180; 分針分針的概念和秒針相似，不過分針另外還會受到秒數的影響，需另外加上 sec*6/60。 1const min_deg = min*6 + sec*6/60 - 180; 時針每小時為 360/12=30度，另外加上分鐘數的影響 min*6/60即可。 1const hour_deg = (hour*30 + min*30/60) - 180; 透過 transform: rotate 為指針 DOM 套用角度 123hour_hand.style.transform = `rotate($&#123; hour_deg &#125;deg)`;min_hand.style.transform = `rotate($&#123; min_deg &#125;deg)`;sec_hand.style.transform = `rotate($&#123; sec_deg &#125;deg)`; setInterval 重複執行將上面整理的邏輯包裝成函式 123456789101112131415161718function clockPrimaryFeature() &#123; const hour_hand = document.querySelector('.hand-hour'); const min_hand = document.querySelector('.hand-min'); const sec_hand = document.querySelector('.hand-sec'); const time = new Date(); const hour = time.getHours(); const min = time.getMinutes(); const sec = time.getSeconds(); const hour_deg = (hour*30 + min*30/60) - 180; const min_deg = min*6 + sec*6/60 - 180; const sec_deg = sec*6 - 180; hour_hand.style.transform = `rotate($&#123; hour_deg &#125;deg)`; min_hand.style.transform = `rotate($&#123; min_deg &#125;deg)`; sec_hand.style.transform = `rotate($&#123; sec_deg &#125;deg)`;&#125; 執行 1234567function runClock(callback)&#123; renderClockUnit(); callback(); setInterval(callback, 1000);&#125;runClock(clockPrimaryFeature); Codepen Demo See the Pen JS地下城 - 2F 時鐘 VanillaJS by Dylan (@Dylan_Liu) on CodePen.]]></content>
      <categories>
        <category>JavaScript</category>
        <category>JS地下城</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS地下城</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 地下城挑戰 - 4F 時區]]></title>
    <url>%2Fjs-4f-timezone.html</url>
    <content type="text"><![CDATA[圖片來源： 六角學院 前言這次闖關除了基本功能之外，試著加入以下一些小功能： 新增及刪除時區 Local Storage 儲存使用者操作資料 多國語系 這些功能主要是使用六角學院JavaScript 學徒試煉 課程作業應用到的一些技巧，因為額外新增了一些小功能，需要多花點時間，有興趣可以參考下面的連結。文末也會提供無額外功能版本的 Codepen Demo 供大家參考。 DemoJavaScript CodeGithub 關卡資訊UI 設計稿 僅能使用原生 JS 開始，不能使用套件 特別注意必須用 JS 處理各國時區 請寫一篇 BLOG 來介紹你的挑戰過程，並介紹 JavaScript 如何提供 GMT、UTC 時區語法，以及何謂 TimeStamp。 每日一字GMT &amp; UTC GMT 為 格林威治標準時間UTC 為 世界協調時間 兩者皆是世界標準時間，但是 UTC 的算法更加嚴謹，不過兩者差異極小，基本上是可以當作相同的。 TimeStampTimeStamp 是指格林威治時間1970年01月01日00時00分00秒起至現在的總秒數。通俗的講，TimeStamp 是一份能夠表示一份數據在一個特定時間點已經存在的完整的可驗證的數據。它的提出主要是為用戶提供一份電子證據， 以證明用戶的某些數據的產生時間。在實際應用上， 它可以使用在包括電子商務、金融活動的各個方面。 在 JavaScript 中取得 TimeStamp 12const dateTime = new Date().getTime();const timestamp = Math.floor(dateTime / 1000); 解題HTML 結構 12345&lt;div id="timeZone"&gt; &lt;h1 class="title"&gt;WORLD CLOCK&lt;/h1&gt; &lt;main class="content"&gt; &lt;/main&gt;&lt;/div&gt; Date.toLocaleString() API首先我們需要先認識它，這個語法是完成這個關的關鍵，詳細用法可以參考以下的文件。 Date.prototype.toLocaleString() toLocaleString 了解一下 基本結構dateObj.toLocaleString([locales [, options]]) locales 為一組字串，可選擇選擇語言環境 options 為一組物件，設定該 API 回傳的日期格式字串，可以設定時區、十二時制或二十四時制..等等。 使用範例只帶入 locales 語言參數，預設為當前環境語言，可以不傳。 1234const date = new Date();date.toLocaleString() // output: "2019/6/19 下午2:15:44"date.toLocaleString('zh-TW'); // output: "2019/6/19 下午2:15:44"date.toLocaleString('en'); // output: "6/19/2019, 2:15:44 PM" 帶入 options 格式參數，可以進一步設置回傳字串的格式，這邊舉這次挑戰所使用到的參數，詳細的參數配置請參考 MDN。 1234567891011const date = new Date();date.toLocaleString('zh-TW', &#123; timeZone: 'Asia/Taipei' // 地區 hour12: false, // 時制 year: 'numeric', month: 'short', day: '2-digit', hour: 'numeric', minute: 'numeric',&#125;);// output: "2019年6月19日 14:35" 開始撰寫程式碼設定地區資料將支援的地區宣告在一個陣列當中 ( 這些字串都是 Date.toLocaleString() 所支援的地區 ) 1let data = ['Europe/London', 'Australia/Sydney', 'Asia/Bangkok', 'America/New_york'] 設定 config 樣板宣告基礎的 Date.toLocaleString() API 需使用的 options 樣板 12345678let config = &#123; hour12: false, year: 'numeric', month: 'short', day: '2-digit', hour: 'numeric', minute: 'numeric',&#125; 將地區資料及 config 合併利用陣列遍歷方法 map 將 data 內的地區值和預設的 config 一一合併，並且使用 Date.toLocaleString() 來產生字串。 關於 map 方法可以參考之前的文章JavaScript陣列處理常用方法 1234let newData = data.map((item) =&gt; &#123; config.timeZone = item; return new Date().toLocaleString('en', config);&#125;) 輸出 newData 陣列 字串處理利用 split方法 處理 newData 的值，把年月日及時分資料拆開，方便之後將資料渲染到畫面上。目前每筆資料是長這個樣子的 &quot;Jun 19, 2019, 08:47&quot;，我們可以利用 split 將字串轉換成陣列 關於 split 方法也可以參考 JavaScript陣列處理常用方法 123let _data = newData.map((item) =&gt; &#123; return item.split(' ');&#125;) 輸出 _data 物件 畫面渲染現在我們得到畫面所需要的時間資訊了，接著將資料渲染到畫面吧！ 12345678910111213141516171819202122const wrapNode = document.querySelector('.content'); // 選取父層 DOM_data.forEach((item, index) =&gt; &#123; const timeZoneParentNode = document.createElement('div'); // 每次迴圈創建一個 div 節點 timeZoneParentNode.classList.add('content__item'); // 為該節點新增 class 樣式 timeZoneParentNode.innerHTML = ` &lt;div class="information"&gt; &lt;div class="information__title"&gt; $&#123;(data[index].replace(/\w+\/(\w+)/g, '$1')).replace(/\_/g, ` `).toUpperCase()&#125; &lt;/div&gt; &lt;div class="information__date"&gt; $&#123;item[1]&#125; $&#123;item[0]&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class="time"&gt; $&#123;item[2]&#125; &lt;/div&gt; ` wrapNode.appendChild(timeZoneParentNode);&#125; ${(data.replace(/\w+\/(\w+)/, &#39;$1&#39;)).replace(/\_/g, &#39; &#39;).toUpperCase()} 這段程式碼是利用正規式將 data 資料內原來的字串做處理，並且回傳新的字串。例如 data[0] 原來是 &#39;Europe/London&#39;，透過正規式我們可以將 / 前的所有字串過濾掉，最後回傳 &#39;London&#39;。關於正規式可以參考文章初探正規式 setInterval 重複執行將程式碼包裝成函式，並加入 while 判斷是否重複渲染。 12345678910111213141516171819202122232425262728293031323334353637function render() &#123; let newData = data.map((item) =&gt; &#123; config.timeZone = item; return new Date().toLocaleString('en', config); &#125;) let _data = newData.map((item) =&gt; &#123; return item.split(','); &#125;) const wrapNode = document.querySelector('.content'); // --------------------- // 刪除子節點，避免重複渲染 while(wrapNode.hasChildNodes()) &#123; wrapNode.removeChild(wrapNode.firstChild); &#125; // --------------------- _data.forEach((item, index) =&gt; &#123; const timeZoneParentNode = document.createElement('div'); timeZoneParentNode.classList.add('content__item'); timeZoneParentNode.innerHTML = ` &lt;div class="information"&gt; &lt;div class="information__title"&gt; $&#123;(data[index].replace(/\w+\/(\w+)/g, '$1')).replace(/\_/g, ` `).toUpperCase()&#125; &lt;/div&gt; &lt;div class="information__date"&gt; $&#123;item[1]&#125; $&#123;item[0]&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class="time"&gt; $&#123;item[2]&#125; &lt;/div&gt; ` wrapNode.appendChild(timeZoneParentNode); &#125;)&#125; 每一分鐘重複執行 12render();setInterval(render, 60000); 基本版 Codepen demo]]></content>
      <categories>
        <category>JavaScript</category>
        <category>JS地下城</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS地下城</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[將 Webpack 專案部屬至 Github Pages]]></title>
    <url>%2Fgit-ghpages-deploy.html</url>
    <content type="text"><![CDATA[npm run build 將專案打包，生成 dist 資料夾 git checkout -b gh-pages 新增分支並且切換到該分支 git add -f dist git commit -m &#39;create project&#39; git subtree push --prefix dist origin gh-pages 部屬]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的 function 及 Pollyfills 整理]]></title>
    <url>%2Fpollyfills.html</url>
    <content type="text"><![CDATA[functions千分位1234function format(num) &#123; num = num + ''; return num.replace(/\B(?=(?:\d&#123;3&#125;)+(?!\d))/g, ',');&#125; pollyfillsArray.prototype.slice()1234567891011121314151617Array.prototype.slicePollyfill = function() &#123; var start = 0, end = this.length if (arguments.length === 1) &#123; start = arguments[0] &#125; else if (arguments.length &gt;= 2) &#123; start = arguments[0] end = arguments[1] &#125; else &#123; return this &#125; var tmp = [] for (var i = start; i &lt; end; i++) &#123; tmp.push(this[i]) &#125; return tmp&#125; Array.prototype.find()Code 1234567Array.prototype.myFind = function(fn)&#123; for(var i = 0; i &lt; this.length; i++) &#123; if (fn(this[i], i)) &#123; return this[i] &#125; &#125;&#125; Usage 123456var arr = ['A', 'B', 'C']arr.myFind(function (item, index) &#123; return item === 'A'&#125;)// output: "A"]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探正規式]]></title>
    <url>%2Flearning-regexp.html</url>
    <content type="text"><![CDATA[圖片來源： 網路 創造一個正規式正規式的基本結構通常以/開頭以/結尾，來寫個簡單的正規式 1var regexp = /xxx/ 還可以用 JavaScript內建的建構子來創建一個正規式 1var regexp = new RegExp('xxx') 用 tpyeof來檢驗他的型別是什麼 12typeof regexp // output: "object" 可以發現他是物件，JavaScript很多東西都是物件型別，包含陣列和函式。 使用正規式來檢驗字串 test()先宣告一組簡單的字串 1var str = 'This is a book' 透過 JavaScript正規式所提供的語法 text來檢驗字串使否符合我們的正規式 1/a/.test(str) // output: true 因為 str 的這個字串內有 a這個字母，因此輸出為 ture。 稍微修改一下 1/z/.test(str) // output: false 由於 str 字串內並沒有 z 字母，所以回傳 false。 使用正規式做字串取代 replace()我們可以透過 replace()方法來做正規式篩選，並取代回傳為 true 的字串內容 1var str = 'This is a book' 將字串內的 ‘is’ 用 ‘xx’ 取代 1str.replace('is', 'xx') // output: "Thxx is a book" 有發現什麼地方怪怪的嗎? 為什麼正規式只取代了 this 中的 is，而忽略的 be動詞 is 呢? 取代多個 剛剛的例子中我們其實並沒有使用到正規式，而是用單純的is 字串做篩選而已，一開始我們就提到，正規式是需要包含 /開頭結尾的。 來修來一下程式碼 1str.replace(/is/, 'xx') // output: "Thxx is a book" Wait Wait Wait! What? 不對欸不對欸，換成了正規式，輸出結果還是沒有變? 使用正規式取得特定字串 match()試著取出 HTML 中 h3 標籤間內的文字 12345678let htmlStr = ` &lt;li&gt; &lt;h3&gt;吳先生&lt;/h3&gt; &lt;p&gt;我覺得這個耳機不好用 &lt;span&gt;2017/11/12&lt;/span&gt; &lt;/p&gt; &lt;/li&gt;` 透過 match 方法做篩選 1htmlStr.match(/&lt;h3&gt;.*?&lt;\/h3&gt;/) 輸出結果 1["&lt;h3&gt;吳先生&lt;/h3&gt;"] 若要取得標籤內文字, 可以透過 () 進行標註 1htmlStr.match(/&lt;h3&gt;(.*?)&lt;\/h3&gt;/) 結果會將 () 符合條件的文字也推入返回的陣列中 1["&lt;h3&gt;吳先生&lt;/h3&gt;", "吳先生"] Demo Regex Flags其實是這樣的，正規式另外有若干的模式可以做設定，常見的三種參數有 i、g、m。 他們分別代表 insensitive、global、multi line。 補充：除了上述三種模式以外，還有另外三種比較進階的，分別是 sticky、unicode、single line，是在 ES6 以後出現的模式。 global 全局匹配 預設模式只會取代字串中第一個符合的對象，後面的會直接忽略。現在我們使用 g 模式，如此一來檢驗的目標中所有符合的對象都會順利被取代。 1str.replace(/is/g, 'xx') // output: "Thxx xx a book" insensitive 忽略大小寫 一般來說在使用正規式是有區分大小寫的，我們直接看下面的例子。 123var str = 'This is a book'str.replace(/this/, 'That') // output: "This is a book" 結果是沒有任何變化的，因為小寫 this和大寫 This是會被判斷為不同的。 修改一下程式碼 123var str = 'This is a book'str.replace(/this/i, 'That') // output: "That is a book" 加入 i參數，可以忽略大小寫，如此一來輸出結果就如我們所預期的囉！ multi line 多行匹配 這個比較難以敘述，直接用程式碼來說明吧～ 1var str = 'iPhone4\niPhone5\niPhone6\niPhone7\niPhone8' 只要在字串內放入 \n 會產生換行的符號，如果這時候來試試看取代會發生什麼事呢? 1str.replace(/iPhone/, 'iPad') 123456// output:"iPad4iPhone5iPhone6iPhone7iPhone8" 和剛才的情況一樣只取代了第一個符合的目標。 诶? 這不是一樣用剛剛學到的 g 就可以解決了嗎 ? 來試試看吧 1str.replace(/iPhone/g, 'iPad') 123456// output:"iPad4iPad5iPad6iPad7iPad8" 確實成功了！ 不過！在實際的情況下可能還有意外的事情會發生！ 1str.replace(/^iPhone/g, 'iPad') 上面的向上箭頭 ^ 是一個正規式很常見符號，簡單說明一下它的意義，它會去匹配字串的開頭。我們來看看 str.replace(/^iPhone/g, &#39;iPad&#39;)的輸出結果。 123456// output:"iPad4iPhone5iPhone6iPhone7iPhone8" 現在，又只修改到第一個符合的目標了！ 怎麼會醬 ? /^iPhone/ 的定義為開頭符合字串iPhone的目標，在沒有使用 m 模式的情況下，即使有換行，他們也不會被視為一個新的開頭，可以想像字串就相當於 &#39;iPhone4iPhone5iPhone6iPhone7iPhone8&#39; 這樣的一大串文字，他們的開頭是 iPhone4中的iPhone字眼。 現在我們來修改一下程式碼 1str.replace(/^iPhone/gm, 'iPad') 輸出結果 12345&quot;iPad4iPad5iPad6iPad7iPad8&quot; 常用情境資料驗證有沒有經驗是當你在註冊某些網站的服務時，當你輸入 E-mail 格式不包含 @ 或是一些 .時，網站會有格是錯誤提示，這是怎麼做到的呢? 123456789101112//please input the test email to see is validvar strEmail = 'xxx1234@gmail.com'; //Regular expression Testingvar emailRule = /^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z]+$/; //validate ok or notif(strEmail.search(emailRule)!= -1)&#123; console.log("true");&#125;else&#123; console.log("false");&#125; 上網搜尋一下正規式 表單驗證其實就很容易找到相關的程式碼了。 由於 E-mail 的格式是固定的，為了避免用戶錯誤輸入，將必定驗證不過的E-mail格式傳到資料庫，消耗不必要的資源，通常在前端我們就會透過正規式的技巧來做簡單的篩選。 搜尋功能相信會看到這篇文章的各位，大部分都有使用文字編輯器。像是筆者使用的文字編輯器是 VS code，我非常常使用到 ctrl + shift + F 的搜尋功能，以往都是使用單純的字串搜尋，但其是現在有非常多的文字編輯器( 或是其他服務 )，都有提供正規式搜尋功能，學會了以後對於資料的篩選精確度會有非常大的提升！ regex101 正規式測試服務這是一個正規式測式的服務，提供正規式的撰寫測試。Regex101 Website 設定程式語言進入網站第一件事情需要先設定程式語言，雖然幾乎所有程式語言都支援正規式，但之中還是有些微差異，有些功能並不是每個程式語言都會支援，但總體來說大概有80%的語法在所有語言都通用。 因為筆者是Web前端開發者，所以這邊我選 JavaScript。 基本功能說明 常用字元字面值如 a b c d 1 2 3 4 等等指定字。 字符類. [abc] [a-z] \d \w \s . 表示任何字符 [abc] 括號表示找到集合裡任意一個字符。 \d 表示一個數字，等同於[0-9] \w 表示一個單詞字符，等同於[0-9A-Za-z_] \s 表示一個空格，tab，回車或一個換行符 [^abc] \D \W \S: 否定字符類，和上述同字母小寫的意義相反 乘法器{4} {3,16} {1,} ? * + {3,16} 表示找到重複3 到16 次內的字元 ? 表示”沒有或出現一次” * 表示”沒有或出現多次” + 表示”一個或出現多次” 分支和組合(Septem|Octo|Novem|Decem)ber 符號 | 表示”或” 圓括號表示組合，比如在一周中找到一天，使用(Mon|Tues|Wednes|Thurs|Fri|Satur|Sun)day。 詞、行和文本邊界 ^ 表示行開始 $ 表示行結束 反向捕獲組比如有一段字符，我們需要前面的橫槓去掉，英文句號換成橫槓，尾巴的數字去掉，但是編號及文章標題需要保留。 12345-1.文章標題1 -2.文章標題2 -3.文章標題3 -4.文章標題4 -51.文章標題5 將上文宣告成一組換行字串 1var str = '-1.文章標題1\n-2.文章標題2\n-3.文章標題3\n-4.文章標題4\n-51.文章標題5' 我們預計要將字串替換成 [編號]-[標題]我們的正規式為 / - (\d+) \. (.+) \d+ / g RegEx 代表意義 - 固定字串 ★ (\d+) 至少一位數的數字(編號)，小括號內的值之後可以用$1輸出 \. 固定字串，由於dot在正規式是有意義的，須以反斜線標記，代表為固定字串. ★ (.+) 至少一個字的任意字元(標題)，小括號內的值之後可以用$2輸出 \d+ 至少一位數的數字 g 全局匹配 而其中$1 $2分別代表正規式中小括號內的字串，他們是由左自右排列的，舉例來說若將 (\d+)的小括號移除，則後面的 (.+)往前遞補，變成 $1的參考值，$2則不存在了。 有時候我們需要括號來作區隔，但是不希望它形成一個群組，意即不希望小括號內的值成為 $的參考值時，我們可以在小括號的前方加上 ?:，就可以把群組取消。如例子中可以將 (\d+)改為(?:\d+)，這麼一來現在的 $1參考到的值是 (.+)，而 $2則不存在了。 使用replace()方法替換內容。 1str.replace(/-(\d+)\.(.+)\d+/g, '$1-$2') 123456// output:&quot;1-文章標題2-文章標題3-文章標題4-文章標題51-文章標題&quot; 空白字元 直接打空白鍵 → space \t → TAB \n → 換行 \r → 回車符 \s* → 所有空白字元 其他預查 正向預查 (?=)有時候我們希望匹配的字串符合某個條件，但不希望該條件也被選取 反向預查 (?!) (?=) &amp; (?!) 和上面補充的 (?:)相同，都不會使小括號內值被群組。 參考資料[偷米騎巴哥]正規式苦手超入門Jark’s Blog - 正則表達式學習正規式語法大全常見正規式範例 - Email 正規式常見正規式範例 - 驗證整數和小數的正則表達式]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>RegEx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 過濾陣列重複值的方法]]></title>
    <url>%2Farray-duplicates-filter.html</url>
    <content type="text"><![CDATA[filter()123456var origin = ['A', 'A', 'B', 'B', 'C', 'C']var result = origin.filter((item, index, arr) =&gt; &#123; return arr.indexOf(item) === index;&#125;)// output: ["A", "B", "C"] 透過 indexOf 方法，從陣列前方開始檢驗，模擬一下迴圈執行過程 1234567891011121314151617// 第一次迴圈arr.indexOf('A') === 0 // true --&gt; result = ['A']// 第二次迴圈，indexOf方法在碰到索引0位置的'A'時就會回傳了，不符合索引1因此這邊不會成立arr.indexOf('A') === 1 // false --&gt; result = ['A']// 第三次迴圈arr.indexOf('B') === 2 // true --&gt; result = ['A', 'B']// 第四次迴圈，indexOf方法在碰到索引2位置的'B'時就會回傳了，不符合索引3因此這邊不會成立arr.indexOf('B') === 3 // false --&gt; result = ['A', 'B']// 第五次迴圈arr.indexOf('C') === 4 // true --&gt; result = ["A", "B", "C"]// 第六次迴圈，indexOf方法在碰到索引4位置的'C'時就會回傳了，不符合索引5因此這邊不會成立arr.indexOf('C') === 5 // false --&gt; result = ["A", "B", "C"] new Set() Set()是 ES6的語法，可以利用他所提供的 has 來做驗證，並用 add 來將驗證後符合的值 push到新的陣列 1var origin = ['A', 'A', 'B', 'B', 'C', 'C'] 方法一 12345var result = new Set()origin.forEach((item) =&gt; &#123; !result.has(item) ? result.add(item) : false&#125;) 方法二 1var result = new Set(origin) 方法一和二結果都是一樣的，這時候印出 result，會發現它並不是我們預期的一般陣列。 12console.log(result)// output: Set(3) &#123;"A", "B", "C"&#125; 利用 ES6的 Spread轉為陣列 12console.log([...result])// output: ["A", "B", "C"] 也可以用 ES6的 Array.form()轉為陣列 12console.log(Array.from(result))// output: ["A", "B", "C"] Object.keys()Object.keys() 可以將物件的屬性取出，並且一個個 push回一個空陣列中。以下做一個簡單範例 1234567var obj = &#123; name: 'Dylan', age: 26&#125;Object.keys(obj)// output: ["name", "age"] 進入主題 12345678910var origin = ['A', 'A', 'B', 'B', 'C', 'C']var result = &#123;&#125;;origin.forEach((item) =&gt; &#123; result[item] = item;&#125;)console.log(result) // output: &#123;A: "A", B: "B", C: "C"&#125;Object.keys(result)// output: ["A", "B", "C"] 資料來源Gua’s Note - JavaScript取出陣列重複/不重複值的方法ES6 Set資料結構]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[認識 XSS 攻擊及防範方案]]></title>
    <url>%2Fxss-attack.html</url>
    <content type="text"><![CDATA[圖片來源： 網路 【網頁安全】給網頁開發新人的 XSS 攻擊 介紹與防範]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 部落格架設流程紀錄]]></title>
    <url>%2Fhexo-blog.html</url>
    <content type="text"><![CDATA[圖片來源： 網路 開始寫學習筆記大概三個月，之前一直使用 github issue 來放文章，它可以支援 markdown 語法，有簡單的分類標籤，不需要架設，登入即用，能滿足最基本的要求，缺點大概是他本來就不是拿來當部落格用的，文章如果多找一些資料蠻不方便的，另外也無法被搜尋引擎找到。 為什麼轉戰 hexo 支援分類、站內搜尋功能 Next 主題會自動幫你生成文章大綱 支援 Markdown 簡單美觀 可以做些客製化 可做 SEO 對我而言，寫筆記主要的用途是幫助自己在未來遇到相同問題時可以很快透過過去的經驗找到解答，在撰寫的過程中透過大量的查找資料，無形中也更加深觀念。Hexo 的分類、標籤、站內搜尋和文章目錄功能都可以幫助我很快的過濾我需要的資訊，這點真的非常方便！網路上 Hexo 的架站教學非常豐富完整，只要照著文章做，30 分鐘就能做出個基本可用的部落格了，後面再花些時間去加入一些你自己想要的功能就可以開始使用了。 需求 Node.js 環境 Git 環境以及基本 Github 使用 基本建置安裝 Node.js 環境如果是沒有使用過 Node.js 的人可能會比較辛苦，需要花點時間學習一下，建議先了解看看基本概念和使用方式。 Node.js 有兩種安裝方式 直接前往Node.js 官網下載 nvm 可以切換管理 node 版本 如果是剛接觸的朋友可以先到官網直接下載來先試試，但未來建議使用 nvm 來安裝， node.js 隨著版本更新會有些版本上的差異，有時這個專案是這個版本，那個專案又是別的版本，會有一些不相容的問題。nvm 只要使用簡單的指令 nvm install :版本號 + nvm use :版本號，就可以自如切換 node 版本。 安裝 Hexo使用 npm 安裝 hexo ( npm 是安裝 node.js 會一併附給你的套件管理工具 ) 1$ npm install hexo-cli -g 安裝成功後，查詢版本 1$ hexo -v 創建部落格初始化 1$ hexo init blog 移動到剛剛創建的資料夾 1$ cd blog 安裝相關套件 1$ npm install 將 Hexo 上傳到 Github 首先先到 Github 新增一個 repository 將 repository 名稱命名為 :你的帳號.github.io， 像我的帳號是 dylan237，那就輸入 1dylan237.github.io 配置 _config.yml檔案路徑./_config.yml，這個檔案是 Hexo 的全域配置文檔，在上面進行 hexo init blog 步驟的時候就會自動生成了。 開啟之後拉到檔案最底部 12deploy: type: 將它修改為 1234deploy: type: git repository: https://github.com/dylan237/dylan237.github.io.git branch: master 這邊以我自己的帳號作範例，帳號部分記得要換成自己的。且注意 : 後一定要有一個空格。 部屬先安裝 Hexo Git 1$ npm install hexo-deployer-git --save 使用 Hexo 的指令編譯你的部落格，並且快速部屬到你的 Github，指令是： 1$ hexo d -g 啟動本機服務 1$ hexo s 接著就可以到 https://dylan237.github.io/ 查看是否部屬成功 Next 主題官方文檔 安裝 12$ cd blog$ git clone https://github.com/iissnan/hexo-theme-next themes/next 配置 開啟站點配置文件，./themes/next/_config.yml 1theme: next 到此，NexT 主題安裝完成。下一步我們將驗證主題是否正確啟用。在切換主題之後、驗證之前，我們最好使用這個語法來清除 Hexo 的緩存。 1hexo clean 主題設定 檔案同樣是 ./themes/next/_config.yml Scheme 的切換通過更改主題配置文件，搜索 scheme 關鍵字。你會看到有三行 scheme 的配置，將你需用啟用的 scheme 前面註釋 # 去除即可。 123#scheme: Muse#scheme: Mistscheme: Pisces 發布及刪除文章創建文章 1$ hexo new :文章名稱 前往 source / _post 資料夾中，打開 :文章名稱.md 文件，在最下面新增 Markdown 語法的內容。 修改完後，執行以下指令 1$ hexo d -g # d = 部署, g = 生成 刪除文章 進入到 source / _post 資料夾中，找到欲刪除文件，在本地直接執行刪除。 執行 12$ hexo clean # 清除快取檔案和已產生的靜態檔案。$ hexo d -g # d = deploy, g = generate 額外功能新增站內搜尋功能參考文章 首先安裝 1$ npm install hexo-generator-searchdb --save 編輯站點配置文件 ./_config.yml 12345search: path: search.xml field: post format: html limit: 10000 編輯主題配置文件 ./themes/next/_config.yml 123# Local searchlocal_search: enable: true 新增分類功能參考文章 首先安裝 1$ hexo new page categories 成功後會提示 1INFO Created: ~/Documents/blog/source/categories/index.md 根據以上路徑找到 index.md文件，打開後會看到預設是 1234---title: categoriesdate: 2017-05-27 13:47:40--- 添加 type: &quot;categories&quot; 到內容中，並存檔 12345---title: categoriesdate: 2017-05-27 13:47:40type: 'categories'--- 開啟 ./themes/next/_config.yml 搜尋，menu 找尋相關配置，將 categories 註解取消 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 之後在 ./source/_post 新增 Markdown 文章都可以添加 categories屬性 注意： hexo 一篇文章只能屬於一個分類，舉例來說如果在 - web前端 下方添加 - JavaScript， hexo 不會產生兩個分類，而是把 - JavaScript 分類歸在 - web前端 分類下。 123456---title: 表單的操作及應用date: 2017-05-26 12:12:57categories: - web前端--- 到這邊，就成功增加分類了，點擊首頁的分類可以看到該分類下的所有文章，只有添加了 categories: xxx的文章才會被收錄到首頁的分類中 新增標籤功能首先安裝 1$ hexo new page tags 成功後會提示 1INFO Created: ~/Documents/blog/source/tags/index.md 根據以上路徑找到 index.md文件，打開後會看到預設是 1234---title: tagsdate: 2017-05-27 13:47:40--- 添加 type: &quot;tags&quot; 到內容中，並存檔 12345---title: tagsdate: 2017-05-27 13:47:40type: 'tags'--- 開啟./themes/next/_config.yml 搜尋，menu 找尋相關配置，將 tags 註解取消 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 之後在 ./source/_post 新增 Markdown 文章可以添加 tags屬性 123456789---title: 表單的操作及應用date: 2017-05-26 12:12:57categories: - web前端tags: - 表格 - 表單驗證--- 作者相關設定大頭照新增一個資料夾來放照片 1$ mkdir source/uploads 將照片丟進資料夾裡，並且設定在設定檔 themes/next/_config.yml設定路徑 1avatar: /uploads/avatar.jpg 作者在根目錄的網站設定 /_config.yml中設定名字、標題和副標題 1234title: &lt;標題&gt;subtitle: &lt;副標題&gt;description: &lt;描述&gt;author: &lt;你的名字&gt; 社群媒體連結在主題設定 themes/next/_config.yml中新增社群網路連結 1234# Social linkssocial: GitHub: #url Twitter: #url About Me Page新建關於我頁面 1$ hexo new page "about" 在 themes/next/_config.yml搜尋 menu 找到相關設定，並且將 about 註解去除 12345menu: home: / archives: /archives tags: /tags about: /about 可以開始編輯關於我頁面囉 source/about/index.md 12345678---title: 關於我date: 2019-05-27 09:57:05---# 關於我大家好，我是 Dylan ....... Disqus 留言功能 先到Disqus註冊服務 選擇 I want to install Disqus on my site 自訂一個 Website Name 回到 themes/next/_config.yml 搜尋 disqus，填入以下資訊 1234disqus: enable: true shortname: #你的Website Name count: true 未來你的所有文章會預設開啟評論功能，如果要關閉可以在該文章表頭設定 1234---...略comments: false--- 文章預設表頭模板打開 ./scaffolds/post.md， 可以設置新文章的模板，在執行 hexo new :文章名 後，新文章會根據該模板添加預設的預設值。 123456---title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories:tags:--- 首頁文章顯示自訂摘要這邊承接上面的模板功能，打開 ./scaffolds/post.md，在下方新增配置 12345678---title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories:tags:---&lt;!-- more --&gt; 從表頭結尾的 ---開始到 &lt;!-- more --&gt;中間可以撰寫該文章的摘要，當瀏覽部落格首頁時，hexo 只會顯示該摘要而不會顯示文章的全文，如此可以讓首頁更加整潔好閱讀。 常用指令整理12345678hexo inithexo cleanhexo generatehexo new post &lt;title&gt;hexo new page tagshexo serverhexo server -p 8000 --debughexo deploy 補充將 Next 自訂配置分離目前升級 NexT 主題的時候並非是非常的流暢。若使用 git pull的方式，很多時候可能會產生衝突;而下載新版本覆蓋安裝的方式又需要手動合併主題的 _config.yml文件。 在此修改之前，NexT 建議將配置分離，一部分在站點的配置文件中，另外一部分在主題的配置文件中。將需要自定的選項放置在站點配置文件中，從而脫離避免更新主題時可能遇到的麻煩這種方式是可行，但是有一些缺點： 配置分離成了兩個部分 用戶可能會疑惑一些選項該放置在哪裡比較合適 為了解決這個問題，NexT 將會使用 Hexo 的 Data 文件。然而由於數據文件是在 Hexo 3 版本時引進的，所以要使用這個特性，需要 Hexo 的版本不低於 3。 若你比較喜歡 Hexo 2.x 版本，可以繼續使用原先的配置方式.NEXT 保持著向下兼容。 優點通過這個特性，你可以將所有的主題配置放置在站點的 source/_data/next.yml文件中。原先放置在站點配置文件中的選項可以遷移到新的位置，同時，主題配置文件可以不用做任何修改。若後續版本有配置相關的改動時，僅需你在 next.yml中做相應調整即可。 如何使用此功能 請先確保你所使用的 Hexo 版本在 3 以上 站點在的 source/_data目錄下新建 next.yml文件（_data 目錄可能需要手動新建） 將 NexT 主題設定檔 _config.yml複製到 next.yml。 參考來源远程仓库无法备份 theme/next 主题的问题Theme configurations using Hexo data filesHexo 博客主题文件夹无法完整 push 及 clone SEO 搜尋引擎優化由於篇幅過長，請直接參考文章 用 Hexo-Github-Pages 搭建個人部落格 Hexo 博客 Next 主题 SEO 优化方法 參考資料Hexo+GitHub，新手也可以快速建立部落格用 Hexo-Github-Pages 搭建個人部落格Hexo 使用攻略-添加分类及标签]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lidemy HTTP Challenge 紀錄]]></title>
    <url>%2Fhttp-game.html</url>
    <content type="text"><![CDATA[圖片來源： https://www.ionos.com/ API文件 3 - 5 關 6 - 10 關 10 - 15 關 第 0 關 - 說明挑戰連結 第0關主要在說明一些遊戲規則，但有一個重點詞 query string ，在串接 API 時時常會使用到的一個技巧，後面也會使用到。 第 1 關 - GET / Query String挑戰連結 這關較為單純，只需要在瀏覽器網址列的 query string 後帶上自己的名字傳入即可。 1https://lidemy-http-challenge.herokuapp.com/lv1?token=&#123;GOGOGO&#125;&amp;name=&apos;dylan&apos; Postman JavaScriptPostman右側的code點進去可以選擇JavaScript原始碼 123456789101112var data = null;var xhr = new XMLHttpRequest();xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("GET", "https://lidemy-http-challenge.herokuapp.com/lv1?token=&#123;GOGOGO&#125;&amp;name=%27dylan%27");xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");xhr.send(data); 第 2 關 - GET / Query String挑戰連結 和第一關一樣用 query string 傳送參數即可。 1https://lidemy-http-challenge.herokuapp.com/lv2?token=&#123;HellOWOrld&#125;&amp;id=56 Postman JavaScript123456789101112var data = null;var xhr = new XMLHttpRequest();xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("GET", "https://lidemy-http-challenge.herokuapp.com/lv2?token=&#123;HellOWOrld&#125;&amp;id=56");xhr.setRequestHeader("content-type", "application/x-www-form-urlencoded");xhr.send(data) 第 3 關 - POST挑戰連結 這關需要使用 POST 來新增書籍資料。 需求 新增書籍的 API 網址為 https://lidemy-http-challenge.herokuapp.com/api 資料的 content type 為 application/x-www-form-urlencoded 格式，這部分需要在撰寫程式碼時加入 request header 當中。 Postman JavaScript1234567891011121314var data = "name=《大腦喜歡這樣學》&amp;ISBN=9789863594475";var xhr = new XMLHttpRequest();xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("POST", "https://lidemy-http-challenge.herokuapp.com/api/books");xhr.setRequestHeader("content-type", "application/x-www-form-urlencoded"); /*!!*/xhr.send(data); 做完第一步伺服器回傳 {&quot;message&quot;:&quot;新增成功&quot;,&quot;id&quot;:&quot;1989&quot;}，接著再把 id 以 query string傳給伺服器就過關了。 1https://lidemy-http-challenge.herokuapp.com/lv3?token=&#123;5566NO1&#125;&amp;id=1989 第 4 關 - Query String過濾資料挑戰連結 需求 API網址為 https://lidemy-http-challenge.herokuapp.com/api/books 查詢書籍的方式為 /books?q=書名 方法為 GET Postman JavaScript1234567891011121314var data = null;var xhr = new XMLHttpRequest();xhr.withCredentials = true;xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("GET", "https://lidemy-http-challenge.herokuapp.com/api/books?q=%E4%B8%96%E7%95%8C");xhr.send(data); 得到 id 後再透過網址列傳送給伺服器即可 1https://lidemy-http-challenge.herokuapp.com/lv4?token=&#123;LEarnHOWtoLeArn&#125;&amp;id=79 第 5 關 - DELETE挑戰連結 這關需要刪除一本書籍資料，此資料的 id 為 23。 需求 刪除的API網址為 https://lidemy-http-challenge.herokuapp.com/api 刪除書籍的方式為 /books/:id 方法為 DELETE Postman JavaScript1234567891011var data = nullvar xhr = new XMLHttpRequest();xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("DELETE", "https://lidemy-http-challenge.herokuapp.com/api/books/23");xhr.send(data) 第 6 關 - 登入驗證挑戰連結此關開始使用新的API (需驗證) 關卡敘述 我終於知道上次哪裡怪怪的了！ 照理來說要進入系統應該要先登入才對，怎麼沒有登入就可以新增刪除…這太奇怪了，我已經回報給那邊的工程師了 這邊是帳號密碼，你先登入試試看吧，可以呼叫一個 /me 的 endpoint，裡面會給你一個 email。把 email 放在 query string 上面帶過來，我看看是不是對的。 帳號：admin密碼：admin123 需求以下 endpoint 都必須經由 HTTP 驗證，驗證方法為傳入 Authorization 的 Header。 首先你必須準備好一組字串，內容為 base64(username:password)舉例來說，如果 username 是 aaa，password 是 123 的話，就會是字串 aaa:123 拿去做 base64 編碼之後得到的結果再把這個結果放到 Header 去，最後變成： Authorization: Basic YWFhOjEyMw==只要帶上這個 Header 就可以驗證身份囉！ （提示：可查詢關鍵字 http basic authorization） 搜索關鍵字 http basic authorization HTTP基本認證 Http Basic Authorization的使用 base64加密為了使用者的安全，通常在進行密碼傳遞時會進行一層加密，http basic authorization是其中一種最簡單的方式，作法是將密碼轉譯為 BASE64 格式，再透過明碼方式傳送，雖然相對容易，但安全性比較低。 我們需要將文件此題所提供的帳號(admin)密碼(admin123)以admin:admin123格式丟入BASE64編碼器中，完成編碼後得到YWRtaW46YWRtaW4xMjM=。 最後組成完整的http basic authorization則會變成Authorization: Basic YWRtaW46YWRtaW4xMjM= Postman API路徑 https://lidemy-http-challenge.herokuapp.com/api/v2/me 夾帶 request header Authorization: Basic YWRtaW46YWRtaW4xMjM= 方法 GET JavaScript12345678910111213var data = null;var xhr = new XMLHttpRequest();xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("GET", "https://lidemy-http-challenge.herokuapp.com/api/v2/me");xhr.setRequestHeader("Authorization", "Basic YWRtaW46YWRtaW4xMjM=");xhr.send(data); 將回傳的 E-mail 放在 query string 上面回傳1https://lidemy-http-challenge.herokuapp.com/lv6?token=&#123;CHICKENCUTLET&#125;&amp;email=lib@lidemy.com 第 7 關 - DELETE挑戰連結 需求 要刪除的書 ID 為 89 方法為 DELETE API路徑 https://lidemy-http-challenge.herokuapp.com/api/v2 endpoint 為 /books/:id 需要包含 http basic authorization 的驗證 request header Postman JavaScript123456789101112var data = null;var xhr = new XMLHttpRequest();xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("DELETE", "https://lidemy-http-challenge.herokuapp.com/api/v2/books/89");xhr.setRequestHeader("Authorization", "Basic YWRtaW46YWRtaW4xMjM=");xhr.send(data); 第 8 關 - PATCH (PUT)挑戰連結 關卡敘述 我昨天在整理書籍的時候發現有一本書的 ISBN 編號跟系統內的對不上，仔細看了一下發現我當時輸入系統時 key 錯了。哎呀，人老了就是這樣，老是會看錯。 那本書的名字裡面有個「我」，作者的名字是四個字，key 錯的 ISBN 最後一碼為 7，只要把最後一碼改成 3 就行了。對了！記得要用新的系統喔，舊的已經完全廢棄不用了。 需求 用 GET方法透過 query string 查詢該書籍 用 PATCH方法修改書籍的 ISBN 資訊 (一樣須帶驗證) Postman JavaScript123456789101112var data = null;var xhr = new XMLHttpRequest();xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("GET", "https://lidemy-http-challenge.herokuapp.com/api/v2/books?q=我");xhr.setRequestHeader("Authorization", "Basic YWRtaW46YWRtaW4xMjM=");xhr.send(data); 123456789101112131415var data = "name=日日好日：茶道教我的幸福15味【電影書腰版】&amp;ISBN=9981835423";var xhr = new XMLHttpRequest();xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("PATCH", "https://lidemy-http-challenge.herokuapp.com/api/v2/books/72");xhr.setRequestHeader("Authorization", "Basic YWRtaW46YWRtaW4xMjM=");xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");xhr.send(data); 第 9 關 - User-agent定義瀏覽器挑戰連結 關卡敘述 API 文件裡面有個獲取系統資訊的 endpoint 你記得嗎？工程師跟我說這個網址不太一樣，用一般的方法是沒辦法成功拿到回傳值的。 想要存取的話要符合兩個條件： 帶上一個 X-Library-Number 的 header，我們圖書館的編號是 20 伺服器會用 user agent 檢查是否是從 IE6 送出的 Request，不是的話會擋掉 順利拿到系統資訊之後應該會有個叫做 version 的欄位，把裡面的值放在 query string 給我吧。 需求 補上對應的 header ,包含登入驗證 偽造IE6的 ` request header Postman JavaScript123456789101112131415var data = null;var xhr = new XMLHttpRequest();xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("GET", "https://lidemy-http-challenge.herokuapp.com/api/v2/sys_info");xhr.setRequestHeader("Authorization", "Basic YWRtaW46YWRtaW4xMjM=");xhr.setRequestHeader("X-Library-Number", "20");xhr.setRequestHeader("User-Agent", "Mozilla/5.0 (Windows; U; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)");xhr.send(data); query string 回傳剛剛得到的 version資訊1https://lidemy-http-challenge.herokuapp.com/lv9?token=&#123;NeuN&#125;&amp;version=1A4938Jl7 第 10 關 - 邏輯遊戲挑戰連結 關卡敘述 出題者會出一個四位數不重複的數字，例如說 9487。你如果猜 9876，我會跟你說 1A2B，1A 代表 9 位置對數字也對，2B 代表 8 跟 7 你猜對了但位置錯了。 開始吧，把你要猜的數字放在 query string 用 num 當作 key 傳給我。 需求這是一個邏輯遊戲，就試吧 如果1個數字對且位置也對就會顯示 1A，兩個的話則顯示 2A，依此類推 若玩家其中一個數字猜對但是位置錯，則會顯示 1B，兩個的話則顯示 2B，依此類推 解答1https://lidemy-http-challenge.herokuapp.com/lv10?token=&#123;duZDsG3tvoA&#125;&amp;num=9613 第 11 關 - Origin 跨域限制挑戰連結 關卡敘述 嘿！很開心看到你願意回來繼續幫忙，這次我們接到一個新的任務，要跟在菲律賓的一個中文圖書館資訊系統做串連這邊是他們的 API 文件，你之後一定會用到：https://gist.github.com/aszx87410/0b0d3cabf32c4e44084fadf5180d0cf4。 現在就讓我們先跟他們打個招呼吧，只是我記得他們的 API 好像會限制一些東西就是了… 需求 從 API 文件參考基本 API 路徑為 https://lidemy-http-challenge.herokuapp.com/api/v3 打招呼的 endpoint 為 /hello 在 request header 內偽造 origin ( 此API有CROS跨域限制，必須來自 lidemy.com 才可存取 ) 方法為 GET Postman JavaScript123456789101112var data = null;var xhr = new XMLHttpRequest();xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("GET", "https://lidemy-http-challenge.herokuapp.com/api/v3/hello");xhr.setRequestHeader("Origin", "lidemy.com");xhr.send(data); 第 12 關 - 使用開發者工具Network觀察回傳的response header資訊挑戰連結 關卡敘述 使用 API 文件提供的方法，獲得藏在其中的 token 需求使用瀏覽器開發者工具的 Network分頁觀察 request ，並於網址列中輸入網址，訪問 API 過程當訪問該 API 後，我們被轉址到其他地方了，順序如下: deliver_token &gt; stopover &gt; deliver_token_result 可以透過 Network 分頁觀察 stopover ，發現 header 內夾帶下一關的 token X-Lv13-Token: {qspyz} 第 13 關 - Proxy代理伺服器挑戰連結 關卡敘述 太好了！自從你上次把運送用的 token 拿回來以後，我們就密切地與菲律賓在交換書籍可是最近碰到了一些小問題，不知道為什麼有時候會傳送失敗我跟他們反映過後，他們叫我們自己去拿 log 來看，你可以幫我去看看嗎？從系統日誌裡面應該可以找到一些端倪。 解題如果直接用 GET 方法，會得到這段伺服器回傳提示： 此 request 不是來自菲律賓，禁止存取系統資訊。 網址後帶入 &amp;hint=13 看看提示 你有聽過代理伺服器 proxy 嗎？ 1. 我們可在 chrome 的設定頁面中搜尋 proxy ，即可開啟設定視窗 2. 上網搜尋 proxy 站點菲律賓proxy 勾選協議是 HTTP 按下搜尋，可以挑選一個速度快的服務。要注意不是每個 proxy 都能正常使用，可能需要多嘗試幾次。 接著在網址列輸入以下，訪問該 API 1https://lidemy-http-challenge.herokuapp.com/api/v3/logs 3. 成功成功可以看到以下畫面，得知下一關 token 為 {SEOisHard} 123[ &#123; logType: &apos;token&apos;, value: &apos;&#123;SEOisHard&#125;&apos; &#125;] 第 14 關 - User-agent定義搜尋引擎挑戰連結 關卡敘述 跟那邊的溝通差不多都搞定了，真是太謝謝你了，關於這方面沒什麼問題了！不過我老大昨天給了我一個任務，他希望我去研究那邊的首頁內容到底是怎麼做的為什麼用 Google 一搜尋關鍵字就可以排在第一頁，真是太不合理了他們的網站明明就什麼都沒有，怎麼會排在那麼前面？難道說他們偷偷動了一些手腳？讓 Google 搜尋引擎看到的內容跟我們看到的不一樣？算了，還是不要瞎猜好了，你幫我們研究一下吧！ 解題網址後帶入 &amp;hint=14 看看提示 伺服器是怎麼辨識是不是 Google 搜尋引擎的？仔細想想之前我們怎麼偽裝自己是 IE6 的。 在第九關我們曾經使用 ` 這個 request header 來偽裝瀏覽器，這題也需要朝這個方向著手。 深入了解 ` 說明與使用](https://ithelp.ithome.com.tw/articles/10209356) 透過`` 伺服器不只可以知道使用者的瀏覽器名稱、瀏覽器版本號，使用者還可以透過他設定要使用哪種搜尋引擎。 各个搜索引擎 Postman JavaScript123456789101112var data = null;var xhr = new XMLHttpRequest();xhr.addEventListener("readystatechange", function () &#123; if (this.readyState === 4) &#123; console.log(this.responseText); &#125;&#125;);xhr.open("GET", "https://lidemy-http-challenge.herokuapp.com/api/v3/index");xhr.setRequestHeader("User-Agent", "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)");xhr.send(data); 第 15 關 這關就沒有題目了，非常感謝 鋰學院 開發這麼有趣的挑戰，對於像我這種菜雞來說非常有幫助XD，透過實際操作，終於開始可以搞懂一些一直很疑惑的概念了。 參考 HTTP-Game攻略(一) HTTP-Game攻略(二)]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[學習 JavaScript 非同步方案：callback / Promise / async await]]></title>
    <url>%2Fjavascript-async.html</url>
    <content type="text"><![CDATA[圖片來源 Codepen Demo Callback Promise + Async Await Async Await 封裝 Axios 參考資料 JavaScript — 對非同步程式的設計方法 使用async await 封装 axios]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>非同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解 HTTP 請求與網頁渲染的背後運作]]></title>
    <url>%2Fhttp-and-webrendering.html</url>
    <content type="text"><![CDATA[概略的基本原理 透過瀏覽器輸入網址 透過網址的 doamin和資訊，與 DNS伺服器取得該網址所對應的 ip及 port號 開始與伺服器建立三項交握 瀏覽器對伺服器發出第一個互動，詢問該伺服器是否存在 伺服器回應 瀏覽器回應: 將開始發送請求 若是HTTPS請求，進行SSL握手 連結到該伺服器後，向伺服器發出第一個 request請求(常見如HTTP或 HTTPS協定)，這個請求通常是該網頁的 HTML文本，此步驟屬於TCP/IP的應用層 伺服器透過 TCP、UDP..等等協定發送封包到瀏覽器，當瀏覽器收到封包後獲得如200 OK..等等的status code，此步驟屬於TCP/IP的傳輸層 瀏覽器開始解析第一個 HTML文本，過程由上向下逐行解析，若有css、js、img等等的需求時，會再向伺服器端發送新的 requst請求 除了持續發送請求，瀏覽器的渲染引擎也持續在渲染 DOM tree(建立網頁 Layout)，並透過伺服器回應的 CSS持續渲染網頁樣式 四次揮手結束瀏覽器與網頁伺服器連線 參考資料六角學院 - 計算機網路直播簡報通訊協議的基本常識 延伸閱讀 [ Summer。桑莫。夏天 ] 在瀏覽器輸入網址並送出後，到底發生了什麼事？ 瀏覽器的渲染原理簡介 瀏覽器的渲染與頁面優化 Understanding Resource Timing]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>網頁渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 陣列處理常用方法]]></title>
    <url>%2Farray-methods.html</url>
    <content type="text"><![CDATA[圖片來源： 網路 push將資料塞入陣列的最後一筆 1234var data = ['A', 'B', 'C']data.push('D')console.log(data) // ['A', 'B', 'C', 'E'] pop將資料最後一筆移除，無參數 1234var data = ['A', 'B', 'C']data.pop()console.log(data) // ['A', 'B'] unshift將資料塞入陣列的第一筆 1234var data = ['B', 'C']data.unshift('A')console.log(data) // ['A', 'B', 'C'] shift將資料第一筆移除，無參數 1234var data = ['A', 'B', 'C']data.shift()console.log(data) // ['B', 'C'] splicesplice 有兩種不同的用法 移除原始陣列特定索引 帶入一個或兩個參數 splice(指定索引, 欲刪除的數量) 起始索引 - 要從哪個索引開始刪除。欲刪除的數量 - 從起始索引開始算往後山幾筆資料，若不帶入則從起始索引開始後的所有資料都刪除。 1234var data = ['A', 'B', 'C', 'D', 'E']data.splice(2, 1) // 從索引2的位置刪除1筆資料console.log(data) // ['A', 'B', 'D', 'E'] 1234var data = ['A', 'B', 'C', 'D', 'E']data.splice(2) // 索引2後的資料全部刪除console.log(data) // ['A', 'B'] 指定從某個索引塞入資料，並且選擇從該索引往後刪除幾筆資料(或不刪除) 必須帶入三個參數 splice(指定索引, 欲刪除的數量, 欲塞入的資料) 1234var data = ['A', 'B', 'C', 'D', 'E']data.splice(2, 0, '塞入資料') // 從索引2的位置，刪除0筆資料，並且在該位置塞入資料。console.log(data) // ['A', 'B', '塞入資料', 'D', 'E'] slice slice 與 splice 很像，slice 取得兩個指定索引間的所有資料，且不會改變原始陣列。 slice( 起始索引[包含], 結束索引[不包含] ) 123456arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']; arr.slice(2, 5);// ["C", "D", "E"]console.log(arr)// ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 原始陣列不變 若只帶第一個參數則是從該參數開始到最後的值都取出 123456arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']; arr.slice(2);// ["C", "D", "E", "F", "G", "H"]console.log(arr)// ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 原始陣列不變 concat可以用來合併兩個陣列 1234arr = ['A', 'B'] arr.concat(['C', 'D', 'E']) // ["A", "B", "C", "D", "E"]console.log(arr) // ['A', 'B'] 原始陣列不變 可以用來複製陣列 12345arr = ['A', 'B'] var arr_copy = arr.concat([])console.log(arr_copy) // ['A', 'B']console.log(arr) // ['A', 'B'] 原始陣列不變 join若把陣列轉換為字串就會以逗號作為一個分隔。 12arr = ['A', 'B', 'C', 'D']console.log(arr.toString()) // A,B,C,D 若要移除逗號或是以別的東西代替逗號，就可以使用 join 123arr = ['A', 'B', 'C', 'D']console.log(arr.join('')) // ABCDconsole.log(arr.join('/')) // A/B/C/D reverse將原始陣列排序相反過來 1234var data = ['A', 'B', 'C', 'D', 'E']data.reverse()console.log(data) // ["E", "D", "C", "B", "A"] sortsort() 方法會原地（in place）對一個陣列的所有元素進行排序，並回傳此陣列。預設的排序順序是根據字串的 Unicode 編碼位置（code points）而定。 不帶入函式123456789var months = ['March', 'Jan', 'Feb', 'Dec'];months.sort();console.log(months);// ["Dec", "Feb", "Jan", "March"]var array1 = [1, 30, 4, 21, 100000];array1.sort();console.log(array1);// [1, 100000, 21, 30, 4] 帶入函式 ( 依數字大小排序 )陣列元素們將根據比較函式之回傳值來排序。如果 a 和 b 為被比較之兩元素，則： 若 compare(a, b) 的回傳值小於 0，則 a 排在 b 前面。 若 compare(a, b) 的回傳值大於 0，則 b 排在 a 前面。 若 compare(a, b) 回傳 0，則 a 與 b 皆不會改變彼此的順序，但會與其他全部的元素比較來排序。 1var arr = [1, 3, 5, 10, 7, 6] 1234567891011arr.sort(function(a, b) &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; // a 必須等於 b return 0;&#125;)// output: [1, 3, 5, 6, 7, 10] 縮寫 升冪 1234arr.sort(function(a, b)&#123; return a - b // output: [1, 3, 5, 6, 7, 10]&#125;) 降冪 1234arr.sort(function(a, b)&#123; return b - a // output: [10, 7, 6, 5, 3, 1]&#125;) 三元運算子縮寫 升冪 1234arr.sort(function(a, b)&#123; return a &gt; b ? 1 : -1 // 翻譯: 如果a&gt;b就回傳-1，不是就回傳1 // output: [1, 3, 5, 6, 7, 10]&#125;) 降冪 1234arr.sort(function(a, b)&#123; return a &lt; b ? 1 : -1 // 翻譯: 如果a&lt;b就回傳-1，不是就回傳1 // output: [10, 7, 6, 5, 3, 1]&#125;) MDN - sort() indexOf用於取的陣列的索引位子，從前面開始找，且找到符合條件的元素後即回傳該元素索引。下面例子雖然後面還有一個 B 符合條件，但因為前面已經找到了，所以不會在往下找。 12arr = ['A', 'B', 'C', 'D', 'E', 'B']arr.indexOf('B') // 1 在陣列內找不到該值則回傳 -1 12arr = ['A', 'B', 'C', 'D', 'E']arr.indexOf('Hi') // -1 運用將兩個陣列不重複的值取出，組成一個新陣列 12var arr = ['A', 'B', 'C', 'D', 'E']var arr2 =['A', 'B'] 解答 123var newArr = arr.filter((item) =&gt; &#123; if (arr2.indexOf(item) == -1) return item&#125;) 12console.log(newArr)// output: ["C", "D", "E"] lastIndexOf跟 indexOf 太一樣的地方是indexOf 只要 一找到資料就會立刻回傳，而 lastIndexOf 會找完全部陣列再回傳最後一筆符合條件的資料索引位子。 12arr = ['A', 'B', 'A', 'D', 'A']arr.lastIndexOf('A') // 4 ====以下例子會使用這個陣列作範例====123456789101112131415161718let data = [ &#123; name: '老媽', money: 2000 &#125;, &#123; name: '老爸', money: 1000 &#125;, &#123; name: '大哥', money: 500 &#125;, &#123; name: '小妹', money: 100 &#125;] 傳統 for123456var len = data.lengthfor(let i=0; i&lt;len; i++) &#123; console.log(data[i]) // 陣列內的物件 console.log(i) // 索引&#125; for in 此篇只有 for in 可用於物件 1234for (let index in data) &#123; console.log(data[index]) // 陣列內的物件 console.log(index) // 索引&#125; forEach forEach 沒在 return 的，所以寫了也沒用。 12345data.forEach(function(item, index, arr) &#123; console.log(item) // 陣列內的物件 console.log(index) // 索引 console.log(arr) //相當於console.log(data) (較不常使用)&#125;) filter filter() 會回傳一個陣列，回傳的是所有判斷為 true 的值，很適合用在搜尋所有符合條件的資料。 123var filterData = data.filter(function(item, index, arr) &#123; return item.money &gt; 600&#125;) find 類似 filter() ，但只回傳陣列中第一個為true的值，適合用在判斷該陣列有沒有任一個符合特定條件目標。 123var findData = data.find(function(item, index, arr) &#123; return item.money &gt; 600&#125;) map 判斷條件為 true 的話，可以 return 自定義內容。 使用 map() 需要 return 一個值，他會透過函式內所回傳的值組合成一個陣列。 回傳的新陣列長度一定會等於該遍歷資料的長度。 如果不回傳任何東西，會形成長度同該遍歷資料的 undefined 陣列。 123var mapData = data.map(function(item, index, arr) &#123; return&#125;) 123var mapData = data.map(function(item, index, arr) &#123; return item.money &gt; 600&#125;) 123456789101112131415161718192021222324var mapData = data.map(function(item, index, arr) &#123; if (item.money &gt; 600) &#123; return &#123; ...item, // ES6 discribtion: '真有錢' &#125; &#125;else &#123; return &#123; ...item, discribtion: '窮' &#125; &#125;&#125;)// ES6以前寫法// var mapData = data.map(function(item, index, arr) &#123;// if (item.money &gt; 600) &#123;// item.discribtion = '真有錢'// return item// &#125;else &#123;// item.discribtion = '窮'// return item// &#125;// &#125;) every 檢查陣列值是否符合條件，這僅會回傳一個值 true 或 false，適合用來檢查陣列中的內容是否全部都符合特定條件。 1234567data.every(function(item, index, arr) &#123; return item.money &gt; 200 // 回傳false，因為小妹只有100塊&#125;)data.every(function(item, index, arr) &#123; return item.money &gt; 10 // 回傳true，所有人都超過100塊&#125;) some 和 every() 類似，但只要一個符合就會回傳 true。 123data.some(function(item, index, arr) &#123; return item.money &gt; 1500 // 回傳true&#125;) reduce prev 參數的值為最後帶入的數字 (此例為0) 下例(1) prev 初始值是0，跑第二次迴圈時 prev的值變成第一次迴圈所 return 的值，依此類推。 123456789/* 加總所有人的錢，reduceData最後結果為3600 */var reduceData = data.reduce(function(prev, item, index, arr) &#123; return prev + item.money // 跑第一次迴圈時值為初始值0，第二次的值為0加上老媽的錢2000，第三次是2000+老爸的錢1000，依此類推。&#125;, 0) // 傳入初始化值為 0 (為prev賦值0)/* 篩選錢最多的，reduceData最後結果為2000 */var reduceData = data.reduce(function(prev, item, index, arr) &#123; return Math.max(prev, item.money) // Math.max() 會回傳帶入的兩個數中較大的數&#125;, 0) reduceRight類似於 reduce ，但 reduceRight的執行順序是由後往前執行。 加總陣列內的數字 如果是加總陣列內的數字，不管是由前往後或是由後往前，結果是看不出差別的。 1var arr = [1, 2, 3, 4, 5]; reduce 1234arr.reduce((prev, item) =&gt; &#123; return prev + item;&#125;)// 15 reduceRight 1234arr.reduceRight((prev, item) =&gt; &#123; return prev + item;&#125;)// 15 組字串 如果是組字串就能看出差異 1var arr = ['1', '2', '3', '4', '5']; reduce 1234arr.reduce((prev, item) =&gt; &#123; return prev + item;&#125;)// "12345" reduceRight 1234arr.reduceRight((prev, item) =&gt; &#123; return prev + item;&#125;)// "54321" findIndex12345678var arr = [5, 12, 8, 130, 44];arr.findIndex(function(item) &#123; return item &gt; 13;&#125;)// 3` 其他預設的陣列行為內的 this 是指向 window (本篇中除了 reduce() 是傳入初始資料)，如果要改，可以在 function 後傳入。 1let newArr = ['A', 'B','C'] 123var newData = data.forEach(function(item, index, arr)&#123; console.log(this) // ['A', 'B','C']&#125;, newArr); // 傳入的物件newArr，替代 this，如果無則是指向 window 參考資料陣列取出重覆與不重複值˙的方法[偷米騎巴哥]操作JS陣列的20種方式[偷米騎巴哥]操作JS陣列的20種方式 - 筆記整理hsiangfeng - 關於JS陣列20種操作的方法]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON Server 環境設定]]></title>
    <url>%2Fjson-server.html</url>
    <content type="text"><![CDATA[圖片來源： 網路 圖片來源： 2017-05-30 (直播錄影) 進擊的前端工程師：今天就自己打造 API 吧！ (高清版) # 教學影片資源 保哥教學 ( JSON Server + Postman Chrome 瀏覽器 API 測試外掛 ) [ Alex 宅幹嘛 ] 👨‍💻 JSON 與 RESTFUL API 串接一次搞定 ( JSON Server + Postman Chrome 瀏覽器 API 測試外掛 + jQuery ) [ Alex 宅幹嘛 ] 👨‍💻Vue 全家桶與 RESTful API 串接入門介紹 (JSON Server + Vue + axios) [ Alex 宅幹嘛 ] 👨‍💻Vue 全家桶與 RESTful API 串接入門介紹 Part 2 【2019/5/3】 基本 AJAX 請求，練習 CRUD下載 JSON servernpm install -g json-server 新增 json 檔案隨意新增一些資料，內容自訂，並存成 .json檔案 用 json server 監控該檔案json-server --watch db.json HTTP 請求基本功能index.html 內撰寫的 JavaScript 來對該資料庫進行CRUD(新增刪除修改) 程式碼 json 1234567891011121314151617181920&#123; "data-base": [ &#123; "id": 1, "name": "Dylan" &#125;, &#123; "id": 2, "name": "Gigi" &#125;, &#123; "id": 3, "name": "Mark" &#125;, &#123; "id": 4, "name": "Ula" &#125; ]&#125; HTML12345678910111213141516&lt;div id="create"&gt; &lt;input type="text" placeholder="name" class="val" /&gt; &lt;a href="javascript:;" class="createBtn"&gt;CREATE&lt;/a&gt;&lt;/div&gt;&lt;div id="delete"&gt; &lt;input type="text" placeholder="id" class="Delval" /&gt; &lt;a href="javascript:;" class="delBtn"&gt;DELETE&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;div id="update"&gt; &lt;input type="text" placeholder="id" class="updateID" /&gt; &lt;input type="text" placeholder="new Name" class="updateName" /&gt; &lt;a href="javascript:;" class="updateBtn"&gt;UPDATE&lt;/a&gt;&lt;/div&gt;&lt;ul id="users"&gt;&lt;/ul&gt; JavaScript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475$(function () &#123; // 取得 $.ajax(&#123; url: 'http://localhost:3000/data-base', method: 'get', dataType: 'json', data: &#123;&#125;, &#125;) .done(function (res) &#123; console.log(res) const container = document.querySelector('#users') res.forEach((item, index) =&gt; &#123; const children = document.createElement('li') children.innerHTML = `$&#123;item.id&#125; / $&#123;item.name&#125;` container.appendChild(children) &#125;) &#125;) .fail(function (err) &#123; console.log(err) &#125;) // 新增 const createBtn = document.querySelector('.createBtn') createBtn.addEventListener( 'click', function () &#123; const name = document.querySelector('.val').value.trim() if (!name) return $.ajax(&#123; url: 'http://localhost:3000/data-base', method: 'post', dataType: 'json', data: &#123; name: name, &#125;, &#125;) &#125;, false ) // 刪除 const delBtn = document.querySelector('.delBtn') delBtn.addEventListener( 'click', function () &#123; const id = document.querySelector('.Delval').value.trim() if (!id) return $.ajax(&#123; url: `http://localhost:3000/data-base/$&#123;id&#125;`, method: 'delete', &#125;) &#125;, false ) // 修改 const updateBtn = document.querySelector('.updateBtn') updateBtn.addEventListener( 'click', function () &#123; const id = document.querySelector('.updateID').value.trim() const NewName = document.querySelector('.updateName').value.trim() if (!id || !NewName) return $.ajax(&#123; url: `http://localhost:3000/data-base/$&#123;id&#125;`, method: 'put', dataType: 'json', data: &#123; name: NewName, &#125;, &#125;) &#125;, false )&#125;)]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 JavaScript 和 CSS 限制內容字數]]></title>
    <url>%2Fellipsis.html</url>
    <content type="text"><![CDATA[CSS限定單行顯示，只要在元素加上以下css即可1234567display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap; 可以指定行數12345678910111213display:-webkit-box;overflow:hidden:text-overflow:ellipsis;-webkit-line-clamp: N; // 想顯示的行數 lines you want to display-webkit-box-orient: vertical;line-height: n; //解決firefox不支援-webkit-line-clamp的問題max-height: n*N; //解決firefox不支援-webkit-line-clamp的問題 JQuery12345678910$(function()&#123; var len = 10; $(".JQellipsis").each(function(i)&#123; if($(this).text().length&gt;len)&#123; $(this).attr("title",$(this).text()); var text=$(this).text().substring(0,len-1)+"..."; $(this).text(text); &#125; &#125;);&#125;); JavaScript12345678const len = 9;const ellipsis = document.querySelectorAll('.ellipsis');ellipsis.forEach((item) =&gt; &#123; if(item.innerHTML.length &gt; len) &#123; let txt = item.innerHTML.substring(0, len) + '...'; item.innerHTML = txt; &#125;&#125;) 參考資料[CSS] 限制行數字數的兩個方法https://www.astralweb.com.tw/css-ellipsis/]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue CLI3 安裝與設定]]></title>
    <url>%2Fvue-cli3.html</url>
    <content type="text"><![CDATA[Vue CLI3 可以快速建立以 Webpack 為基礎的 Vue 單頁式應用開發環境，並且可以透過手動新增 vue.config.js 來變更 Vue CLI3 環境的預設設定。 安裝1npm install -g @vue/cli 查看版本1vue --version 創建專案1vue create :[專案資料夾名稱] 細節設定選擇手動設定或預設設定123? Please pick a preset: default (babel, eslint)❯ Manually select features 手動選取功能這些功能是開發者較常用的，若不在這邊做設定，也可以之後透過 npm 來安裝。 12345678910? Check the features needed for your project: ◉ Babel ◯ TypeScript ◯ Progressive Web App (PWA) Support ◉ Router ◉ Vuex❯◉ CSS Pre-processors ◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing Vue Router 模式設定Vue Router 的 mode， 可選擇 history 或是 hash (預設模式)，hash 預設模式會在 URL 加上 # 符號，由前端來執行虛擬路由。 1? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) Y 若之後需要更改可以到 Vue CLI3 生成的 router.js 內修改。 123456export default new Router(&#123; mode: 'history', routes: [ //..略 ]&#125;) CSS 預處理器若是 SCSS 使用者，可以選擇 Sass/SCSS (with node-sass)。 12345? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS (with dart-sass)❯ Sass/SCSS (with node-sass) Less Stylus ESLint 協助讓你寫的程式符合規範的輔助工具，區分嚴謹程度12345? Pick a linter / formatter config: ESLint with error prevention only ESLint + Airbnb config❯ ESLint + Standard config ESLint + Prettier 程式碼檢查時機1234567891011? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)❯◉ Lint on save # 存檔時 ◯ Lint and fix on commit (requires Git) # 提交更新時# 在哪為特性進行配置? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys)❯ In dedicated config files In package.json# 是否將上述配置儲存到 preset 的 default (就是一開始那)? Save this as a preset for future projects? (y/N) N 進入專案資料夾1cd :[專案資料夾名稱] 開啟服務1npm run serve 發佈1npm run build vue.config.js 配置vue.config.js 是一個可選的配置檔案 (必須自行新增)，如果專案項目的根目錄中 (和 package.json 同層目錄)，它會自動被 @vue/cli-service 加載，並改變 Vue CLI 的預設行為。 參考官方文件]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 字串模板]]></title>
    <url>%2Ftemplate-literals.html</url>
    <content type="text"><![CDATA[先宣告等等會用到的陣列 12345const team = [ &#123;name: '鳴人'&#125;, &#123;name: '佐助'&#125;, &#123;name: '小櫻'&#125;] 傳統組字串123456let str = '我叫做' + team[0].namelet UL = '&lt;ul&gt;\ &lt;li&gt;我叫做' + team[0].name + '&lt;/li&gt;\ &lt;li&gt;我叫做' + team[1].name + '&lt;/li&gt;\ &lt;li&gt;我叫做' + team[2].name + '&lt;/li&gt;\&lt;/ul&gt;' ES6 字串模板12345678let str = `我叫做 $&#123;team[0].name&#125;`let UL = `&lt;ul&gt; &lt;li&gt;我叫做 $&#123;team[0].name&#125;&lt;/li&gt; &lt;li&gt;我叫做 $&#123;team[1].name&#125;&lt;/li&gt; &lt;li&gt;我叫做 $&#123;team[2].name&#125;&lt;/li&gt;&lt;/ul&gt;` 進階 - 在${}內插入JS原始碼12345let newUL = `&lt;ul&gt; $&#123; team.map(item =&gt; `&lt;li&gt;我叫做 $&#123;item.name&#125;&lt;/li&gt;`) &#125;&lt;/ul&gt;` 這邊會有一個小問題，因為map回傳的會是陣列，我們試試在 console 執行下列程式碼。 1team.map(item =&gt; `&lt;li&gt;我叫做 $&#123;item.name&#125;&lt;/li&gt;`) 結果會回傳： 檢查 newUL： 如果輸出在 DOM 上會導致畫面出現多兩個逗號，這邊需要加上 join(&#39;&#39;) 將陣列轉成字串，並且透過(&#39;&#39;)過濾掉逗號。 12345let newUL = `&lt;ul&gt; $&#123; team.map(item =&gt; `&lt;li&gt;我叫做 $&#123;item.name&#125;&lt;/li&gt;`).join('') &#125;&lt;/ul&gt;` 結果：]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 學習箭頭函式]]></title>
    <url>%2Farrow-function.html</url>
    <content type="text"><![CDATA[箭頭函式基本架構1234567891011// 正常結構;([param], [param]) =&gt; &#123; statements&#125;// 縮寫結構param =&gt; expression// param(parameter) 參數// statements 陳述句// expression 表達式 延伸閱讀：重讀 Axel 的 Javascript 中的 Expression vs Statement 一文 傳統函式與箭頭函式寫法差異12345678// 傳統函式var callSomeoneToEat = function(someone) &#123; return someone + '，吃飯了!'&#125;// 箭頭函式 - 省略function字眼，在小括號後加上=&gt;var callSomeoneToEat = someone =&gt; &#123; return someone + '，吃飯了!'&#125; 箭頭函式 - 縮寫 只可用在 function code 只有一行的情況。 1234567// 1. "省略大括號 + return"。// 注意:省略了程式還是會自動return。var callSomeoneToEat = someone =&gt; someone + '，吃飯了!'// 2. 可以再省略"小括號"。// 注意:如果`沒有傳入參數`或有`兩個以上參數`,都不能省略小括號。var callSomeoneToEat = someone =&gt; someone + '，吃飯了!' 註：雖然很多情況可以省略圓括號()，但建議你一律都用圓括號框起來。(Google 5.5.3, eslint: arrow-parens) 補充 123456// 若返回值或參數有包含&#123;&#125;，像是物件內容，需要在外圍加上括號()var foo = () =&gt; (&#123; x: 10, y: 20 &#125;)var foo = (&#123; x, y &#125;) =&gt; x + y// 非常適合簡化回調函數 (callback function)arr.map(num =&gt; num * 10) // arr.map((num) =&gt; &#123; return num * 10)&#125; 箭頭函式沒有 Arguments 物件傳統函式傳統函式在執行環境被創造的時候，JavaScript 引擎會自動生成一個 arguments 物件。 12345const foo = function() &#123; console.log(arguments)&#125;foo(10, 20, 30, 40, 50) 箭頭函式ES6 的箭頭函式不會產生Arguments類物件，若要取用參數，需要利用Spread - 展開與其餘參數這篇所提到的其餘參數方法來代替。 123456// 錯誤示範const foo = () =&gt; &#123; console.log(arguments) // Uncaught ReferenceError: arguments is not defined&#125;foo(10, 20, 30, 40, 50) 123456// ES6其餘參數const foo = (...arg) =&gt; &#123; console.log(arg) // Array [10, 20, 30, 40, 50]&#125;foo(10, 20, 30, 40, 50) This 綁定差異參考資料 【參考】Vue 出一個電商網站 - This 綁定差異 【卡斯伯】鐵人賽：JavaScript 的 this 到底是誰？ Day 06: ES6 篇 - Arrow Function(箭頭函式) 傳統函式 箭頭函式 this值是動態的，由呼叫這個函式的物件(Owner)決定 this是由箭頭函式本身所在的詞彙環境所決定，也就是他所在的函式作用域(function scope)的this就是他的this，其他塊級作用域(block scope/if、for..等的)不會影響他的this 在 ES6 之後，JS 引進了一種新式的設計，稱為 Lexical this(詞彙環境的 this)，下面簡單的說明一下。 以傳統函式而言，在 JS 中的預設 this 值，就是呼叫這個函式的物件，例如是 obj.method()，除非 method 是一個綁定方法(一般指 bind 這個方法)，不然 this 預設就是 obj。 箭頭函式的預設 this 就是用 Lexical this(詞彙環境的 this)，它雖然是函式，但它不像傳統函式的設計，在被呼叫時以呼叫它的物件作為預設 this 值，或是在全域呼叫時以 window 或全域物件作為預設 this (或是嚴格模式下是 undefined )。它不是這樣設計的，它是從詞彙環境(Lexical enviroment)中捕捉 this 值，作為自己的預設 this 值。 ★ 會影響 Lexical this( 詞彙環境的 this )的只有函數的作用域(function scope)，包含函式或全域的作用域。其他的塊級作用域(block scope，例如 if、 for..等等)並不會影響箭頭函式的 this。 上面講了一堆，實際看例子就會很容易理解，這是一個在函式中使用箭頭函式的例子：更多例子 - 箭頭函數的 this 1234567891011const obj = &#123;&#125;function func() &#123; setTimeout(() =&gt; &#123; console.log(this) &#125;, 1000)&#125;func.call(obj) // &#123;obj&#125; - func的this被以call語法指定在obj物件，所以箭頭函式會根據他所在的作用域(func)的this為自己的thisfunc() // window - 這裡func的this指向window，同理箭頭函式也一樣會指向window 在以往這個有名的常見問題中，解決方式有很多種，要不就是要開發者自己作”捕捉”外層函式 this 的動作，或是用 bind 方法自己綁定，下面這是其中一種用”捕捉”外層函式 this 的解決方式： 12345678910const obj = &#123;&#125;function func() &#123; const self = this // 這裡用一個常數self先捕捉到this，讓它到作用域鏈上 setTimeout(function() &#123; console.log(self) &#125;, 1000)&#125;func.call(obj) // &#123;obj&#125; 類似的問題非常多，你可以從 setTimeout 的例子就可以看到，這種用了 callback(回調, 回呼)作為傳入參數的方法，在 JS 中多到一個程度，語法也是很常見，可見在真實的應用情況，如果能像箭頭函式能作週邊的捕抓 this 值，作為自己的預設 this，可以得到多大的方便與減少多少的濳在問題。 當然，箭頭函式的 Lexical this(詞彙的 this)作用在大部的情況都可以運作得很好，但它也有在某些下不適合使用的情況，因為 Lexical this(詞彙的 this)一旦綁定過了，就無法再覆蓋，即使是用 new 關鍵字也不行。不過，這部份可能會比較進階，你可以參考 You Don’t Know JS: this &amp; Object Prototypes 與這篇文章中的內容。也因為如此，有些情況下你不應該使用箭頭函式，在下面的內容中會說明。 不可使用箭頭函式的情況物件中的方法因為箭頭函式會以物件在定義時的捕捉到的週邊 this 為預設 this，下例的箭頭函式並沒有函數包覆，而他只受function scope影響，因此他會離開 obj 物件的 scope，往外找到全域環境，我們都知道在全域環境執行 console.log(this) 會得到 window，這也成為此例箭頭函式捕捉到的 this 參考，所以此例的 this 指向的是 window(或是在嚴格模式的 undefined)。 12345678const obj = &#123; //.. method: () =&gt; &#123; console.log(this) &#125;&#125;obj.method() // window 不可搭配 apply, call, bindthis 在 Arrow function 中是被綁定的(參考周邊函數的 this 的)，所以套用 call 的方法時是無法修改 this 的。 1234567891011let family = &#123; ming: '小明'&#125;const func = () =&gt; &#123; console.log(this)&#125;const func2 = function() &#123; console.log(this)&#125;func.call(family) // 箭頭函式的情況，this 依然是 windowfunc2.call(family) // 一般函示 this 則是傳入的物件 不能當作建構子由於 this 的是在物件下建立，所以箭頭函式不能像 function 一樣作為建構式的函式，如果嘗試使用此方法則會出現錯誤 (... is not a constructor)。 123456var Construcor = () =&gt; &#123; this.name = 'Dylan' this.age = 18&#125;var literal = new Construcor() DOM 事件監聽同先前說的， this 是指向所建立的物件上，如果是用在監聽 DOM 上一樣會指向 window，所以無法使用在此情境。 12345678var el = document.getElementsByTagName('div');var changeDOM = () =&gt; &#123; console.log(this); // 指向 window Object this.style.border = '1px solid red'. // 錯誤&#125;for (var i = 0; i &lt; el.length; i++) &#123; el[i].addEventListener('click', changeDOM, false);&#125; Prototype 中使用 this一樣是 this 的問題，如果原型上新增一個箭頭函式，並嘗試使用 this 的話會指向全域。 123456789101112function construc() &#123; // ...&#125;construc.prototype.fn = function(someone) &#123; console.log(this)&#125;construc.prototype.fn2 = someone =&gt; &#123; console.log(this)&#125;const obj = new construc()obj.fn() // &#123;construc&#125;obj.fn2() // window 資料來源JavaScript 中的 this六角學院 - Vue 出一個電商網站]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 - 縮寫]]></title>
    <url>%2Fshorthand.html</url>
    <content type="text"><![CDATA[先宣告等等會用到的變數 123456const kakashi = '卡卡西'const team = &#123; naruto: '鳴人', sasuke: '佐助', sakura: '小櫻'&#125; 多個物件或值，合併至一個物件。ES5 1234const newTeam = &#123; kakashi: kakashi, team: team &#125; ES6適用在屬性和來源變數名稱一樣的時候 ( kakashi： kakashi, team： team ) 1234const newTeam = &#123; kakashi, team&#125; Vue 常見的縮寫應用12345678910import Vue from 'vue'import App from './App' import router from './router' // 將套件由 './router' 路徑載入，並使用 router 這個變數名稱new Vue(&#123; el: '#app', router, // ES5是 router: router template: '&lt;App/&gt;', components: &#123; App &#125;&#125;); 物件內的函式縮寫ES5 12345const newTeam = &#123; showPosture: function () &#123; console.log('我們是 基紐特戰隊') &#125;&#125; ES6 12345const newTeam = &#123; showPosture() &#123; console.log('我們是 基紐特戰隊') &#125;&#125; 練習將以下物件指向賦予到另一個物件上，並且避免傳參考 123456789101112const team = &#123; naruto: &#123; name: '鳴人' &#125;, sasuke: &#123; name: '佐助' &#125;, sakura: &#123; name: '小櫻' &#125;, // ...&#125; 解答 12345678// ES5const newTeam = &#123; team: team&#125;// ES6縮寫const newTeam = &#123; team&#125; 輸出結果：newTeam的結構多包了一層物件，和原來的team有點不一樣，這不是我們要的結果。 搭配前面章節的展開 ... 使用 123const newTeam = &#123; ...team&#125; 輸出結果結構正確 資料來源六角學院 - Vue出一個電商網站]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 解構與賦值]]></title>
    <url>%2Fdestructuring.html</url>
    <content type="text"><![CDATA[認識解構與賦值 (Destructuring)解構賦值可以簡單先以這張圖做初步認識，簡而言之就是將右邊的值，鏡射到左方的變數，不過要注意這邊的鏡射不會有任何順序或方向的改變。 圖片來源： 六角學院線上課程 陣列傳統上如果我們想將陣列的值取出，賦予給另一個新變數，我們會這麼做。 1234let family = ['Dylan', 'Eva', 'John']let son = family[0]let daugter = family[1]let father = family[2] 在 ES6 的做法中，我們可以用 解構賦值 的方式，使可讀性提高。 123456let family = ['Dylan', 'Eva', 'John']let [son, daughter, father] = familyconsole.log(son) // Dylanconsole.log(daughter) // Evaconsole.log(father) // John 這個例子具象化如下，就像一開始那張 鏡射 的圖片概念一樣，將右邊的值依序對應，賦予給左方的變數。 1let [son, daughter, father] = ['Dylan', 'Eva', 'John'] 如果賦值的對象或者被賦值的變數數量不等，會出錯嗎？ 賦值對象數量較少的情況 123456let family = ['Dylan', 'Eva']let [son, daughter, father] = familyconsole.log(son) // Dylanconsole.log(daughter) // Evaconsole.log(father) // undefined，相當於宣告 let father; 被賦值變數數量較少的情況 123456let family = ['Dylan', 'Eva', 'John']let [son, daughter] = familyconsole.log(son) // Dylanconsole.log(daughter) // Eva//依序排入，不會有影響。 跳過賦值對象內的某的值 12345let family = ['Dylan', 'Eva', 'John']let [son, , father] = family // 想跳過的位置不要宣告變數即可，但注意逗號還是要保留。console.log(son) // Dylanconsole.log(father) // John 字串這邊要做的是拆開字串內的每個字元，並依數量賦予給不同的變數。 1234567let str = '字元拆解';let [A, B, C, D] = str;console.log(A) // 字console.log(B) // 元console.log(C) // 拆console.log(D) // 解 使用解構賦值將兩個變數的值互換ES5要實作兩個變數值互換，需要宣告第三個變數作中繼，但是ES6的解構賦值可以不需要，因為他們的交換時的資料傳遞是同時進行的，如下程式碼。 123let son = 'Dylan';let daughter = 'Eva';[son, daughter] = [daughter, son]; 註：son和daughter變數已經存在，所以不需要在前方做let宣告，這裡只是同步的將兩個變數值做交換 額外補充在查資料時，發現一個很有意思的ES5同步變數值交換方式，當中用到了克服JS奇怪的部分提過的運算子的優先性和相依性的觀念，這部分的觀念要非常清楚，才能真正理解這行程式碼的精隨。 123456let a = 'a';let b = 'b';b = [a, a = b][0]; // 這樣寫也行 a = [b][b = a,0];console.log(a) //bconsole.log(b) //a Stackoverflow討論 物件12345let data = &#123; naruto: '鳴人', sasuke: '佐助', sakura: '小櫻'&#125; 取出物件內的其中一個值，並創造變數賦予該值。等於運算子的相依性是由右至左，這邊從=的右方data開始看。data是目標物件，再來因為我們寫了{naruto}，JS會去等號右邊物件data裡面找到 naruto屬性，並抓取它的值，最後將該值賦予給一個變數naruto。 我們得到了一個新變數 naruto，而它的值則是從 data.naruto 抓取。 123let &#123;naruto&#125; = data;console.log(naruto) // 鳴人 如果變數名稱想要自己取，不想用物件屬性的名稱，可以改嗎？下方程式碼多了一個:，它的右方是自定義的變數名稱，若有撰寫，JS將會把原先該賦予給變數naruto的值，轉而創建一個新變數naruto_uzumaki，並將該值傳遞給它。 如果在 : 右方有定義新變數名稱，則會使用新變數名稱。 12345let &#123;naruto: naruto_uzumaki&#125; = data;console.log(naruto) // Uncaught ReferenceError: naruto is not defined，因為值是被傳入naruto_uzumakiconsole.log(naruto_uzumaki) // 鳴人 延伸題目 - 較複雜的物件解構賦值12345let &#123;naruto: naruto_uzumaki, group: [, sakura]&#125; = &#123;naruto: '鳴人', group: ['佐助', '小櫻', '卡卡西']&#125;// 想想看答案console.log(naruto_uzumaki) console.log(sakura) 這樣寫或許更好懂 123456let data = &#123; naruto: '鳴人', group: ['佐助', '小櫻', '卡卡西']&#125;let &#123;naruto: naruto_uzumaki, group: [, sakura]&#125; = data 設定預設值陣列12345let [A = 'Dylan', B = '將被Eva取代的人', C] = [, 'Eva', 'John']console.log(A) // 沒有傳入參數，以預設值Dylan帶入console.log(B) // 預設值'將被Eva取代的人'被傳入值'Eva'取代console.log(C) // John 物件123456let &#123;naruto: naruto_uzumaki = '漩渦鳴人', sasuke: Uchiha_sasuke&#125; = &#123;sasuke: '佐助'&#125;console.log(naruto_uzumaki) // 漩渦鳴人 - 等號右邊物件沒有naruto屬性，但是在左邊有設定預設值是'漩渦鳴人'。console.log(Uchiha_sasuke) // 佐助 - 等號右邊物件有sasuke屬性，值是'佐助'，所以可以直接參照到值。另外沒有預設值，即使有也會被帶入的值覆蓋。 資料來源六角學院 - Vue出一個電商網站]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 - Spread 展開與其餘參數]]></title>
    <url>%2Fspread.html</url>
    <content type="text"><![CDATA[展開先宣告兩個陣列 12let arr1 = ['A', 'B', 'C']let arr2 = ['D', 'E', 'F'] 合併陣列12345// ES5let arrAll = arr1.concat(arr2) // ["A", "B", "C", "D", "E", "F"]// ES6 展開let arrAll = [...arr1, ...arr2] // ["A", "B", "C", "D", "E", "F"] 複製陣列1234// ES5let copy = arr1.concat() // ['A', 'B', 'C']// ES6 展開let copy = [...arr1] // ['A', 'B', 'C'] 陣列開頭插入陣列(物件)12345// ES5Array.prototype.unshift.apply(arr1, arr2) //arr1現在是 ["D", "E", "F", "A", "B", "C"]// ES6 展開arr1 = [...arr2, ...arr1] //arr1現在是 ["D", "E", "F", "A", "B", "C"] 原理1console.log(...arr1) // A B C 單純印出 ...arr1 會出現陣列內的內容，我們可以理解 ... 這個運算子 的作用是將它後方的陣列值一個個取出來，然後再 push 回去。 類陣列 (array like) 參考：JavaScript 深入之類陣列物件與 arguments 定義：擁有一個 length 屬性 和 若干索引屬性 的 物件。 手動創造一個類陣列以物件實體語法創造一個物件，其成員的屬性皆為索引(數字)，並賦予額外 length 屬性。 123456var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3 &#125; 操作 12345678910111213141516// 讀寫console.log(arrayLike[0]) // namearrayLike[0] = 'new name'//長度console.log(arrayLike.length) // 3//遍歷//1for(var i = 0, len = arrayLike.length; i &lt; len; i++) &#123; console.log(arrayLike[i])&#125;//2 類陣列本身還是屬於物件，因此要使用陣列方法必須這麼做Array.prototype.forEach.call(arrayLike, function(item)&#123; console.log(item)&#125;) Arguments JavaScript 深入之類陣列物件與 arguments 克服JS的奇怪部分 ‘arguments’ 與 spread Arguments 是當函數的執行環境被創造時與 環境變數、this、外部環境一起被 JavaScript 引擎創造出來的物件。他也是一個類陣列，而裡面的屬性是所有被傳入該函數的參數。 12345function foo() &#123; console.log(arguments);&#125;foo('Dylan', 25, 'Eva', 25); 輸出： 可以看到輸出結果產生了類陣列的物件，而__proto__內的方法皆是物件的原生方法。 如果嘗試用 arguments 使用陣列的 push 方法，會跳出錯誤。因為 arguments是物件不是陣列。 12345678function foo() &#123; arguments.push(['John', 40]); // Uncaught TypeError: arguments.push is not a function //補充：如果要取用原生陣列方法要使用 // Array.prototype.push.apply(arguments, ['John', 40])&#125;foo('Dylan', 25, 'Eva', 25); 利用展開將類陣列轉換成陣列，如此也可以順利取用陣列的方法。 12345678function foo() &#123; let arg = [...arguments] arg.push('John', 40) console.log(arg)&#125;foo('Dylan', 25, 'Eva', 25); 結果： querySelectorAll()12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 12let doms = document.querySelectorAll('li')console.log(doms) 可以發現用 querySelectorAll 所產生的變數doms，看起來好像是個陣列，仔細看發現紅框上面寫的是 NodeList 而不是陣列會顯示的 Array，這是一個典型的類陣列例子。 進一步做驗證，打開 __proto__ 看看內部的原生方法，可以很快的發現和我們所知的陣列方法是有出入的，真正的陣列方法並沒有這麼少。 而陣列方法 concat 在 doms.__proto__ 也找不到，如果試著對 doms 使用這個方法的話，不意外的跳錯了。 如果類陣列就是很任性的想使用陣列的方法，可以嗎?假設變數 arrayLike是一個類陣列 ES6先轉為陣列，之後可以合理使用陣列方法了。 1234//1[...arrayLike]//2Array.from(arrayLike) ES5使用call、apply、bind，呼叫陣列的方法。 123456//1Array.prototype.concat.apply([], arrayLike) //指向一個空陣列，將doms連接進去。//2Array.prototype.slice.call(arrayLike)//3Array.prototype.splice.call(arrayLike, 0) //不適用於querySelectorAll產生的NodeList類陣列 輸出： 看看它的 __proto__，可以發現他已經有所有陣列該有的原生方法了，現在就可以直接取用這些方法，不需要再使用call、apply、bind，也可以證明它已經變成一個真正的陣列了。 其餘在克服JS奇怪部分 4-39最後提到的Speard，就是指展開與其餘，當時影片錄製時，ES6功能還不夠完整，講師提到未來這個功能如果完善了，將可以取代 Arguments，下面來看看如何使用吧。 12345function foo(...people) &#123; // 自定義陣列名稱 (裡面包含傳入的參數) console.log(people) // 透過自定義名稱，可以取用一個包含所有參數的陣列&#125;foo('Dylan', 25, 'Eva', 25) 結果可以發現不同於 Arguments，其餘參數所創造的陣列是純粹的陣列而不是偽陣列： 另外如果還有其他參數並不想加入其餘參數陣列當中，我們可以 1234567function foo(area, road, ...people) &#123; // 自定義陣列名稱 (裡面包含傳入的參數) console.log(area) console.log(road) console.log(people)&#125;foo('台北市', '羅斯福路', 'Dylan', 25, 'Eva', 25) 結果可以發現若有額外設計參數，一樣會一一對應並帶入，而剩餘的參數將直接被放入其餘參數的陣列當中。 注意：其餘參數一定要在最後，且只能有一個 資料來源六角學院 - Vue出一個電商網站]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 let & const]]></title>
    <url>%2Flet-and-const.html</url>
    <content type="text"><![CDATA[特性var在 JavaScript Understanding The Wired Parts 課程中，有提到JS的 hoisting 特性，當語法解析器在解析程式碼時，他會把我們所宣告的變數都設置在一個記憶體位置，並先以 undefined 當作值儲存到記憶體當中，之後開始逐行讀取程式碼，當讀到了 var A = &#39;xxx&#39; 的時候，再將 xxx 字串取代 undefined 賦值給 A 變數。 所以在 var A = &#39;xxx&#39; 這行程式碼前印出 A 時，它還是 undefined，讀取到了以後才賦值變成 xxx。 123console.log(A) // undefinedvar A = 'xxx'console.log(A) // xxx let 與 constES6的 let和 const 無法在宣告前無法取用該值，否則會跳出 is not defined錯誤。 12console.log(A) // Uncaught ReferenceError: A is not definedlet A = 'xxx' 作用域var var的作用域為 Function Scope 只能以函式為變數作用域的分界，在一些使用了區塊語句(用花括號的語句)的像 if, else, for, while 等等區塊語句中，在這裡面用 var 宣告的變數仍然是會曝露到全域之中可被存取。 12345678910function test()&#123; var a = 10&#125;if(true)&#123; var b = 20&#125;console.log(a) // a is not defined 存取不到console.log(b) // 20 存取得到 這對初學者容易造成誤解外，如果再搭配到隱藏的提升特性，整個程式碼經常會有出人意表的結果。在許多撰寫風格指引通常會提醒這點，而且叫你一定要把 var 語句寫在程式碼檔案的最上面。(甚至連 for 語句中的 var 宣告也要寫到最上面) let 與 const var的作用域為 Block Scope 如果使用了 let 或 const 來宣告，則是以區塊語句為分界的作用域，它會比較明確而且不易發生錯誤。一些之前對於 var 語句的麻煩撰寫風格，就可以不需要了。 123456789101112131415function test() &#123; let a = 10 const a2 = 10&#125;if (true) &#123; let b = 20 const b2 = 20&#125;console.log(a) // a is not defined 存取不到console.log(b) // b is not defined 存取不到，b被限制在if的&#123;&#125;中，外部環境無法存取console.log(a2) // a2 is not definedconsole.log(b2) // b2 is not defined 總之，不要再用 var 了，用 let 或 const 來取代它就是了。像我們有使用的 ESLint 檢查工具，一定出現會叫你不要使用 var 的訊息。 const 定義常數const 針對是常數的定義，常數在一宣告時就必定要指定給值，不然會產生錯誤。而對於常數在 ES6 的定義是： 不可再指定 can’t re-assignment 指定的意思就是用等號 = 作指定運算，像下面這例子就是再指定值(或重覆指定值)，所以會產生錯誤： 12const a = 10a = 20 // TypeError: Assignment to constant variable. 錯誤 宣告了一個常數，代表這個識別名稱的參照 reference是唯讀的 read-only，並不代表這個參照指定到的值是不可改變的 immutable。意思是如果你宣告的常數是一個物件或陣列類型，裡面的值是可以作改變的。 12345const a = []a[0] = 1const b = &#123;&#125;b.foo = 123 所以對於物件、陣列、函式來說，使用const常數來宣告就可以，除非你有需要再指定這個陣列或物件的參照。 let使用於for語句for 圓括號中的 let 變數仍然是在區塊作用域for圓括號中的第一個表達式，用 let宣告變數時，是不是也會是被限制到 for 語句的區塊作用域中？答案是肯定的，見下面的例子： 12345678for (let i = 0; i &lt; 2; i++) &#123; console.log('in for statement: i', i) // in for statement: i 0 // in for statement: i 1 // ( i變數被限制在for的"block scope"中，所以可以正常印出 )&#125;console.log(i) // ReferenceError: i is not defined ( 全域則存取不到 ) for 迴圈中的 let 變數會作重新綁定參考文章 這是 let的特別之處，是由於區塊作用域造成的結果，在每次的 for迴圈執行時，用 let 宣告的變數都會重新綁定 re-bind一次。這是在 for 語句中 var 與 let 的差異。 以下用程式碼直接看會比較容易的理解。這個改進主要是為了要解決在 for 語句中的閉包結構的問題。 使用 var123for (var i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; console.log(i), 1000) &#125; JS中setTimeout屬於非同步函式，當JS引擎看到setTimeout時並不會等待一秒，而是先將它放入event queue等待執行，並且持續執行程式碼，也就是繼續執行第2、3、4…次for迴圈。此例總共迴圈了十次，所以event queue裡等待被執行的console.log(i)有十個，然而當for迴圈跑完時，i已經透過九次i++變成了10，因此累積的十次console.log(i)依序執行後參照到的 i 將都會是10，所以輸出的結果為十個10，而非我們預期的0~9。 使用 let123for (let i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; console.log(i), 1000) &#125; 如果你使用了 let 而不是 var，let 的變數除了作用域是在 for的{}區塊中，而且會為每次循環執行建立新的詞彙環境(LexicalEnvironment)，拷貝所有的變量名稱與值到下個循環執行，因此event queue裡的十次console.log(i)將會各自參考到不同的 i 變數，輸出預期的0~9。 模擬情況 12345let k;for (k = 0; k &lt; 10; k++) &#123; let i = k //注意這裡，每次循環都會建立一個新的i變數 setTimeout(() =&gt; console.log(i), 1000)&#125; let的陷阱 - Hoisting 和 臨時死區(TDZ)要理解 let, const是否會被提升，可以用下面的簡單例子來看。第一個例子，是正常可以輸出 a 變數的值 12345let a = 1;(function() &#123; console.log(a); // 1&#125;)() 然而如果 let 不會提升，那麼這裡的 console.log(a) 應該還是會印出全域的 1，但是執行時發現報錯，這是因為函數中 let a = 2宣告的變數被提升到函數中區塊的最上面，進而產生TDZ，因此造成錯誤。 123456let a = 1;(function() &#123; console.log(a); // Uncaught ReferenceError: a is not defined let a = 2;&#125;)() 對於TDZ，可以大概理解成這樣： 1234567let a = 1;(function() &#123; // 這裡產生 TDZ for a console.log(a); // TDZ期間取用變數，產生Uncaught ReferenceError: a is not defined錯誤 let a = 2; // 對a的宣告語句，這裡結束 TDZ for a&#125;)() 在例子中的 IIFE 裡的函數作用域，變數 a 在作用域中會先被提升到函數區域中的最上面，但這時會產生TDZ，如果在程序流程還未運行到 a 的宣告語句時，算是在TDZ作用的期間，這時候取用 a 的值，就會拋出ReferenceError錯誤。 結論 let 和 var 都有hoisting let 有TDZ，var 沒有TDZ 不過說句實在話，let 有沒有 hoisting 都無所謂，程式還是那樣寫，因為即使是古早的var我們也知道必須先宣告後使用，只要把握這個原則就沒問題了。 參考文章 TDZ 參考內容1 TDZ 參考內容2 撰寫風格建議 不要再用 var 來宣告變數，改用 let 與 const，而且優先使用 const，除非需要再指定值才用 let。 var 的部份不要再用的理由，上面的內文已經有說明。const 可以用在物件、陣列與函式上，常數一宣告時就要指定值，犯錯的機會會減少很多。另外，JS 引擎也可以作最佳化。所以大概9成的情況都是用 const，只有像 for 迴圈語句或一些需要再指定值的情況才會用到 let。 並不是在區塊中或函式中區域的最上面來宣告變數/常數，而是在合理的位置，在變數/常數首次被使用時的上面一行來宣告變數。現在的編譯器與 JS 引擎都已經做得很好，而且 let 與 const 都是區塊作用域，不用再擔心常數/變數會曝露到全域中的問題，提升特性如果你已經學過知道了，不要亂用也很難遇到。總之變數/常數在要用到前再宣告就行了，這是所謂的”合理的位置”。這會與 Douglas Crockford 大師所提的，一定要宣告在函式或程式檔案的最上面，這個撰寫風格的說法會不太一樣，不過當年也只有 var 可用，大師的想法自然有他的道理，但現在有了 let 與 const 就不用這樣做了。 重點歸納 若未使用var 、let、 const宣告，會使變數成為全域變數。 ES6後，鼓勵使用 let、const 取代 var。 let 在 for 迴圈時，每次循環都會重新綁定。 let 與 const 都是區塊作用域 ( block scope )，而 var 是函式作用域( function scope ) 資料來源eyesofkids - Day 05: ES6篇 - let與const六角學院 - Vue出一個電商網站]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[實作一個 JavaScript 迷你框架 (三)]]></title>
    <url>%2Fbuild-a-js-framework-3.html</url>
    <content type="text"><![CDATA[前言這篇應該就是JavaScript 全攻略：克服 JS 的奇怪部分的最後一篇筆記了(灑花) ，如果要學好 JS這堂課真的是扎穩馬步的好課，一開始或許會覺得有點艱澀，不過比起一些書籍來說，算是對新手相對友善了的～如果影片真的有聽不懂的地方，可以google搜尋一些前輩的筆記來閱讀，會很有幫助的！ 關於克服JS的奇怪部分筆記，特別推薦 PJChender和 SimonAllen這兩位大大的筆記，寫得非常清楚易懂，有些看影片還不能理解的地方，看了他們寫的筆記很快就能通了 :thumbsup: 好，到前一篇為止，我們完成的需求有： 是一個可重複使用的 library/framework，也就是說，每一個安裝此 framework 的人可以直接使用，不會和它原本程式碼有所衝突。 和 jQuery 只需要輸入 “$( )” 一樣，我們可以使用 “G$( )” 來建立物件。 當我們告訴它我們的姓（lastname）名（firstname）還有選擇的語言（language）時，它可以用正式（formal）和非正式（informal）的方式和我們打招呼。 支援英文（English）和中文（Chinese）兩種語言。 只剩下最後一個需求囉： 支援 jQuery ，可以把 greetr 產生的訊息直接顯示於HTML中。 HTML 我們首先先來寫一些HTML，做出一個簡易的畫面。內容有下拉選單提供語言選擇，還有一個按鈕。 12345678910111213141516&lt;body&gt; &lt;div class="logdiv"&gt; &lt;select id="lang"&gt; &lt;option value="en"&gt;English&lt;/option&gt; &lt;option value="ch"&gt;中文&lt;/option&gt; &lt;/select&gt; &lt;input type="button" value="login" id="login" /&gt; &lt;/div&gt; &lt;h1 id="logMsg"&gt;&lt;/h1&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt; &lt;script src="greetr.js"&gt;&lt;/script&gt; &lt;script src="app.js"&gt;&lt;/script&gt;&lt;/body&gt; 新增方法 - 連動 jQuery 選擇器現在要來新增一個方法，具體功能如下 可以傳入參數(如 #btn)，配合 jQuery 提供使用者選取DOM的功能。 檢驗環境是否有 jQuery，如果沒有利用throw 丟出錯誤訊息。 檢驗是否有傳入DOM選擇對象，如果沒有用 throw 丟出錯誤訊息。 可以傳入參數，讓使用者選擇用正式或非正式，方法打招呼。 將打招呼的結果，呈現在畫面上，畫面指的即使用者傳入的選擇器對象中。 支援鏈式。 1234567891011121314151617181920HTMLGreeting: function(selector, formal) &#123; if (!$) &#123; throw 'not found jQuery'; &#125; if (!selector) &#123; throw 'Missing jQuery selector'; &#125; var msg; if (formal) &#123; msg = this.formalGreetings(); &#125;else &#123; msg = this.greeting(); &#125; $(selector).html(msg); return this;&#125; 基本上就是前一篇的一些方法綜合起來的應用，記得一樣要放在 Greetr.prototype 中。 實際來使用框架現在要配合剛剛簡易的畫面來使用 HTMLGreeting 這個方法。 123456$('#login').on('click',function()&#123; var person = G$('Dylan', 'Liu'); var lang = $('#lang').val; person.setLang(lang).HTMLGreeting('#logMsg', true);&#125;); 點選語言再按下 login ，畫面就呈現囉。 Codepen Demo 資料來源 JavaScript 全攻略：克服JS的奇怪部分 9-77、78、79 PJChender - 親手打造屬於你自己的 JavaScript Framework/Library（下）]]></content>
      <categories>
        <category>JavaScript</category>
        <category>克服JS的奇怪部分</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>克服JS的奇怪部分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[實作一個 JavaScript 迷你框架 (二)]]></title>
    <url>%2Fbuild-a-js-framework-2.html</url>
    <content type="text"><![CDATA[前言前一篇筆記，我們完成的需求有： 是一個可重複使用的 library/framework，也就是說，每一個安裝此 framework 的人可以直接使用，不會和它原本程式碼有所衝突。 和 jQuery 只需要輸入 $( ) 一樣，我們可以使用 G$() 來建立物件。 剩下的需求有： 當我們告訴它我們的姓（lastname）名（firstname）還有選擇的語言（language）時，它可以用正式（formal）和非正式（informal）的方式和我們打招呼。 支援英文（English）和中文（Chinese）兩種語言。 支援 jQuery，可以把 greetr 產生的訊息直接顯示於HTML中。 新增一些變數 &amp; 方法建立全域環境無法取用的變數在開始建立方法（method）前，我想要先建立一些變數是我之後可以在方法中使用的，但這些變數又不會和外層的 global environment 有所衝突也不能被外層所取用，要如何達到呢？ 參考：[筆記] JavaScript中Scope Chain和outer environment的概念[筆記] 談談JavaScript中closure的概念 – Part 1 1234567891011121314151617181920;(function(global, $)&#123; var Greetr = function(firstname, lastname, language)&#123; return new Greetr.init(firstname, lastname, language); &#125; var supportedLangs = ['en', 'ch'] /* 看這邊就好 */ Greetr.prototype = &#123;&#125; Greetr.init = function(firstname, lastname, language)&#123; var self = this; self.firstname = firstname || ''; self.lastname = lastname || ''; self.language = language || 'ch'; &#125; &#125;)(window, jQuery) 我們不用放在 prototype 或 function constructor 裡面，這樣會佔據額外的記憶體位置。 直接將變數建立在 IIFE裡 就可以了，通過 scope chain的特性，外部環境 (這邊相對於IIFE的外部環境就是window) 是參照不到這個 IIFE 內的變數的。透過以上程式碼其實我們已經產生一個閉包 Closure。透過這種方法，我們可以讓使用 framework 的人沒有辦法去改這些變數的值，但是在使用 method 的時候，仍然可以參考到這些變數。 建立更多變數 12345678910111213141516171819202122232425262728;(function(global, $)&#123; var Greetr = function(firstname, lastname, language)&#123; return new Greetr.init(firstname, lastname, language); &#125;/* 看這邊就好 */ var supportedLangs = ['en', 'ch'] ; var greetings = &#123; en: 'Hello', ch: '你好' &#125;; var formalGreetings = &#123; en: 'Greetings', ch: '您好' &#125;; var logMessages = &#123; en: 'Logged in', ch: '已登入' &#125;;/* 看這邊就好 */ // ...略 &#125;)(window, jQuery) 開始建立方法(method)方法該寫在哪 ?有兩個地方可以放置我們想要的方法，分別是如下圖的（1）和 （2）。但是如果放在這個 function constructor 中（2），變成每一個所建立的物件都會直接帶有這個方法，如此會佔據相當多的記憶體空間；所以比較好的方式是利用原型的概念，把根據這個 function constructor 所建立的物件，都可以使用到的方法，放到（1） 的 prototype 當中。 參考：JS的原型繼承(方法1) － 函數建構子 與「new」 - 我們不該把方法放在 function constructor 中 開始撰寫程式碼接著，我們要在 prototype 中開始建立一些 framework 裡面可以使用的方法，就像是jQuery的 animate() 或 attr() 這類的自訂函數。 我們先來看一下建立完方法後完整的程式碼長什麼樣子，這些程式碼都是放在Greetr.prototype 內，接著我們再來分別解釋每個方法的意義 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* 屬性 */var supportedLangs = ['en','ch']var greetings = &#123; en: 'Hello', ch: '你好'&#125;;var formalGreetings = &#123; en: 'Greetings', ch: '您好'&#125;;var logMessages = &#123; en: 'Logged in', ch: '已登入'&#125;;/* 方法 */Greetr.prototype = &#123; fullName: function() &#123; return this.firstname + ' ' + this.lastname; &#125;, validate: function () &#123; if (supportedLangs.indexOf(this.language) === -1) &#123; throw "Invalid language"; &#125;; &#125;, greeting: function() &#123; return greetings[this.language] + ' ' + this.firstname + '!'; &#125;, formalGreetings: function() &#123; return formalGreetings[this.language] + ',' + this.fullName(); &#125;, greet: function(formal) &#123; var msg; if (formal) &#123; msg = this.formalGreetings(); &#125;else &#123; msg = this.greeting(); &#125; if (console) &#123; console.log(msg); &#125; return this; &#125;, log: function() &#123; if (console) &#123; console.log(logMessages[this.language] + ': ' + this.fullName()); &#125; return this; &#125;, setLang: function(lang) &#123; this.language = lang; this.validate(); return this; &#125;&#125;; 方法解析fullName() - 全名字串組合123fullName: function() &#123; return this.firstname + ' ' + this.lastname; &#125; 這個比較單純，就是印出物件實體的名字屬性。 validate() - 驗證語言12345validate: function () &#123; if (supportedLangs.indexOf(this.language) === -1) &#123; throw "Invalid language"; &#125;;&#125; 用來檢測使用者所輸入的語言有沒有支援，我們剛剛新增了一個陣列supportedLangs = [&#39;en&#39;, &#39;ch&#39;]，我們可以透過 indexOf 來檢測該物件的語言this.language，如果沒有與陣列中任何一個值吻合，indexOf 會回傳 -1，並透過 throw 在 console 裡丟出錯誤訊息。 indexOf： 如果有吻合會回傳對應的陣列位置，例如輸入supportedLangs.indexOf(&#39;en&#39;)，因為吻合supportedLangs = [&#39;en&#39;, &#39;ch&#39;] 該陣列的第0個物件，所以會回傳 0 。 greeting() - 非正式招呼123greeting: function() &#123; return greetings[this.language] + ' ' + this.firstname + '!'; &#125; 這樣寫的目的是要取得 該物件的語言 ，並對應到剛剛宣告的物件 greetings = {en: &#39;Hello&#39;,ch: &#39;你好&#39;} ，把值給抓出來，如果 該物件的語言的語言設定成 en 就抓出Hello；ch就抓出你好。 formalGreetings() - 正式招呼123formalGreetings: function() &#123; return formalGreetings[this.language] + ',' + this.fullName(); &#125; 基本上和上一個非正式招呼一樣，值得注意的是名字的部分它呼叫了this.fullName()，這邊記得要加上this，因為這個方法存在於這個物件的原型裡，而不是環境中。 greet() - 合併正式與非正式招呼。123456789101112131415greet: function(formal) &#123; var msg; if (formal) &#123; msg = this.formalGreetings(); &#125;else &#123; msg = this.greeting(); &#125; if (console) &#123; console.log(msg); &#125; return this;&#125; 透過 greet 這個方法，我可以直接控制我要使用的是 greeting() 或 formalGreeting() ，而不用打出這兩個方法。 如果我們給予的參數 formal 存在的話( if會型轉為true，然後執行程式碼 )，那麼執行 formalGreeting()，否則使用 greeting()。 為了避免有些IE版本不支援 console 這個物件，我們用 if(console)，意思是如果有 console 這個物件的話，再幫我輸出。 最重要的是 return this ，這是在模仿jQuery的鏈式 methods chainning，而這裡的 this 指的也就是我們的物件，因此透過這個 return this，它可以先針對物件進行欲要進行的方法後，最後再次將它回傳成一個物件，於是，它就可以繼續在接著下一個方法，形成一個方法鍊的作法。 (方法鏈)鏈式簡易範例： 12345678910111213var person = &#123; name: 'Dylan', method1: function() &#123; this.name = 'Eva'; return this; &#125;, method2: function() &#123; this.name = 'John'; return this; &#125;&#125;person.method1().method2(); person.method() 執行後 person.name 會被改為 Eva，然後透過return this 回傳一個改名後的新物件，再接著執行新物件.method2()。 log() - 針對不同語言，在console印出登入訊息+使用者名字123456log: function() &#123; if (console) &#123; console.log(logMessages[this.language] + ': ' + this.fullName()); &#125; return this;&#125; 使用的技巧和上面重複。 setLans() - 更改所設定的語言12345setLang: function(lang) &#123; this.language = lang; this.validate(); return this;&#125; 設定新語言，呼叫上面寫過的 validate() 驗證語言是否支援，且一樣使用鏈式的 return this。 測試功能 接著在 app.js 中，我們可以試著來測試一下所建立的 framework 。 12var person = G$('Dylan', 'Liu'); // language 預設是 chperson.greet().setLang('en').greet(true); 我就可以得到以下的結果。因為我們有使用了鏈式的技巧，所以我可以一個接著一個方法的使用，當中我又用了 setLang() 這個方法，把預設的語言改成英文： 結果 12var person = G$('Eva', 'Lin'); // language的預設是chperson.log().setLang('jp').greet(true); 首先會回傳登入的訊息，接著因為我把語言設成 “jp” ，但框架並不支援日語，所以回拋出錯誤的訊息。 完整程式碼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192;(function (global, $) &#123; var Greetr = function (firstname, lastname, language) &#123; return new Greetr.init(firstname, lastname, language); &#125; var supportedLangs = ['en','ch'] var greetings = &#123; en: 'Hello', ch: '你好' &#125;; var formalGreetings = &#123; en: 'Greetings', ch: '您好' &#125;; var logMessages = &#123; en: 'Logged in', ch: '已登入' &#125;; Greetr.prototype = &#123; fullName: function() &#123; return this.firstname + ' ' + this.lastname; &#125;, validate: function () &#123; if (supportedLangs.indexOf(this.language) === -1) &#123; throw "Invalid language"; &#125;; &#125;, greeting: function() &#123; return greetings[this.language] + ' ' + this.firstname + '!'; &#125;, formalGreetings: function() &#123; return formalGreetings[this.language] + ',' + this.fullName(); &#125;, greet: function(formal) &#123; var msg; if (formal) &#123; msg = this.formalGreetings(); &#125;else &#123; msg = this.greeting(); &#125; if (console) &#123; console.log(msg); &#125; return this; &#125;, log: function() &#123; if (console) &#123; console.log(logMessages[this.language] + ': ' + this.fullName()); &#125; return this; &#125;, setLang: function(lang) &#123; this.language = lang; this.validate(); return this; &#125; &#125;; Greetr.init = function (firstname, lastname, language) &#123; var self = this; self.firstname = firstname || ''; self.lastname = lastname || ''; self.language = language || 'ch'; &#125; Greetr.init.prototype = Greetr.prototype; global.Greetr = global.G$ = Greetr;&#125;)(window, jQuery); 資料來源 PJChender - 親手打造屬於你自己的 JavaScript Framework/Library（中） JavaScript 全攻略：克服JS的奇怪部分 9-76]]></content>
      <categories>
        <category>JavaScript</category>
        <category>克服JS的奇怪部分</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>克服JS的奇怪部分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[實作一個 JavaScript 迷你框架 (一)]]></title>
    <url>%2Fbuild-a-js-framework-1.html</url>
    <content type="text"><![CDATA[前言在這系列的課程，我們將總結 JavaScript 全攻略：克服JS的奇怪部分 學習到的知識，並仿效 jQuery 原始碼的架構，來打造一個簡單的 Framwork，取名為 Greetr。 關於 jQuery的架構可以參考 jQuery原始碼關鍵架構 JavaScript 全攻略：克服JS的奇怪部分 - 第八章節 需求 當我們在打造一個 framework 時，須事先規劃好這個 framework 要具備哪些功能，而不是一股腦的就打開程式編輯器開始寫，以下是這個框架的功能。 當我們告訴它我們的姓（lastname）名（firstname）還有選擇的語言（language）時，它可以用正式（formal）和非正式（informal）的方式和我們打招呼。 支援英文（English）和中文（Chinese）兩種語言。 是一個可重複使用的 library/framework，也就是說，每一個安裝此 framework 的人可以直接使用，不會和它原本程式碼有所衝突。 和 jQuery只需要輸入 $() 一樣，我們可以使用 G$( )來建立物件。 支援 jQuery，可以把 Greetr 產生的訊息直接顯示於 HTML 中。 HTML123456789&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="jquery-3.0.0.js"&gt;&lt;/script&gt; &lt;script src="greetr.js"&gt;&lt;/script&gt; &lt;script src="app.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 安全的程式碼 IIFEs 參考：PJChender - 為什麼我們要用IIFEs(Immediately Invoked Functions Expressions) 先前的課程有提到知名的框架通常都會使用 IIFE，避免程式碼使用者和框架的程式碼互相汙染。 12345(function(global, $) &#123;// the content of framwork&#125;)(window, jQuery) 同時，因為我們要讓我們的 framework 能夠取用或改變到全域環境的內容，同時還要支援 jQuery ，因此在參數的地方，我們會帶入 window 和 jQuery 的核心 。 補充：我們還可以加上 ; 在最前面，防止前一份 Framwork 或程式碼結尾沒有加上分號而導致的問題。 1;(function(global, $) &#123; ... &#125; 不使用 new 就可以建立物件 參考：[筆記] 跟著JQuery原始碼一起學習程式設計 我們可以利用 return 一個 function constructor 的方式來達到這樣的效果，如下面程式碼中第 1 部分所示，而第 2 部分，才是我們真正的函數建構子。 123456789101112131415;(function (global, $) &#123;/* 1. new放在這個函數中 */ var Greetr = function (firstName, lastName, language) &#123; return new Greetr.init(firstName, lastName, language); &#125;/* 2. 函數建構子 */ Greetr.init = function (firstName, lastName, language) &#123; this.firstName = firstName; this.lastName =lastName; this.language = language; &#125;&#125;)(window, jQuery) 建立函數建構子的預設值接著，我們要在函式裡面為 firstname, lastname 和 language 來建立預設值 [筆記] JavaScript中coercion的實際使用–建立函式預設值(default value)[筆記] 談談JavaScript中的”this”和它的bug 12345678Greetr.init = function (firstName, lastName, language) &#123; /* 1 */ var self = this /* 2 */ self.firstName = firstName || ''; self.lastName = lastName || ''; self.language = language || 'ch';&#125; ES6還可以這麼做 1Greetr.init = function (firstName = '', lastName = '', language = 'ch') &#123; &#125; 為了避免 this 可能在後面使用時碰到一些問題，所以在第 1 部分的地方，我們用 var self = this 這樣的方法，來避免 this 在後續操作上可能會碰到的問題；在第 2 部分的地方，我們則是透過 JavaScript 中強制轉換coercion的特性，使用 OR operator || 的方式來達到預設值的效果。 建立函數建構子的原型（prototype） 參考：JS的原型繼承(方法1) － 函數建構子 與「new」 該篇文章中的函數建構子和prototype的建立部分 12345678910111213141516171819202122;(function (global, $) &#123; var Greetr = function (firstName, lastName, language) &#123; return new Greetr.init(firstName, lastName, language); &#125;/* 1 */ Greetr.prototype = &#123; // 方法寫在這 &#125; Greetr.init = function (firstName, lastName, language) &#123; var self = this self.firstName = firstName || ''; self.lastName =lastName || ''; self.language = language || 'ch'; &#125;/* 2 */ Greetr.init.prototype = Greetr.prototype&#125;)(window, jQuery) 我們的函數建構子是 Greetr.init，如果要設定相關方法，照理說應該要設定在Greetr.init.prototype，但是為了讓程式碼更好閱讀，我們要將方法設置在 Greetr.prototype 內，如 /* 1 */ 。再來我們還必須讓 Greetr.init 建構子 所建立的物件實體 instance 可以參考到 Greetr.prototype 內的方法，我們可以使用/* 2 */ 這行程式碼來達到目的。 使用 G$( ) 即可快速建立物件就像在 jQuery 中，我們可以使用 jQuery() 或 $() 來選取DOM，在這裡，我們希望我們可以使用 Greetr() 或 G$() 這兩種方式來建立物件。 我們只需要加上這一行，就可以達到這樣的效果了。 1G$ = Greetr 讓全域環境也可以取用如果是上面的寫法，只有在這個IFFE內才能取用到 G$() 和 Greetr()，因為就詞彙環境來說，全域物件裡並沒有這個變數。 1global.G$ = global.Greetr = Greetr 加上Global，是為了讓全域都可以使用這些功能 ，如此一來 G$() 和 Greetr() 也可以在全域環境下使用了。 測試目前為止的 Greetr.js 程式碼如下，已經可以簡單使用了。 12345678910111213141516171819202122;(function(global, $)&#123; var Greetr = function(firstname, lastname, language)&#123; return new Greetr.init(firstname, lastname, language); &#125; Greetr.prototype = &#123;&#125; Greetr.init = function(firstname, lastname, language)&#123; var self = this; self.firstname = firstname || ''; self.lastname = lastname || ''; self.language = language || 'EN'; &#125; Greetr.init.prototype = Greetr.prototype; global.Greetr = global.G$ = Greetr; &#125;)(window, jQuery) 試著在 app.js，建立一個物件： var a = G$('Dylan', 'Liu', 'EN') 結果 資料來源： JavaScript 全攻略：克服JS的奇怪部分 9-73、74、75 PJChender - 親手打造屬於你自己的 JavaScript Framework/Library（上）]]></content>
      <categories>
        <category>JavaScript</category>
        <category>克服JS的奇怪部分</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>克服JS的奇怪部分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 原始碼關鍵架構]]></title>
    <url>%2Fanalyze-jquery-source-code.html</url>
    <content type="text"><![CDATA[原始版1234567891011121314151617181920212223242526(function (global, factory) &#123; factory(global);&#125;)(window, function (window, noGlobal) &#123; //這裡才是放jquery核心程式碼的地方 var version = "1.11.2"; var jQuery = function (selector, context) &#123; return new jQuery.fn.init(selector, context); &#125; //這個fn身上放各種功能函式 jQuery.fn = jQuery.prototype = &#123; jquery: version, constructor: jQuery, //各種功能 first: function (selector) &#123;&#125; &#125;; //這個new 物件的時候傳參進去 var init = jQuery.fn.init = function (selector, context) &#123; //拿到選擇器幹事兒 &#125;; init.prototype = jQuery.fn; window.jQuery = window.$ = jQuery;&#125;); 簡化版1234567891011121314151617181920212223242526(function (global, factory) &#123; factory(global);&#125;)(window, function (window, noGlobal) &#123; //這裡才是放jquery核心程式碼的地方 var version = "1.11.2"; var jQuery = function (selector, context) &#123; return new jQuery.fn.init(selector, context); &#125; // 放建構子方法 jQuery.prototype = &#123; jquery: version, constructor: jQuery, //各種功能 first: function (selector) &#123;&#125; &#125;; //函數建構子 jQuery.init = function (selector, context) &#123; &#125;; jQuery.init.prototype = jQuery.prototype; window.jQuery = window.$ = jQuery;&#125;); 資料來源jQuery原始碼分析]]></content>
      <categories>
        <category>JavaScript</category>
        <category>克服JS的奇怪部分</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>克服JS的奇怪部分</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode 快捷鍵整理]]></title>
    <url>%2Fvscode-shortcuts.html</url>
    <content type="text"><![CDATA[多行註解1Shift + Alt + A 選取整行1Ctrl + L 查詢變數1對變數按右鍵 + 預覽變數 程式碼摺疊12345Ctrl + K -&gt; Ctrl + [數字] // 摺疊層級Ctrl + K -&gt; Ctrl + 0 // 摺疊所有程式碼Ctrl + K -&gt; Ctrl + J // 取消摺疊 手動選取多個位置1Alt + [click] 一次選取檔案內所有相同的文字123Ctrl + Shift + L對目標按右鍵 + 變更所有發生次數 智慧擴展 / 縮減選擇1Alt + Shift + ← → 格式化程式碼1Alt + Shift + F 快速開啟檔案1Ctrl + P 選取相同字串1Ctrl + D 單行註解1Ctrl + / 跳到該檔案的某行1Ctrl + G 目前游標所在行，向上或向下移動1Alt + ↑ ↓ 目前游標所在行，複製並移動1Alt + Shift + ↑ ↓ 分割編輯視窗1Ctrl + [數字] 開啟終端機1Ctrl + ` 建立新終端機分頁1Ctrl + Shift + ` 搜尋目前檔案1Ctrl + F 搜尋全部檔案 / 取代1Ctrl + Shift + F]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 的原型繼承(方法3)－ES6 Class]]></title>
    <url>%2Fes6-class.html</url>
    <content type="text"><![CDATA[前言在 ES6中的 Class(類別)語法，並不是向其他語言真的是以類別為基礎 ( class-based ) 的物件導向，在骨子裡仍然是以原型為基礎 ( prototype-based ) 的物件導向，它只是個語法糖 ( syntactical sugar )。加入 Class(類別)語法的目的，並不是要建立另一套物件導向的繼承模型，而是為了提供更簡潔的語法來作物件建立與繼承，當然，一部份的原因是，讓已經熟悉以類別為基礎的物件導向程式語言的開發者使用，以此提供另一種在物件導向語法上的選擇。 語法糖(syntactical sugar)：指的是在程式語言中添加的某些語法，這些語法對語言本身的功能並沒有影響，但是能更方便使用，可以讓程式碼更加簡潔，有更高可讀性。 圖片來源 類別宣告 class declaration如何使用class 12345678910111213class Person&#123; constructor(firstname, lastname)&#123; this.firstname = firstname; this.lastname = lastname; &#125; getFullName()&#123; return "Hello "+ this.firstname + " " + this.lastname; &#125;&#125;var john = new Person("John","Doe");console.log(john); 先設定一個 class類別 Person，裏頭開分為兩塊來看，constructor可以想像成之前所學的函數建構子，若要新增方法 getFullName寫在class內即可。 用函數建構子的方式，寫一次相同的程式，會更好理解。 1234567891011function Person(firstname, lastname) &#123; this.firstname= firstname this.lastname= lastname&#125;Person.prototype.getFullName = function()&#123; return "Hello "+ this.firstname + " " + this.lastname;&#125;var john = new Person('John', 'Doe');console.log(john); 在其他的語言，類別是創建物件的藍圖 blue print，但在ES6，類別本身就是被建立出來的物件，上例 class Person 是一個實際被建立的物件，開發者是從物件class Person建立新物件 john出來的，也就是說，ES6 的 Class，本質仍然是原型繼承，而非變成古典繼承。 class的命名規範和先前的函數建構子一樣首字建議大寫。 繼承 Extends由剛剛的例子做延伸 123456789101112131415161718class Person&#123; constructor(firstname, lastname)&#123; this.firstname = firstname; this.lastname = lastname; &#125; getFullName()&#123; return "Hello "+ this.firstname + " " + this.lastname; &#125;&#125;class InformalPeron extends Person&#123; greet() &#123; return 'Yo' + firstname &#125;var john = new InformalPeron('John', 'Doe')&#125; 結果是 john的原型指向(繼承)了InformalPeron，而InformalPeron也繼承了 Person 的屬性及方法，形成一個原型鏈 prototypal chain。 呼叫父類別 Super 用extends關鍵字可以作類別的繼承，而在建構式中會多呼叫一個super()方法，用於執行上層父母類別的建構式之用。super也可以用於指向上層父母類別，呼叫其中的方法或存取屬性。 繼承時還有有幾個注意的事項: 繼承的子類別中的建構式，super()需要放在建構式第一行，這是標準的呼叫方式。如果有需要傳入參數可以傳入。 繼承的子類別中的屬性與方法，都會覆蓋掉原有的在父母類別中的同名稱屬性或方法，要區為不同的屬性或方法要用super關鍵字來存取父母類別中的屬性或方法，例如super.toString() 12345678910111213141516171819class Point &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y) this.color = color &#125; toString() &#123; return super.toString() + ' in ' + this.color &#125;&#125; 輸出結果 創建 static 函數關鍵字 static 定義了一個類別的靜態方法，靜態方法不需要實體化它所屬類別的實例就可以被呼叫，它也無法被已實體化的類別物件呼叫。靜態方法經常被用來建立給應用程式使用的工具函數，可以有效避免全域的污染。 123456789class Point &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; static staticFn() &#123; return 'This is static function' &#125;&#125; 全域 namespace 呼叫 1Point.staticFn // output: 'This is static function' 創建 setter、getter 函數getter 及 setter 函數都是 callback function, callback 函數有三個的特點 由你定義的 你並沒有調用 但最終他執行了 1234567891011121314151617class Square &#123; constructor(width, height) &#123; this.width = width this.height = this.width &#125; get area() &#123; return this.width + this.height &#125; set area(value) &#123; console.log('value: ' + value) this.newData = 'Hello!' this.width = value this.height = this.width &#125;&#125;const square1 = new Square(5) getter 在當你讀取此屬性值時，自動調用 (就像 Vue 框架的計算屬性 computed) 1square1.area // output: 10 setter 調用於 getter 參數被修改時，並且接受一個 param，值為 setter 被賦予的新值 1square1.area = 10 在執行 square1.area = 10 後, setter 已經被調用了，現在試著印出 setter 函式內所更改和新增的屬性 12console.log(newData) // output: 'Hello!'console.log(width) // output: 10 Getter 及 Setter Codepen DEMO ES6 class 原型繼承完整 DEMO Codepen 小結類別的語法目前雖然內容少而簡單，但它仍然有不少的好處。如果你把它當作是一種自訂物件類型的簡寫語法來看，它隱藏了很多JS中物件在作初始化與繼承的複雜語法，提供了較為簡單、閱讀性高、較容易維護的語法。並不是說直接使用原型語法來寫達不到，只是原型物件導向的特性需要理解到一定的程度，才有辦法寫出像類別這麼簡短的語法能達到的事情。 資料來源 MDN PJChender [JS] JavaScript 類（Class） eyesofkids - Day 10: ES6篇 - Class(類別) SimonAllen - Day29 Object.create與class 原型基礎物件導向 [YouTube] Class 的完整介紹 | Class 其實只是….. JavaScript 全攻略：克服JS的奇怪部分 6-64]]></content>
      <categories>
        <category>JavaScript</category>
        <category>克服JS的奇怪部分</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>克服JS的奇怪部分</tag>
        <tag>原型繼承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 的原型繼承(方法2)－Object.create()]]></title>
    <url>%2Fobject-create.html</url>
    <content type="text"><![CDATA[前言先前的筆記中已經談到了用function constructor來建立物件，同時也提到這個概念是模仿其他程式語言來的，然而其他的程式語言會用class這個關鍵字來設定物件的模板(tamplate)，然後用new來建立物件，這是古典繼承/類別物件導向的程式語言；而 JavaScript始終是一個原型繼承/原型物件導向語言，所以即使看起來很像，本質上是不同的。 因此有許多人認為專注在JS中的原型繼承而不要使用古典繼承會是個好選擇。而JS中還有一個沒有模仿其他程式語言的建立物件方法，它就是等等我們要談的Object.create()。 Object.create() 使用首先，我們先使用這段程式碼建立一個物件的原型 1234567var Person = &#123; firstName: 'Default', lastName: 'Default', getFullName: function () &#123; return this.firstName + " " + this.lastName; &#125;&#125; 然後建立一個以Person為基礎的物件 12var john = Object.create(Person);console.log(john); 輸出的結果如下，它是一個空物件，但是它繼承了 Person 這個物件當中的屬性和方法： 透過 Object.create() 可以建立一個空物件，同時可以將帶入Object.create() 的參數內容變成該物件的原型。 Object.create()是最單純使用原型繼承prototypal inheritance的方式，使用 Object.create() 的方式運用繼承和原型的概念能夠非常簡便的建立物件。 實際應用 如果你想要定一個物件的原型，就先建立一個 A 物件當做其他物件的基礎，然後再建立另一個空物件 B，指稱 A 物件當做它的原型，再透過為 B 物件賦予屬性或方法。 12345678910111213var A = &#123; firstName: 'Default', lastName: 'Default', getFullName: function () &#123; return this.firstName + " " + this.lastName; &#125;&#125;var B = Object.create(A);B.firstName = 'John';B.lastName = 'Doe';console.log(john.getFullName()); 對於 firstName和 lastName來說，在 B物件就已經有這兩個屬性，因此它不會在往該物件的原型__proto去尋找，而對 getFullName 來說，因為在 B這個物件裡沒有這個方法，於是就會到 __proto__ 裡面去找，最後會回傳&quot;John Doe&quot;。 關於這個概念考可以參考之前的筆記了解JavaScript中原型(prototype)、原型鍊（prototype chain）和繼承(inheritance)的概念 若瀏覽器不支援雖然大部分的新瀏覽器都支援這個語法，但如果某些瀏覽器的版本真的舊到無法使用 Object.create() 的話，可以怎麼辦呢？我們可以利用函數建構子 與「new」的方式新增這個功能。 使用polyfill polyfill： 有一些舊型瀏覽器引擎不支援某些JavaScript功能，因此有人會自己撰寫一些程式碼來實作相同效果的功能。 12345678910111213// polyfill for Object.create()if (!Object.create) &#123; Object.create = function (o) &#123; if (arguments.length &gt; 1) &#123; throw new Error('Object.create implementation only accepts the first parameter'); &#125; function F() &#123;&#125;; F.prototype = o; return new F(); &#125;;&#125; 分析程式碼 首先先判斷瀏覽器支不支援，如果瀏覽器中查無Object.create會回傳布林值false，再由!運算子轉換成true，觸發if內程式碼。 1if (!Object.create) &#123; ... &#125; 由於瀏覽器不支援，所以我們要在JS引擎內建的 Object() 函數建構子內，自己創造一個名字一樣為create的方法。 1Object.create = function (o) &#123; ... &#125; 如果 Object.create = function (o) { ... } 的傳入參數 o 超過一個以上，console回報錯誤訊息。 123if (arguments.length &gt; 1) &#123; throw new Error('Object.create implementation only accepts the first parameter');&#125; 建立一個名為 F 的函數建構子。 1function F() &#123;&#125;; 在F建構子的prototype當中新增一個物件，該物件是之後使用者回傳入的參數 o 1F.prototype = o; 回傳一個以F函數建構子為基礎，並以new創造的物件，且該物件的__proto會繼承F.prototype內的物件( 也就是使用者傳入的參數o )，如此一來能夠達到Object.create()的原始效果。 1return new F(); 資料來源 PJCHENder - 談談JavaScript中最單純的原型繼承（prototypal inheritance）─ Object.create SimonAllen - Day29 Object.create與class 原型基礎物件導向 JavaScript 全攻略：克服JS的奇怪部分 5-63]]></content>
      <categories>
        <category>JavaScript</category>
        <category>克服JS的奇怪部分</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>克服JS的奇怪部分</tag>
        <tag>原型繼承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 的內建函數建構子]]></title>
    <url>%2Fbuildin-constructor.html</url>
    <content type="text"><![CDATA[前言我們在之前學到利用函數建構子來創造物件，然而在JavaScript中原本就有內建了幾個建構子，如Number()、String()、Date() ….，或許過去你已經有使用過，但可能並不是很了解底層運作的原理，經由上一章函數建構子 與「new」，我們已經很清楚了，現在你只要使用一樣的概念來讀這篇即可。 註：內建的函數建構子，如上一章所述也都是以第一個字母大寫呈現。 new Number()1new Number(); 首先，先輸入： 123var num = new Number(3);console.log(num);console.log(Number.prototype); 從 new 這種用法我們可以理解到 Number() 是一個 function constructor，且是由JS引擎內建給我們的，也就是說由new Number()所建立的物件會含有Number.prototype內的method。另外很重要的是，因為它是透過 function construct 加以建立的，所以它雖然看起來是個數值，但它實際上還是個物件 。 因此，輸出之後我們會看到以下結果： num.__proto__ 包含了 它的建構子Number.prototype內的 method。 new String() 1new String(); 類似的方式我們也可以看看用 String() 這個 function constructor 所建立的物件： 1234var str = new String('我是一個字串');console.log(str);console.log(String.prototype);console.log(str.indexOf("字串")); 在這裡， str 一樣是透過 function constructor 所建立的 物件，而不是真正的字串！同時 str 繼承了String.prototype 裡面的內容，所以我們可以直接使用 str.indexOf() 這樣的JS內建方法來查找字串，結果如下： new Date()即使是 Date()，它輸出的結果雖然看起來很像是一個字串，但它實際上還是物件，我們可以這樣做： 1234var date = new Date("2/22/2019");console.log(date);console.log(typeof(date));console.log(Date.prototype); 如此，我們會發現它依然是個物件，而這個物件也一樣繼承了來自 Date.prototype 的屬性和方法： 用物件的method來處理純值 有些時候，JavaScript 會知道你想要針對純值（primitive type）去做一些物件才能處理的事，因此它會幫你將所輸入的純值進行物件般的處理。 12//stringconsole.log("Dylan".length); // 5 記得嗎? 純值是沒有屬性（property）和方法（method）的，我們之所以這樣輸入一樣可以得到 9 的結果，是因為 JavaScript 自動的幫我們把這個原生值進行了物件的處理！ 對內建的function constructor增添自訂屬性和方法函數建構子 與「new」 章節提到的.prtotype可以為函數建構子增添自訂的方法 method，現在我們同樣可以為內建的函數建構子增添方法。 透過這種方式來增添屬性或方法時，要留意的是，不要不小心把原本內建的屬性或方法給無意間覆蓋掉了。 對String()建構子增加方法12345String.prototype.isLengthGreaterThan = function(limiter)&#123; return this.length &gt; limiter;&#125;console.log("Dylan".isLengthGreaterThan(4)); // True 透過以上的程式碼，我們幫原本內建的 String() 這個 function constructor 新增了一個名為 isLengthGreaterThan 的方法，此後所有的字串都可以取用這個方法了，而很多library和framwork都是這樣新增功能的，這就是原型繼承強大所在。 如此當我們輸入 &quot;Dylan&quot;.isLengthGreaterThan(4) 就會回傳 true 的結果給我們。在這裡，如同剛剛所提，我們輸入的 &quot;Dylan&quot; 是字串純值，但 JavaScript 知道我們希望對它進行和物件有關的方法，因此會自動用物件的方式將它做處理。 對Number()建構子增加方法增加判斷是否為正整數的方法isPositive 12345Number.prototype.isPositive = function()&#123; return this &gt; 0;&#125;console.log(3.isPositive()); 結果會出現錯誤 會跳錯是因為 3.isPositive() 的地方，在上面提到JavaScript雖然能夠幫我們自動判斷，順利用屬於物件的方法來處理純值字串，但如果是純值數字的話會造成JavaScript直譯器在編譯上發生錯誤。 解決方法 用()包住 用變數 1234567Number.prototype.isPositive = function()&#123; return this &gt; 0;&#125;var a = 3;console.log(a.isPositive()); // trueconsole.log((3).isPositive()); // true 補充Moment.js - 時間處理函式庫順帶一提，如果有用JS處理時間的需求，作者不建議使用JS內建的時間方法，他推薦使用JS函示庫 Moment.js，這可以幫助開發者迴避一些因建構子產生的問題。 不要使用內建的函式建構子來建立純值看完這篇及上一章函數建構子 與「new」必須建立的觀念：利用這些 function constructors 所建立的東西，看起來可能像數值、字串等等，但實際上，它們都還是物件。 讓我們看一下這段程式碼： 123456var numPrimitive = 5 ;var numFromConstructor = new Number(5);console.log(typeof numPrimitive + "; " + typeof numFromConstructor); // number; objectconsole.log(numPrimitive == numFromConstructor); // trueconsole.log(numPrimitive === numFromConstructor); // false 你會發現，numPrimitive 和 numFromConstructor 看起來都是一樣的5，但如同上面所提到的 numPrimitive是純值數字 primitive type 而 numFromConstructor是物件 object。 所以 當你使用 == 時，JavaScript會進行強制型轉，回傳true 當使用===時，並不會型轉，而是進一步比較兩者的類型，理所當然回傳false 這也是為什麼盡量不要使用和純值有關的 function constructors，而是使用真正的純值或是實體語法，因為如果交替使用的話，不小心你已經不知道到底哪些是純值哪些是透過function constructors所建立的物件，進而導致在進行比較時產生無法預期的問題。 資料來源 PJCHENder - 談談JavaScript中內建的function constructors及應注意的地方 SimonAllen - Day28 內建的函式建構子 JavaScript 全攻略：克服JS的奇怪部分 5-60、61]]></content>
      <categories>
        <category>JavaScript</category>
        <category>克服JS的奇怪部分</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>克服JS的奇怪部分</tag>
        <tag>原型繼承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 的原型繼承(方法1) － 函數建構子與「new」]]></title>
    <url>%2Ffunction-constructor.html</url>
    <content type="text"><![CDATA[前言在前幾篇的筆記中，我們已經對於物件（object）、原型（prototype）、繼承（inheritance）和原型鏈等等有更多的了解，現在讓我們來更深入的談論一下 JavaScript中 建立物件的方法。 JavaScript語法本身其實已經有物件實體這個快速好用的建立物件方法，但追溯到早期 JavaScript剛被創造出來時，參考了其他語言的古典繼承的概念和 new 關鍵字，而與 new一起出現的用法就是 function constructor函數建構子。 函數建構子 Function constructor 能用來新建物件的一種函式，透過與 new運算子一起使用，能創建出新物件並設定該物件的屬性與方法 1234567function Person ()&#123; this.firstName = 'John'; this.lastName = 'Doe';&#125;var john = new Person();console.log(john); 結果 變數john指向了new person()創造出來的物件，印出john發現裏頭的屬性和Person()一致。 在運算子表格裡，可以得知new是一種運算子。 補充知識 - instance 物件實體由函數建構子創造出來的物件，稱為instance，由上例我可以說，物件 john是函數建構子 Person的物件實體。 當使用new時背後發生什麼事 ? JS直譯器 syantax parsor會先建立一個空物件{}。 接著呼叫new後面的函式建構子，當函式被呼叫時，創造函式執行環境 Excusion content，this關鍵字也隨之被創造出來。 由於this被寫在new的後面，JS直譯器知道你在用函數建構子創造物件，因此this指向了剛被創造出來的空物件{}，所以函式建構子內的this.xxx被創造在這個空物件中。 我們先前知道，全域函式的this會指向全域物件，現在因為new關鍵字，this指向了john，我們可以將程式碼改成這樣，多加一個console.log(this);，看看會印出window還是john指向的這個物件。 12345678function Person ()&#123; console.log(this) // Person &#123;&#125; this.firstName = 'John'; this.lastName = 'Doe';&#125;var john = new Person();console.log(john); // Person &#123;firstName: "John", lastName: "Doe"&#125; 結果 由此可以了解new會改變this的對象 如果在函數建構子使用 return使用new的狀況下，new後方的函式預設不會回傳值，若故意在函式裡寫上return的話，函式反而會因為return回傳東西，依狀況決定是否把this創造的物件屬性蓋掉，看看例子 retrun一個字串123456789function Person ()&#123; console.log(this) this.firstName = 'John'; this.lastName = 'Doe'; return 'this is return value' //**&#125;var john = new Person();console.log(john); 結果 雖然加了return &#39;this is return value&#39;但是物件輸出結果不受影響 retrun一個物件123456789function Person ()&#123; this.firstName = 'John'; this.lastName = 'Doe'; console.log(this) //** return &#123; name: 'this is return object test' &#125; //**&#125;var john = new Person();console.log(john); 函式的最後若 return其他物件，則前面設定的物件內容會被覆蓋。 容易出錯的地方 需要注意的是，若是使用使用函數建構子不用new，就會變成一般的呼叫函式。 12var john = new Person();var john = Person(); 有用new 建立物件，且 this指向變數john; 忘了用new 單純呼叫函式 Person，且這時 this指向全域物件，因此設定的屬性會被設定到全域物件(window)裡。 因此，如果使用函數建構子忘了放上 new可能會造成預期以外的錯誤，且它的樣子與一般的函數表示式 function ecpression長得無異，會非常難以 debug，因此人們習慣將所有函數建構子的首字以大寫表示 函數建構子和prototype的建立函式就是物件，它有一些隱藏屬性，像是函數的名稱(Name)及函數的內容(Code)，其中還有一個專屬於function 的屬性叫做.prototype，這個屬性會以空物件形式呈現。 除非你是把 function 當做 function constructor 來使用，否則這個屬性就沒有特別的用途；但如果你是把它當做 function constructor，透過 new 這個關鍵字來執行這個 function 的話，它就有特別的意義了。 圖片來源： PJCHENder那些沒告訴你的小細節 要設定這個 function 的 prototype 屬性只要透過 .prototype 就可以了。 然而，有一點很容易讓人困惑的地方，我們會以為使用 .prototype 時，就可以進入這個函數的原型，但實際上則不是這樣。 函數當中的 prototype 屬性並不是指這個函數本身的 prototype，他指的是透過這個函數建構子所建立出來的物件 __proto__。 function 中的 prototype 屬性一開始是空物件看看以下程式碼 12345678910function Person(firstName, lastName)&#123; this.firstName = firstName; this.lastName = lastName;&#125;var john = new Person('John', 'Doe');console.log(john);var jane = new Person('Jane', 'Doe');console.log(jane); 到 Google Chrome 的 console 中，輸入Person.prototype 會得到一個空物件。 透過 function constructor 所建立的物件會繼承該 function 中 prototype 的內容接著，讓我們在 Person.prototype 裡面增加一個 getFullName 的函數 1234567891011121314function Person(firstName, lastName)&#123; this.firstName = firstName; this.lastName = lastName;&#125;Person.prototype.getFullName = function() &#123; //** return this.firstName + ' ' + this.lastName;&#125;var john = new Person('John', 'Doe');console.log(john);var jane = new Person('Jane', 'Doe');console.log(jane); 我們為 Person.prototype 添加了一個函式，所以當我們在 Google Chrome 的 console 視窗中呼叫 Person.prototype 時，會多了這個函式在內： 剛剛，我們有提到很重要的一句話，「函式當中 prototype 這個屬性並不是這個函式本身的原型，它指的是所有透過這個它所建立出來之 物件實體的原型」。 用程式概念可能比較好說明，這句話的意思是說 Person.prototype 並不是 Person.__proto__，但是所有透過 Person 這個所建立的物件實體，在該物件實例的 __proto__ 中，會包含 Person.prototype 的內容。 也就是說，當我們使用 new 這個運算子來執行函式建構式時，它會先建立一個空物件，同時將該建構子中 prototype，設置到該物件實例 john.__proto__ 中。 因此，當我們在 Google Chrome 的 console 中輸入 john.__proto__ 時，我們就可以看到剛剛在Person.prototype 所建立的函式 getFullName 已經繼承在裡面了。 實際運用由於 Person.prototype 中的方法已經被繼承到由 Person 這個 function constructor 所建立的物件實例 john 中，所以這時侯，我們就可以順利的使用 john.getFullName 來呼叫這個方法。 123456789101112function Person(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName;&#125;Person.prototype.getFullName = function()&#123; return this.firstName + ' ' + this.lastName;&#125;var john = new Person('John', 'Doe');console.log(john);console.log(john.getFullName()); 如此，可以正確的執行 getFullName 這個函數並得到如下的結果 我們不該把方法放在 function constructor 中。 透過以上的方法，我們可以讓所有根據這個函式建構式 function constructor 所建立的物件都包含有某些我們想要使用的方法。如果我們有 1000 個物件是根據這個函式建構式所建立，那麼我們只需要使用 .prototype 這樣的方法，就可以讓這 1000 個物件都可以使用到我們想要執行的某個 method。 有的人可能會好奇說，為什麼我們不要把 getFullName 這個方法直接寫在函式建構式當中呢？ 把 method 放在函數建構子內雖然程式仍可執行，但是如果今天有1000個物件都是根據這個函數建構子所建立，那麼這1000個方法將會各自佔據記憶體空間，相反的如果建立在 prototype 中，就只會有一個記憶體空間被佔據。 所以，為了效能上的考量，最好的做法是 屬性 property放在建構子當中， 方法 method則放在 prototype 中。 原型繼承沿用上一個例子，當我們希望有一個新的建構子 可以繼承另一個已存在的建構子的屬性及方法，能怎麼做 12345678function Person(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName;&#125;Person.prototype.getFullName = function()&#123; return this.firstName + ' ' + this.lastName;&#125; 現在我們要創造一個新的建構子 Teacher，老師會有名字也會有姓，但和其他人不一樣的是，老師可能還包含教授科目的資訊 1234function Teacher(firstName, lastName, subject) &#123; Person.call(this, firstName, lastName) this.subject = subject&#125; 設定 Teacher() 的原型與建構子參考到這部其實還沒結束，目前 Teacher 所繼承的只有來自 Person 的屬性 ( firsName 和 lastName )，還沒有繼承來自 Person 的方法 (getFullName) 來看看目前 Teacher 的原型確實還沒有 getFullName 方法 我們透過 Object.crete() 並搭配等同於 Person.prototype 的原型，建立新的 prototype 屬性值 (它本身就是物件，包含屬性與函式) ，並將之設定為 Teacher.prototype 的值。也就是說 Teacher.prototype 現在會繼承 Person.prototype 上的所有可用函式 1Teacher.prototype = Object.create(Person.prototype) Object.create() 詳細的使用方法可以參考 JS 的原型繼承(方法2)－Object.create() MDN 現在 Teacher 的原型鏈中已經可以找到 getFullName 方法了！ 到目前為止看起來好像很完美了，但其實還沒有結束，現在如果試著輸入 1Teacher.prototype.constructor 這樣可能會產生問題，所以要設定正確。你可回到自己的原始碼並在最下方加入下列程式碼： 1Teacher.prototype.constructor = Teacher 到這就算是完整的做完了一個原型繼承的流程 如果要給 Teacher 建構子擴充新的函式 … 1Teacher.prototype.greeting = function() &#123; ... &#125; ES5 原型繼承 DEMO Codepen 補充建立物件實體後，再在函數建構子裡新增方法123456789101112131415function today(food1,food2)&#123; // new出物件前設定 this.lunch = food1; this.dinner = food2;&#125;today.prototype.eat = function()&#123; return this.lunch + ' ' + this.dinner;&#125;var Dylan = new today('雞絲麵', '麵包');today.prototype.eat2 = function()&#123; // new出物件後，再設定一個eat2() return this.lunch + ' ' + this.dinner;&#125;console.log(Dylan); 結果 即使在使 new創造一個物件之後，才使用.prototype創造eat2()，物件實體的__proto__中依然可以找到該屬性，而這和JS的傳參考特性有關。 封裝成函數，避免在使用函數建構子時忘記寫new在上面容易出錯的地方提到，在使用函數建構子如果忘了在前面加上 new 可能會造成一些很難發現的問題。這邊提供一個方式可以有效避免這個情況。 12345678function A(name, age) &#123; this.name = name, this.age = age&#125;var $ = function(name, age) &#123; return new A(name, age)&#125; 我們設定了一個函數 $ ，在這個函數中把創造物件的動作 new在裡面執行完畢後並且回傳，如此一來我們就不需要在每次創造物件實體 instance的時候都加上一次new，也可以不用擔心忘了加上new產生不好的結果。 12var person = $('dylan', 18);console.log(person) 資料來源 MDN PJchender - 談談JavaScript中的function constructor和關鍵字new SimonAllen - Day27 函式建構子與new 原型基礎物件導向 JavaScript 全攻略：克服JS的奇怪部分 5-57]]></content>
      <categories>
        <category>JavaScript</category>
        <category>克服JS的奇怪部分</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>克服JS的奇怪部分</tag>
        <tag>原型繼承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 的 Reflection and Extend]]></title>
    <url>%2Freflection-and-extend.html</url>
    <content type="text"><![CDATA[Reflection一個物件可以列出自己有哪些成員。 利用 Reflection可以實現一個有用的模式，叫做 extend用來將一個物件的所有成員複製到另一個物件裡。 123456789101112var A = &#123; firstname: 'Dylan', lastname: 'Liu', getFullName: function()&#123; return this.firstname + ' ' + this.lastname; &#125;&#125;var B = &#123; firstname: 'Eva', lastname: 'Lin'&#125; for in可以將目標內的屬性全都遍歷、loop一輪，而現在要把 B每個 屬性 property和 值 value都取出來 12345B.__proto__ = A;for (var prop in B) &#123; console.log(prop + ':' + B[prop])&#125; B[prop]是 &quot;.&quot;運算子的另一種寫法，並不是陣列。如 B.fristname 也可以寫做 B[&#39;firstname&#39;]，因為這邊採用變數做歷遍的關係，因此只能使用[]運算子。( 關於這部分可以參考 SimonAllen - Day12 物件與點 ) B其實沒有getFullName這個方法，因為B的原型物件A有，for in還是順著原型鏈把其他屬性都取出來了。 我們可以用JavaScript物件內建的方法hasOwnProperty來幫助我們篩選，將for in程式碼改成這樣 hasOwnProperty可以檢查屬性，若是該物件本身的成員才會回傳 true，.__proto__內的屬則回傳 false，因此這裡的 if判斷，console.log只會印出 B本身有的屬性。 Extend 利用 Reflection 可以列出自己所有成員的方法，就可以實做 extend功能，用來合併多個物件的所有成員。extend 在各種函式庫都有實做，所以這邊我們不自己寫而是使用 underscore.js 提供的。 使用 extend後，物件john獲得了另外兩個物件jane、jim的屬性與方法，並不是說john去原型鏈查找，而是利用extend函式新增了原本沒有的屬性，我們現在可以直接操作john最初沒有的屬性了。 12345678910111213141516171819202122232425var john = &#123; firstname: 'John', lastname: 'Doe'&#125;var jane = &#123; address: '111 Main St.', getFormalFullName: function()&#123; return this.lastname + ', ' + this.firstname; &#125;&#125;var jim = &#123; getFirstName: function()&#123; return firstname; &#125;&#125;// 要先載入 underscore.js_.extend(john, jane, jim);// 使用 extend 後，物件 john 就雍有另外兩個物件的所有成員了console.log(john.address); // 顯示 111 Main St.console.log(john.getFormalFullName()); // 顯示 Doe, Johnconsole.log(john.getFirstName()); // 顯示 John 結語 extend(s) 是 JavaScript 物件導向很重要的觀念、語法，ES6已有新增內建的extends函數，另外 ES6的 extends和 underscore.js的 extend並未衝突，因為差了一個 s字母。 有 extend 可以用的話，就不需要每次都使用原型鏈了。 資料來源： SimonAllen - Day26 物件型別、Reflection and Extend [PTT分享] 克服JS的奇怪部分 ch5 JS的物件導向與原型繼承 JavaScript 全攻略：克服JS的奇怪部分 5-56]]></content>
      <categories>
        <category>JavaScript</category>
        <category>克服JS的奇怪部分</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>克服JS的奇怪部分</tag>
        <tag>原型繼承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[窺探 JS 原型鏈的盡頭]]></title>
    <url>%2Fproto.html</url>
    <content type="text"><![CDATA[這篇筆記延伸上一篇所提到的原型（prototype）的概念。 純值與物件型別JavaScript 上所有的東西可以分成兩大類：純值 Primitive Types和物件型別 Object Type 基本型別(純值) Primitive Types 數字 number 字串 string 布林值 boolean undefined null 符號 symbol （ES6) 物件型別 Object TypeJavaScript 中除了 Primitive Types 以外的東西，全都是物件型別！ 上述包含 數字、字串、布林值、物件、陣列、函數都有 __proto__ 原型，且盡頭都會是 物件。 實驗假設我們現在分別建立物件、函式和陣列： 123456789101112131415161718192021// Objectvar obj = &#123; name: 'Dylan',&#125;// functionvar func = function () &#123; console.log('Hello')&#125;// Arrayvar arr = ['this', 'is', 'an', 'array']// stringvar str = 'This is string'// numbervar num = 3// booleanvar boo = false 接著，我們會在 Google Chrome 的 console 視窗來分別檢視這些變數的__proto__。 物件 ( Object )我們可以看到obj 這個物件本身的 __proto__ 也是一個物件，在下去就沒了（null），也就是 Object → Object → null。 而 obj.__proto__ 就是物件的原型物件，打開來看會發現裡面有許多 JavaScript 中專屬物件的內建方法。 如果我在 console 中輸入 obj.，也會出現一樣的 JavaScript 中專屬物件的內建方法： 由於 obj.__proto__ 仍然是一個物件，所以如果我輸入 obj.__proto__.的話，會得到一樣對於物件可以使用的方法： 函數 ( Function )接著我們來看看函式，它會是 function → function → object → null，所以最後還是結束在 object。 如果我們想要看函式有哪些內建的方法可以用，我們可以輸入func. 或 func.__proto__. 就可以看到了，這裡我們就可以看到我們之前使用的 apply, bind, 和 call。 陣列 ( Array )再來陣列的話則是array → array → object → null。 如果我們要看陣列有哪些方法可以用，一樣可以透過 arr. 或 arr.__proto__. 來檢視 這樣看下來可以知道：JS 物件的原型仍會是物件，而原型鏈的終點，就是 null。 字串、數字和布林值同樣的方法也可以用來檢視字串、數字和布林值，這邊就不做下去了，打開 console 來試試看吧。 資料來源 PJchender - JavaScript 中，任何東西的 prototype 到最後都是物件（object） SimonAllen - 物件型別、Reflection and Extend JavaScript 全攻略：克服 JS 的奇怪部分 5-55]]></content>
      <categories>
        <category>JavaScript</category>
        <category>克服JS的奇怪部分</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>克服JS的奇怪部分</tag>
        <tag>原型繼承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型(prototype)、原型鍊（prototype chain）和繼承(inheritance)]]></title>
    <url>%2Fprototype-and-inheritance.html</url>
    <content type="text"><![CDATA[這篇筆記主要說明了 JavaScript 中非常重要的概念，也就是繼承（inheritance）、原型（prototype）和原型鍊（prototype chain）。 繼承 ( inheritance )1. 定義繼承即一個物件擁有另一個物件的屬性(property)和方法(method) 2. 古典繼承及原型繼承 古典繼承(classical inheritance) C#、JAVA常用到的物件繼承方式，古典繼承很流行，也解決了很多問題，但樹狀結構物件的互動模式，一但數量增加，很容易產生複雜、龐大的集合。而對於古典繼承，講師提到一種很貼切的形容，就像是今天你打開了燈，馬桶卻突然沖水了。 原型繼承(prototypal inheritance) JavaScript的物件繼承種類，相對古典繼承簡易、彈性。 原型鍊 ( prototype chain )由於 JavaScript使用的是 原型繼承 prototypal inheritance，所以必然會包含原型（prototype）的概念。 一個物件裡面除了所給予的屬性值外，另外也包含一個原型物件__proto__。 1obj.prop1 現在有一個物件obj，而這個物件包含屬性(property)稱做prop1，並可以使用obj.prop1來取用這個屬性。 1obj.prop2 如果要存取obj.prop2 ，JavaScript 引擎會先在 obj 這個物件的屬性裡去尋找有沒有叫作 prop2 的屬性，如果它找不到，這時候它就會再進一步往該物件的原型物件 __proto__ 裡面去尋找。所以，雖然我們輸入 obj.prop2 的時候會得到回傳值不報錯，但實際上這不是 obj 裡面直接的屬性名稱，而是在 obj 的 __proto__ 裡面找到的屬性名稱（ 即obj.proto.prop2但我們不需要這樣打）。 1obj.prop3 同樣的，每個物件都包含一個原型物件__proto__，包含__proto__本身也不例外，所以如果輸入obj.prop3，JavaScript會先在obj裡尋找，找不到會再往obj.__proto__找，若還是找不到，他就會再往obj.__proto__.__proto__繼續找下去，找到最底層為止。 物件往原型物件查找，再往原型物件的原型物件查找，再往原型物件的原(下略)一直找，鏈接下來的這個型態，就稱為Prototypal Chain原型鏈。 原型鏈查找與範圍鏈scope chain(外部參照)是不一樣的東西，前者是去物件的原型對象找屬性和方法，後者是往外部執行環境找變數，這兩者不可搞混。 JS的原型繼承特性，不同的物件可以指向同一個原型物件若今天有個物件obj2，它可以是和obj1有同樣的原型物件__proto__的。 123456789101112var person = &#123; firstName: 'Default', lastName: 'Default', getFullName: function() &#123; return this.firstName + ' ' + this.lastName; &#125;,&#125;;var john = &#123; firstName: 'John', lastName: 'Doe',&#125;; 創建兩個物件person、john，他們都有屬性firstname與lastname，只有person有方法getFullName。 1john.__proto__ = person; 將john的原型proto指向person，現在john的原型是person了 警告: 這樣的指向方式是為了讓人更好理解，在現實開發不可以用這樣的方式。 1console.log(john.getFullName()) //John Doe; 我們可以得到 &quot;John Doe&quot; 的結果。原本在 john 的這個物件中，是沒有 getFullName() 這個方法的，但由於我讓john物件的原型物件__proto__變成了 person 這個物件，所以當 JavaScript 引擎在 john 物件裡面找不到getFullName() 這個方法時，它便會到__proto__裡面去找，最後它找到了，於是它回傳 &quot;John Doe&quot;的結果。 1console.log(john.firstName); //John 我們會得到的是 John 而不是 &#39;Default&#39;，因為 JavaScript 引擎在尋找 john.firstName 這個屬性時，在john 這個物件裡就可以找到了，因此它不會在往 __proto__ 裡面找。這也就是剛剛在上面所的原型鍊（prototype chain）的概念， 一旦它在上層的部分找到該屬性或方法時，就不會在往下層的proto去尋找。 在了解了prototype chain這樣的概念後，讓我們接著看下面這段程式碼：123456var jane =&#123; firstName: 'Jane'&#125;jane.__proto__ = person;console.log(jane.getFullName()); 現在，你可以理解到會輸出什麼結果嗎？答案是 &quot;Jane Default&quot; 。因為在 jane 這個物件裡只有 firstName 這個屬性，所以當 JavaScript 引擎要尋找 getFullName() 這個方法和 lastName 這個屬性時，它都會去找 __proto__ 裡面，而這裡面找到的就是一開始建立的person 這個物件的內容。 完整範例程式123456789101112131415161718192021222324var person = &#123; firstName:'Default', lastName:'Default', getFullName: function()&#123; return this.firstName+ ' ' + this.lastName; &#125;&#125;var john = &#123; firstName:'John', lastName:'Doe'&#125;john.__proto__ = person;console.log(john.getFullName()); // John Doeconsole.log(john.firstName); // Johnvar jane =&#123; firstName: 'Jane'&#125;jane.__proto__ = person;console.log(jane.getFullName()); 資料來源 JavaScript深入之从原型到原型链 SimonAllen - Day25 古典與原型繼承、瞭解原型 JavaScript 全攻略：克服JS的奇怪部分 - 5-53、5-54]]></content>
      <categories>
        <category>JavaScript</category>
        <category>克服JS的奇怪部分</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>克服JS的奇怪部分</tag>
        <tag>原型繼承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLens 筆記]]></title>
    <url>%2Fgitlens.html</url>
    <content type="text"><![CDATA[圖片來源： 網路 查看過去版本紀錄開啟GitLens後，可以看到index.html總共有三次commit紀錄 ，包含一個uncommited changes [下圖1.] 註: uncommited changes就是工作區版本( 還沒有add ) [下圖2] 與前一個版本對比指定你想對照的版本紀錄 [下圖1.] ，GitLens會對比指定版本與他的前一個版本 [下圖2.]註: [下圖3.] 功能下一段解釋 工作區與指定版本做比對 指定想對應的版本 [下圖1.] 點擊 [下圖2.] 按鈕，即可讓指定版本與工作區版本進行比對]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Sync Setting 在多台裝置上同步 VScode 設定]]></title>
    <url>%2Fvscode-sync-setting.html</url>
    <content type="text"><![CDATA[圖片來源: https://medium.com/@mvpdw06/ Sync Setting教學如何在不同的電腦上同步 VS Code 的設定？ 補充：下載備份 / 上傳備份的錯誤問題同步遇到錯誤，可能是Gist ID有過期問題 處理步驟開啟你的 Github頁面，至 settings / Developer settings / Personal Access Tokens，選擇你的 vscode gist。 點選 Regenerate token。 取得新的Gist ID 。 回到 VS code，使用快捷鍵 F1，輸入 sync，選擇 Sync：advanced optin 。 選擇 Sync：Edit Extension Local Settings 。 進入 syncLocalSettings.json 找到 &quot;token&quot; ，貼上新的 Gist ID 。]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用指令]]></title>
    <url>%2Fgit-command.html</url>
    <content type="text"><![CDATA[圖片來源： 網路 操作基礎設定查詢版本 1git version 查詢設定細項 1git config --list 開啟 git 設定檔案 1code ~/.gitconfig 1open ~/.gitconfig 輸入姓名 1git config -global user.name '名字' 輸入信箱 1git config -global user.email '信箱' 自訂 git 指令名稱 ( 將git status指令簡短改成git st ) 1git config --global alias.st status 本地資料夾新增數據庫 1git init 增加/刪除檔案 Untracked =&gt; 還沒被add過的檔案(新增的檔案) Tracked not staged =&gt; 已被add過，但之後又做過編輯、刪除..等，還沒有再次add的檔案 Staged wait commit =&gt; 最後一次add版本 (存檔的概念，若之後有問題可以直接做git checkout [該檔名]，即可把這個存檔紀錄叫回) 實際操作思路 存檔就像小時候玩 gameboy 一樣，好不容易遇到了幻獸而且收服了他，你一定不會希望突然沒電或當機，所以機靈如你一定會立馬把這個里程碑儲存起來。 - 那 Git 呢? 很簡單，今天你的程式碼到一個里程碑了，只需要將關鍵的幾個檔案add，基本上就完成了這個紀錄的儲存，之後隨便你怎麼修改，改爛了直接git checkout [該檔名]即可時光倒流回暫存區的版本 - 那想進一步回到上個 commit 點?而不是暫存區的話呢?很簡單，查詢你想回去的 commit 點的commit id，然後git checkout [id] [該檔名]。 乾淨的 commit 紀錄 盡量別使用git add . + git commit，比如說這次我新增了一個 navbar，共修改了 index.html 和 all.scss， 但過程中也有修改 all.js 和 member.html，但是這個 commit 的名稱我預計是’add navbar’，那就不須把不相干的其他兩隻檔案也加進這個紀錄中，所以我只需git add index.html all.scss然後git commit -m &#39;add navbar&#39;就好。 已進入儲存庫的 commit 是很難改變的，請謹慎，也盡量避免個資、商業機密等資料被簽入儲存庫。 將所有檔案加入索引 1git add . 將單一檔案加入索引 1git add [檔名] 查詢索引狀態 1git status 將索引提交到本地數據庫 1git commit -m '說明文字' 查詢歷史 commit 紀錄 123git loggit log --oneline -[n] //最近n次的紀錄git reflog //查看所有訊息版本 (包含刪除的commit紀錄和reset紀錄) 檔案還原 模式名稱 master 的位置 索引 工作目錄 --soft 回到指定點 不變 不變 --mixed 回到指定點 綠變紅 不變 --hard 回到指定點 清空 清空 註: --mixed為預設 往前一個 commit 點 往前數個 commit 點 HEAD^ HEAD^^^^ HEAD~ HEAD~4 註 1: HEAD 可以用 commit id 取代git reset de2d32 註 2: 若不加上 HEAD 或是 commit id，系統預設為 HEADgit reset === git reset HEAD 常用指令 1234git reset --hard HEAD^ // HEAD、工作區、索引皆退回前一個commit點git reset --soft HEAD^ // HEAD退回一個commit，保留索引和工作目錄git reset HEAD // HEAD、工作目錄不變、取消索引git reset HEAD [檔名] // 同上，單一檔案 上面語法刪除錯了可以用此語法還原 1git reset --hard ORIG_HEAD 恢復到 commit 點 ★ 123git checkout [檔名] // 單一檔案回到最新commit點git checkout [commit id] // 回到該commit點git checkout [commit id] --[檔案名稱] // 該檔案回到該commit點 覆蓋最後一次 commit 12git add [檔名] // 如果要多加檔案才要執行，單純改commit說明可以只執行下一行git commit --amend -m '訊息' // 送出後會取代最後一個commit紀錄 查看所有 untracked 檔案 1git clean -n 刪除所有 untracked 檔案 1git clean -f 移除特定檔案的工作區變更 1git checkout -- [目標檔案名稱] 新增本地/遠端數據庫 複製遠端數據庫 1git clone [url] 如要 clone 最近一次的 history，而且也需要其他 branch，使用如下， 1git clone [url] --depth 1 --no-single-branch 如要 clone 最近一次的 history，而且不需要其他 branch，使用如下， 1git clone [url] --depth 1 --single-branch or 1git clone [url] --depth 1 查詢遠端數據庫數量及名稱 1git remote 將本地數據庫與遠端數據庫做連結 1git remote add [遠端數據庫名稱（預設為origin）] [遠端數據庫 url] 可新增多個遠端數據庫 本地的 Git 數據庫可以同時有擁有多個遠端數據庫，常見的情況為一個遠端數據庫作為測試使用，當測試過通後，再推送至正式版的遠端數據庫，請注意，遠端數據庫稱不可重複。 1git remote add [自定義數據庫名稱（不重複）] [遠端數據庫 url] 將本地數據庫推送到遠端數據庫 1git push [遠端數據庫名稱（預設為origin）] [遠端數據庫的分支名稱（預設為master）] 設定預設推送的遠端數據庫 假如擁有多個遠端數據庫，輸入此指令後，未來輸入git push，Git 將會自動預設推送至你所設定的遠端數據庫的 master 分支。 1git push -u [某個已存在的遠端數據庫名稱] master 將遠端分支拉下來與本地分支進行合併 1git pull 將遠端儲存庫的最新版下載回來，下載的內容包含完整的物件儲存庫(object storage)。這個命令不包含「合併」分支的動作。此時你的分支會多一個 FETCH_HEAD 的分支，而這個就是遠端數據庫的分支，可以等到你看過沒問題後，再用git merge FETCH_HEAD做合併。 1git fetch [遠端數據庫名稱] [遠端分支名稱] 重新命名遠端數據庫 1git remote rename [修改後的名稱] 分支只要記住使用 branch 其實就是在說：「我想要包含這一次的 commit 以及它的所有 parent 的 commit。」 顯示分支資訊 12git branch \\本地git branch -r. \\遠端 新增分支 1git branch [分支名稱] 切換分支 1git checkout [分支名稱] 合併指定分支到目前分支 1git merge [分支名稱] 合併指定分支到目前分支，並且將合併後的結果產生成一個最新的 commit 紀錄。樹狀圖會呈現一個小耳朵的結構，有利於開發者清楚辨識當時曾進行 merge 的動作 1git merge [分支名稱] --no-ff 刪除分支 1git branch -D [分支名稱] 刪除遠端分支 加個 : 即可 1git push origin :[分支名稱] 標籤使用情境 : 重大版本里程碑紀錄 查詢標籤 1git tag 刪除標籤 1git tag -d [標籤名稱] 新增輕量標籤 1git tag [標籤名稱] 新增標示標籤 1git tag -am '標註內容' [標籤名稱] 暫存當你手上工作還沒做完也不想 commit 時就要切換到別的 branch (PM 說有一個 issue 要在 5 分鐘內解決)，手中的修改內容也會跟著移動到新 branch 讓人會很困惑，這時可以把手上工作放到暫存裡，有點像先把這些檔案 ctrl + x 剪下來 (git stash)，之後再 ctrl + v 貼回你想要的 branch (git stash pop)，另外 git stash pop 後暫存即消失技巧： 若不切回 master 而在 branch b 進行 pop 也可以將資料帶到該 branch 暫時儲存當前目錄 1git stash 查詢 stash 列表 1git stash list 還原暫存 1git stash pop 清除最新暫存 1git stash drop 清除全部暫存 1sit stash clear 注意 --global 影響整個電腦中的設定，若不輸入則只影響目前資料夾的.git 設定 commit id 可以用git log查詢，需要輸入時可以輸入 id 前四碼，git 即可辨認 參考細說 git reset 和 git checkout 的不同之處超詳細 Git 圖解我想要精通 GitGit 教學系列 - Youtubegit 練習網站]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 常用語法]]></title>
    <url>%2Fmarkdown.html</url>
    <content type="text"><![CDATA[這篇算是踏入前(ㄇㄚ ˇ)端(ㄋㄨㄥ ˊ)領域後的第一篇學習筆記，程式的學習之路實在是個無底洞，算算在工作三個月學了scss、gulp、ES6、Git、css design paterns…族繁不及備載，知道的東西得越多，發現自己不會的更多，這麼多的技術要學，好像該找個方法幫助自己消化這些東西，這篇每一篇心得都有價值——為什麼初學者才更應該要寫心得筆記是促使我想開始寫認真寫學習筆記的原因，希望自己可以養成這個好習慣。 字體類大標題# h1斜體_斜體_粗體**bold**刪除線~~刪除線~~粗斜體***斜粗體***超連結有標題的超連結1［連結](http://google.com/ &quot;Title&quot;) 有標題的照片1![Alt text](https://api.fnkr.net/testimg/200x200/00CED1/FFF/?text=img+placeholder &quot;title&quot;) 一般連結 (直接顯示網址)1&lt;http://example.com/&gt; 原生 html 標籤可以調整寬高 1&lt;img src=&quot;https://api.fnkr.net/testimg/200x200/00CED1/FFF/?text=img+placeholderwidth=&quot;150&quot; height=&quot;150&quot; /&gt; 程式區塊inline 程式碼樣式1`printf()` // 若內容也有上斜引號，則`` `printf()` ``撰寫 一般程式碼樣式123[反引號*3]js console.log(‘Hello World!’);[反引號*3] 格式分隔線1---- 引用123&gt; 一行引用&gt;&gt; 嵌套的引用&gt;&gt;&gt; 再嵌套 清單123456- Step - Step - Step- Step - Step - Step 表格1234567Age | Time | Food | Gold | Requirement--------------|:-----:|-----:| ----:|------------------------Feudal Age | 02:10 | 500 | 0 | Dark Age building x 2Castle Age | 02:40 | 800 | 200 | Feudal Age building x 2Imperial Age | 03:30 | 1000 | 800 | Castle Age building x 2// : 符號控制靠左或靠右 其他checkbox12- [x] 代辦事項- [ ] 代辦事項 字體顏色123&lt;font color=red size=72 face=&quot;微软雅黑&quot;&gt;顏色+字體大小&lt;/font&gt;&lt;font color=red size=72 face=&quot;微軟正黑體&quot;&gt;顏色+字體大小&lt;/font&gt; EmojiEmoji 代碼]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
</search>
